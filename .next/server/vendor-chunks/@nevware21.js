"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@nevware21";
exports.ids = ["vendor-chunks/@nevware21"];
exports.modules = {

/***/ "(ssr)/./node_modules/@nevware21/ts-async/dist/es5/mod/ts-async.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@nevware21/ts-async/dist/es5/mod/ts-async.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PolyPromise: () => (/* binding */ PolyPromise),\n/* harmony export */   arrForEachAsync: () => (/* binding */ arrForEachAsync),\n/* harmony export */   createAllPromise: () => (/* binding */ createAllPromise),\n/* harmony export */   createAllSettledPromise: () => (/* binding */ createAllSettledPromise),\n/* harmony export */   createAnyPromise: () => (/* binding */ createAnyPromise),\n/* harmony export */   createAsyncAllPromise: () => (/* binding */ createAsyncAllPromise),\n/* harmony export */   createAsyncAllSettledPromise: () => (/* binding */ createAsyncAllSettledPromise),\n/* harmony export */   createAsyncAnyPromise: () => (/* binding */ createAsyncAnyPromise),\n/* harmony export */   createAsyncPromise: () => (/* binding */ createAsyncPromise),\n/* harmony export */   createAsyncRacePromise: () => (/* binding */ createAsyncRacePromise),\n/* harmony export */   createAsyncRejectedPromise: () => (/* binding */ createAsyncRejectedPromise),\n/* harmony export */   createAsyncResolvedPromise: () => (/* binding */ createAsyncResolvedPromise),\n/* harmony export */   createIdleAllPromise: () => (/* binding */ createIdleAllPromise),\n/* harmony export */   createIdleAllSettledPromise: () => (/* binding */ createIdleAllSettledPromise),\n/* harmony export */   createIdleAnyPromise: () => (/* binding */ createIdleAnyPromise),\n/* harmony export */   createIdlePromise: () => (/* binding */ createIdlePromise),\n/* harmony export */   createIdleRacePromise: () => (/* binding */ createIdleRacePromise),\n/* harmony export */   createIdleRejectedPromise: () => (/* binding */ createIdleRejectedPromise),\n/* harmony export */   createIdleResolvedPromise: () => (/* binding */ createIdleResolvedPromise),\n/* harmony export */   createNativeAllPromise: () => (/* binding */ createNativeAllPromise),\n/* harmony export */   createNativeAllSettledPromise: () => (/* binding */ createNativeAllSettledPromise),\n/* harmony export */   createNativeAnyPromise: () => (/* binding */ createNativeAnyPromise),\n/* harmony export */   createNativePromise: () => (/* binding */ createNativePromise),\n/* harmony export */   createNativeRacePromise: () => (/* binding */ createNativeRacePromise),\n/* harmony export */   createNativeRejectedPromise: () => (/* binding */ createNativeRejectedPromise),\n/* harmony export */   createNativeResolvedPromise: () => (/* binding */ createNativeResolvedPromise),\n/* harmony export */   createPromise: () => (/* binding */ createPromise),\n/* harmony export */   createRacePromise: () => (/* binding */ createRacePromise),\n/* harmony export */   createRejectedPromise: () => (/* binding */ createRejectedPromise),\n/* harmony export */   createResolvedPromise: () => (/* binding */ createResolvedPromise),\n/* harmony export */   createSyncAllPromise: () => (/* binding */ createSyncAllPromise),\n/* harmony export */   createSyncAllSettledPromise: () => (/* binding */ createSyncAllSettledPromise),\n/* harmony export */   createSyncAnyPromise: () => (/* binding */ createSyncAnyPromise),\n/* harmony export */   createSyncPromise: () => (/* binding */ createSyncPromise),\n/* harmony export */   createSyncRacePromise: () => (/* binding */ createSyncRacePromise),\n/* harmony export */   createSyncRejectedPromise: () => (/* binding */ createSyncRejectedPromise),\n/* harmony export */   createSyncResolvedPromise: () => (/* binding */ createSyncResolvedPromise),\n/* harmony export */   createTaskScheduler: () => (/* binding */ createTaskScheduler),\n/* harmony export */   createTimeoutPromise: () => (/* binding */ createTimeoutPromise),\n/* harmony export */   doAwait: () => (/* binding */ doAwait),\n/* harmony export */   doAwaitResponse: () => (/* binding */ doAwaitResponse),\n/* harmony export */   doFinally: () => (/* binding */ doFinally),\n/* harmony export */   doWhileAsync: () => (/* binding */ doWhileAsync),\n/* harmony export */   iterForOfAsync: () => (/* binding */ iterForOfAsync),\n/* harmony export */   setCreatePromiseImpl: () => (/* binding */ setCreatePromiseImpl),\n/* harmony export */   setDefaultIdlePromiseTimeout: () => (/* binding */ setDefaultIdlePromiseTimeout),\n/* harmony export */   setDefaultIdleTimeout: () => (/* binding */ setDefaultIdleTimeout),\n/* harmony export */   setPromiseDebugState: () => (/* binding */ setPromiseDebugState)\n/* harmony export */ });\n/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @nevware21/ts-utils */ \"(ssr)/./node_modules/@nevware21/ts-utils/dist/es5/mod/ts-utils.js\");\n/*!\n * NevWare21 Solutions LLC - ts-async, 0.5.4\n * https://github.com/nevware21/ts-async\n * Copyright (c) NevWare21 Solutions LLC and contributors. All rights reserved.\n * Licensed under the MIT license.\n */\n\n\nvar STR_PROMISE = \"Promise\";\nvar DONE = \"done\";\nvar VALUE = \"value\";\nvar RETURN = \"return\";\nvar REJECTED = \"rejected\";\n\nfunction doAwaitResponse(value, cb) {\n    return doAwait(value, function (value) {\n        return cb ? cb({\n            status: \"fulfilled\",\n            rejected: false,\n            value: value\n        }) : value;\n    }, function (reason) {\n        return cb ? cb({\n            status: REJECTED,\n            rejected: true,\n            reason: reason\n        }) : reason;\n    });\n}\nfunction doAwait(value, resolveFn, rejectFn, finallyFn) {\n    var result = value;\n    try {\n        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(value)) {\n            if (resolveFn || rejectFn) {\n                result = value.then(resolveFn, rejectFn);\n            }\n        }\n        else {\n            try {\n                if (resolveFn) {\n                    result = resolveFn(value);\n                }\n            }\n            catch (err) {\n                if (rejectFn) {\n                    result = rejectFn(err);\n                }\n                else {\n                    throw err;\n                }\n            }\n        }\n    }\n    finally {\n        if (finallyFn) {\n            doFinally(result, finallyFn);\n        }\n    }\n    return result;\n}\nfunction doFinally(value, finallyFn) {\n    var result = value;\n    if (finallyFn) {\n        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(value)) {\n            if (value.finally) {\n                result = value.finally(finallyFn);\n            }\n            else {\n                result = value.then(function (value) {\n                    finallyFn();\n                    return value;\n                }, function (reason) {\n                    finallyFn();\n                    throw reason;\n                });\n            }\n        }\n        else {\n            finallyFn();\n        }\n    }\n    return result;\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction _pureAssign(func1, func2) {\n    return func1 || func2;\n}\n\nvar _debugState;\nvar _debugResult;\nvar _debugHandled;\nvar _promiseDebugEnabled = false;\nfunction _addDebugState$1(thePromise, stateFn, resultFn, handledFn) {\n    _debugState = _debugState || { toString: function () { return \"[[PromiseState]]\"; } };\n    _debugResult = _debugResult || { toString: function () { return \"[[PromiseResult]]\"; } };\n    _debugHandled = _debugHandled || { toString: function () { return \"[[PromiseIsHandled]]\"; } };\n    var props = {};\n    props[_debugState] = { get: stateFn };\n    props[_debugResult] = { get: resultFn };\n    props[_debugHandled] = { get: handledFn };\n    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProperties)(thePromise, props);\n}\nfunction setPromiseDebugState(enabled, logger) {\n    _promiseDebugEnabled = enabled;\n}\n\nvar STRING_STATES =  [\n    \"pending\", \"resolving\", \"resolved\", REJECTED\n];\n\nvar DISPATCH_EVENT = \"dispatchEvent\";\nvar _hasInitEvent;\nfunction _hasInitEventFn(doc) {\n    var evt;\n    if (doc && doc.createEvent) {\n        evt = doc.createEvent(\"Event\");\n    }\n    return (!!evt && evt.initEvent);\n}\nfunction emitEvent(target, evtName, populateEvent, useNewEvent) {\n    var doc = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getDocument)();\n    !_hasInitEvent && (_hasInitEvent = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(!!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.safe)(_hasInitEventFn, [doc]).v));\n    var theEvt = _hasInitEvent.v ? doc.createEvent(\"Event\") : (useNewEvent ? new Event(evtName) : {});\n    populateEvent && populateEvent(theEvt);\n    if (_hasInitEvent.v) {\n        theEvt.initEvent(evtName, false, true);\n    }\n    if (theEvt && target[DISPATCH_EVENT]) {\n        target[DISPATCH_EVENT](theEvt);\n    }\n    else {\n        var handler = target[\"on\" + evtName];\n        if (handler) {\n            handler(theEvt);\n        }\n        else {\n            var theConsole = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getInst)(\"console\");\n            theConsole && (theConsole[\"error\"] || theConsole[\"log\"])(evtName, (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(theEvt));\n        }\n    }\n}\n\nvar NODE_UNHANDLED_REJECTION = \"unhandledRejection\";\nvar UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase();\nvar _currentPromiseId = [];\nvar _uniquePromiseId = 0;\nvar _unhandledRejectionTimeout = 10;\nvar _aggregationError;\nvar _hasPromiseRejectionEvent;\nfunction dumpFnObj(value) {\n    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value)) {\n        return value.toString();\n    }\n    return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(value);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createAggregationError(values) {\n    !_aggregationError && (_aggregationError = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.safe)(_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getInst, [\"AggregationError\"]).v || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCustomError)(\"AggregationError\", function (self, args) {\n        self.errors = args[0];\n    })));\n    return new _aggregationError.v(values);\n}\nfunction _createPromise(newPromise, processor, executor) {\n    var additionalArgs = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrSlice)(arguments, 3);\n    var _state = 0 ;\n    var _hasResolved = false;\n    var _settledValue;\n    var _queue = [];\n    var _id = _uniquePromiseId++;\n    var _parentId = _currentPromiseId.length > 0 ? _currentPromiseId[_currentPromiseId.length - 1] : undefined;\n    var _handled = false;\n    var _unHandledRejectionHandler = null;\n    var _thePromise;\n    function _then(onResolved, onRejected) {\n        try {\n            _currentPromiseId.push(_id);\n            _handled = true;\n            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();\n            _unHandledRejectionHandler = null;\n            var thenPromise = newPromise(function (resolve, reject) {\n                _queue.push(function () {\n                    try {\n                        var handler = _state === 2  ? onResolved : onRejected;\n                        var value = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(handler) ? _settledValue : ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(handler) ? handler(_settledValue) : handler);\n                        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(value)) {\n                            value.then(resolve, reject);\n                        }\n                        else if (handler) {\n                            resolve(value);\n                        }\n                        else if (_state === 3 ) {\n                            reject(value);\n                        }\n                        else {\n                            resolve(value);\n                        }\n                    }\n                    catch (e) {\n                        reject(e);\n                    }\n                });\n                if (_hasResolved) {\n                    _processQueue();\n                }\n            }, additionalArgs);\n            return thenPromise;\n        }\n        finally {\n            _currentPromiseId.pop();\n        }\n    }\n    function _catch(onRejected) {\n        return _then(undefined, onRejected);\n    }\n    function _finally(onFinally) {\n        var thenFinally = onFinally;\n        var catchFinally = onFinally;\n        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(onFinally)) {\n            thenFinally = function (value) {\n                onFinally && onFinally();\n                return value;\n            };\n            catchFinally = function (reason) {\n                onFinally && onFinally();\n                throw reason;\n            };\n        }\n        return _then(thenFinally, catchFinally);\n    }\n    function _strState() {\n        return STRING_STATES[_state];\n    }\n    function _processQueue() {\n        if (_queue.length > 0) {\n            var pending = _queue.slice();\n            _queue = [];\n            _handled = true;\n            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();\n            _unHandledRejectionHandler = null;\n            processor(pending);\n        }\n    }\n    function _createSettleIfFn(newState, allowState) {\n        return function (theValue) {\n            if (_state === allowState) {\n                if (newState === 2  && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(theValue)) {\n                    _state = 1 ;\n                    theValue.then(_createSettleIfFn(2 , 1 ), _createSettleIfFn(3 , 1 ));\n                    return;\n                }\n                _state = newState;\n                _hasResolved = true;\n                _settledValue = theValue;\n                _processQueue();\n                if (!_handled && newState === 3  && !_unHandledRejectionHandler) {\n                    _unHandledRejectionHandler = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.scheduleTimeout)(_notifyUnhandledRejection, _unhandledRejectionTimeout);\n                }\n            }\n        };\n    }\n    function _notifyUnhandledRejection() {\n        if (!_handled) {\n            _handled = true;\n            if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNode)()) {\n                process.emit(NODE_UNHANDLED_REJECTION, _settledValue, _thePromise);\n            }\n            else {\n                var gbl = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getWindow)() || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getGlobal)();\n                !_hasPromiseRejectionEvent && (_hasPromiseRejectionEvent = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.safe)((_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getInst), [STR_PROMISE + \"RejectionEvent\"]).v));\n                emitEvent(gbl, UNHANDLED_REJECTION, function (theEvt) {\n                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefine)(theEvt, \"promise\", { g: function () { return _thePromise; } });\n                    theEvt.reason = _settledValue;\n                    return theEvt;\n                }, !!_hasPromiseRejectionEvent.v);\n            }\n        }\n    }\n    _thePromise = {\n        then: _then,\n        \"catch\": _catch,\n        finally: _finally\n    };\n    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp)(_thePromise, \"state\", {\n        get: _strState\n    });\n    if (_promiseDebugEnabled) {\n        _addDebugState$1(_thePromise, _strState, function () { return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objToString)(_settledValue); }, function () { return _handled; });\n    }\n    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.hasSymbol)()) {\n        _thePromise[(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getKnownSymbol)(11 )] = \"IPromise\";\n    }\n    function _toString() {\n        return \"IPromise\" + (_promiseDebugEnabled ? \"[\" + _id + (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(_parentId) ? (\":\" + _parentId) : \"\") + \"]\" : \"\") + \" \" + _strState() + (_hasResolved ? (\" - \" + dumpFnObj(_settledValue)) : \"\") + (\"\");\n    }\n    _thePromise.toString = _toString;\n    (function _initialize() {\n        if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(executor)) {\n            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwTypeError)(STR_PROMISE + \": executor is not a function - \" + dumpFnObj(executor));\n        }\n        var _rejectFn = _createSettleIfFn(3 , 0 );\n        try {\n            executor.call(_thePromise, _createSettleIfFn(2 , 0 ), _rejectFn);\n        }\n        catch (e) {\n            _rejectFn(e);\n        }\n    })();\n    return _thePromise;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createAllPromise(newPromise) {\n    return function (input) {\n        var additionalArgs = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrSlice)(arguments, 1);\n        return newPromise(function (resolve, reject) {\n            try {\n                var values_1 = [];\n                var pending_1 = 1;\n                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.iterForOf)(input, function (item, idx) {\n                    if (item) {\n                        pending_1++;\n                        doAwait(item, function (value) {\n                            values_1[idx] = value;\n                            if (--pending_1 === 0) {\n                                resolve(values_1);\n                            }\n                        }, reject);\n                    }\n                });\n                pending_1--;\n                if (pending_1 === 0) {\n                    resolve(values_1);\n                }\n            }\n            catch (e) {\n                reject(e);\n            }\n        }, additionalArgs);\n    };\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createResolvedPromise(newPromise) {\n    return function (value) {\n        var additionalArgs = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrSlice)(arguments, 1);\n        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(value)) {\n            return value;\n        }\n        return newPromise(function (resolve) {\n            resolve(value);\n        }, additionalArgs);\n    };\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createRejectedPromise(newPromise) {\n    return function (reason) {\n        var additionalArgs = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrSlice)(arguments, 1);\n        return newPromise(function (_resolve, reject) {\n            reject(reason);\n        }, additionalArgs);\n    };\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createAllSettledPromise(newPromise) {\n    return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(function (input) {\n        var additionalArgs = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrSlice)(arguments, 1);\n        return newPromise(function (resolve, reject) {\n            var values = [];\n            var pending = 1;\n            function processItem(item, idx) {\n                pending++;\n                doAwaitResponse(item, function (value) {\n                    if (value.rejected) {\n                        values[idx] = {\n                            status: REJECTED,\n                            reason: value.reason\n                        };\n                    }\n                    else {\n                        values[idx] = {\n                            status: \"fulfilled\",\n                            value: value.value\n                        };\n                    }\n                    if (--pending === 0) {\n                        resolve(values);\n                    }\n                });\n            }\n            try {\n                if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(input)) {\n                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(input, processItem);\n                }\n                else if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isIterable)(input)) {\n                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.iterForOf)(input, processItem);\n                }\n                else {\n                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwTypeError)(\"Input is not an iterable\");\n                }\n                pending--;\n                if (pending === 0) {\n                    resolve(values);\n                }\n            }\n            catch (e) {\n                reject(e);\n            }\n        }, additionalArgs);\n    });\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createRacePromise(newPromise) {\n    return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(function (input) {\n        var additionalArgs = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrSlice)(arguments, 1);\n        return newPromise(function (resolve, reject) {\n            var isDone = false;\n            function processItem(item) {\n                doAwaitResponse(item, function (value) {\n                    if (!isDone) {\n                        isDone = true;\n                        if (value.rejected) {\n                            reject(value.reason);\n                        }\n                        else {\n                            resolve(value.value);\n                        }\n                    }\n                });\n            }\n            try {\n                if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(input)) {\n                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(input, processItem);\n                }\n                else if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isIterable)(input)) {\n                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.iterForOf)(input, processItem);\n                }\n                else {\n                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwTypeError)(\"Input is not an iterable\");\n                }\n            }\n            catch (e) {\n                reject(e);\n            }\n        }, additionalArgs);\n    });\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createAnyPromise(newPromise) {\n    return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(function (input) {\n        var additionalArgs = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrSlice)(arguments, 1);\n        return newPromise(function (resolve, reject) {\n            var theErros = [];\n            var pending = 1;\n            var isDone = false;\n            function processItem(item, idx) {\n                pending++;\n                doAwaitResponse(item, function (value) {\n                    if (!value.rejected) {\n                        isDone = true;\n                        resolve(value.value);\n                        return;\n                    }\n                    else {\n                        theErros[idx] = value.reason;\n                    }\n                    if (--pending === 0 && !isDone) {\n                        reject(_createAggregationError(theErros));\n                    }\n                });\n            }\n            try {\n                if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(input)) {\n                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(input, processItem);\n                }\n                else if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isIterable)(input)) {\n                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.iterForOf)(input, processItem);\n                }\n                else {\n                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwTypeError)(\"Input is not an iterable\");\n                }\n                pending--;\n                if (pending === 0 && !isDone) {\n                    reject(_createAggregationError(theErros));\n                }\n            }\n            catch (e) {\n                reject(e);\n            }\n        }, additionalArgs);\n    });\n}\n\nfunction syncItemProcessor(pending) {\n    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(pending, function (fn) {\n        try {\n            fn();\n        }\n        catch (e) {\n        }\n    });\n}\nfunction timeoutItemProcessor(timeout) {\n    var callbackTimeout = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)(timeout) ? timeout : 0;\n    return function (pending) {\n        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.scheduleTimeout)(function () {\n            syncItemProcessor(pending);\n        }, callbackTimeout);\n    };\n}\nfunction idleItemProcessor(timeout) {\n    var options;\n    if (timeout >= 0) {\n        options = {\n            timeout: +timeout\n        };\n    }\n    return function (pending) {\n        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.scheduleIdleCallback)(function (deadline) {\n            syncItemProcessor(pending);\n        }, options);\n    };\n}\n\nvar _allAsyncSettledCreator;\nvar _raceAsyncCreator;\nvar _anyAsyncCreator;\nfunction createAsyncPromise(executor, timeout) {\n    return _createPromise(createAsyncPromise, timeoutItemProcessor(timeout), executor, timeout);\n}\nvar createAsyncAllPromise = /*#__PURE__*/ _createAllPromise(createAsyncPromise);\nvar createAsyncResolvedPromise = /*#__PURE__*/ _createResolvedPromise(createAsyncPromise);\nvar createAsyncRejectedPromise = /*#__PURE__*/ _createRejectedPromise(createAsyncPromise);\nfunction createAsyncAllSettledPromise(input, timeout) {\n    !_allAsyncSettledCreator && (_allAsyncSettledCreator = _createAllSettledPromise(createAsyncPromise));\n    return _allAsyncSettledCreator.v(input, timeout);\n}\nfunction createAsyncRacePromise(values, timeout) {\n    !_raceAsyncCreator && (_raceAsyncCreator = _createRacePromise(createAsyncPromise));\n    return _raceAsyncCreator.v(values, timeout);\n}\nfunction createAsyncAnyPromise(values, timeout) {\n    !_anyAsyncCreator && (_anyAsyncCreator = _createAnyPromise(createAsyncPromise));\n    return _anyAsyncCreator.v(values, timeout);\n}\n\nvar _promiseCls;\nvar _allCreator;\nvar _allNativeSettledCreator;\nvar _raceNativeCreator;\nvar _anyNativeCreator;\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createNativePromiseHelper(name, func) {\n    !_promiseCls && (_promiseCls = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.safe)(_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getInst, [STR_PROMISE]).v) || null));\n    if (_promiseCls.v && _promiseCls.v[name]) {\n        return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(function (input, timeout) {\n            return createNativePromise(function (resolve, reject) {\n                _promiseCls.v[name](input).then(resolve, reject);\n            });\n        });\n    }\n    return func();\n}\nfunction createNativePromise(executor, timeout) {\n    !_promiseCls && (_promiseCls = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.safe)(_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getInst, [STR_PROMISE]).v) || null));\n    var PrmCls = _promiseCls.v;\n    if (!PrmCls) {\n        return createAsyncPromise(executor);\n    }\n    if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(executor)) {\n        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwTypeError)(STR_PROMISE + \": executor is not a function - \" + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(executor));\n    }\n    var _state = 0 ;\n    function _strState() {\n        return STRING_STATES[_state];\n    }\n    var thePromise = new PrmCls(function (resolve, reject) {\n        function _resolve(value) {\n            _state = 2 ;\n            resolve(value);\n        }\n        function _reject(reason) {\n            _state = 3 ;\n            reject(reason);\n        }\n        executor(_resolve, _reject);\n    });\n    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp)(thePromise, \"state\", {\n        get: _strState\n    });\n    return thePromise;\n}\nfunction createNativeAllPromise(input, timeout) {\n    !_allCreator && (_allCreator = _createNativePromiseHelper(\"all\", function () { return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(_createAllPromise(createNativePromise)); }));\n    return _allCreator.v(input, timeout);\n}\nvar createNativeResolvedPromise = /*#__PURE__*/ _createResolvedPromise(createNativePromise);\nvar createNativeRejectedPromise = /*#__PURE__*/ _createRejectedPromise(createNativePromise);\nfunction createNativeAllSettledPromise(input, timeout) {\n    !_allNativeSettledCreator && (_allNativeSettledCreator = _createNativePromiseHelper(\"allSettled\", function () { return _createAllSettledPromise(createNativePromise); }));\n    return _allNativeSettledCreator.v(input, timeout);\n}\nfunction createNativeRacePromise(values, timeout) {\n    !_raceNativeCreator && (_raceNativeCreator = _createNativePromiseHelper(\"race\", function () { return _createRacePromise(createNativePromise); }));\n    return _raceNativeCreator.v(values, timeout);\n}\nfunction createNativeAnyPromise(values, timeout) {\n    !_anyNativeCreator && (_anyNativeCreator = _createNativePromiseHelper(\"any\", function () { return _createAnyPromise(createNativePromise); }));\n    return _anyNativeCreator.v(values, timeout);\n}\n\nvar _allSyncSettledCreator;\nvar _raceSyncCreator;\nvar _anySyncCreator;\nfunction createSyncPromise(executor) {\n    return _createPromise(createSyncPromise, syncItemProcessor, executor);\n}\nvar createSyncAllPromise = /*#__PURE__*/ _createAllPromise(createSyncPromise);\nvar createSyncResolvedPromise = /*#__PURE__*/ _createResolvedPromise(createSyncPromise);\nvar createSyncRejectedPromise = /*#__PURE__*/ _createRejectedPromise(createSyncPromise);\nfunction createSyncAllSettledPromise(input, timeout) {\n    !_allSyncSettledCreator && (_allSyncSettledCreator = _createAllSettledPromise(createSyncPromise));\n    return _allSyncSettledCreator.v(input, timeout);\n}\nfunction createSyncRacePromise(values, timeout) {\n    !_raceSyncCreator && (_raceSyncCreator = _createRacePromise(createSyncPromise));\n    return _raceSyncCreator.v(values, timeout);\n}\nfunction createSyncAnyPromise(values, timeout) {\n    !_anySyncCreator && (_anySyncCreator = _createAnyPromise(createSyncPromise));\n    return _anySyncCreator.v(values, timeout);\n}\n\nvar _defaultIdleTimeout;\nvar _allIdleSettledCreator;\nvar _raceIdleCreator;\nvar _anyIdleCreator;\nfunction setDefaultIdlePromiseTimeout(idleDeadline) {\n    _defaultIdleTimeout = idleDeadline;\n}\nvar setDefaultIdleTimeout = ( /*#__PURE__*/_pureAssign(setDefaultIdlePromiseTimeout));\nfunction createIdlePromise(executor, timeout) {\n    var theTimeout = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(timeout) ? _defaultIdleTimeout : timeout;\n    return _createPromise(createIdlePromise, idleItemProcessor(theTimeout), executor, theTimeout);\n}\nvar createIdleAllPromise = /*#__PURE__*/ _createAllPromise(createIdlePromise);\nvar createIdleResolvedPromise = /*#__PURE__*/ _createResolvedPromise(createIdlePromise);\nvar createIdleRejectedPromise = /*#__PURE__*/ _createRejectedPromise(createIdlePromise);\nfunction createIdleAllSettledPromise(input, timeout) {\n    !_allIdleSettledCreator && (_allIdleSettledCreator = _createAllSettledPromise(createIdlePromise));\n    return _allIdleSettledCreator.v(input, timeout);\n}\nfunction createIdleRacePromise(values, timeout) {\n    !_raceIdleCreator && (_raceIdleCreator = _createRacePromise(createIdlePromise));\n    return _raceIdleCreator.v(values, timeout);\n}\nfunction createIdleAnyPromise(values, timeout) {\n    !_anyIdleCreator && (_anyIdleCreator = _createAnyPromise(createIdlePromise));\n    return _anyIdleCreator.v(values, timeout);\n}\n\nvar _promiseCreator;\nvar _allSettledCreator;\nvar _raceCreator;\nvar _anyCreator;\nfunction setCreatePromiseImpl(creator) {\n    _promiseCreator = creator ? (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(creator) : null;\n}\nfunction createPromise(executor, timeout) {\n    !_promiseCreator && (_promiseCreator = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(createNativePromise));\n    return _promiseCreator.v.call(this, executor, timeout);\n}\nvar createAllPromise = /*#__PURE__*/ _createAllPromise(createPromise);\nvar createResolvedPromise = /*#__PURE__*/ _createResolvedPromise(createPromise);\nvar createRejectedPromise = /*#__PURE__*/ _createRejectedPromise(createPromise);\nfunction createAllSettledPromise(input, timeout) {\n    !_allSettledCreator && (_allSettledCreator = _createAllSettledPromise(createPromise));\n    return _allSettledCreator.v(input, timeout);\n}\nfunction createRacePromise(values, timeout) {\n    !_raceCreator && (_raceCreator = _createRacePromise(createPromise));\n    return _raceCreator.v(values, timeout);\n}\nfunction createAnyPromise(values, timeout) {\n    !_anyCreator && (_anyCreator = _createAnyPromise(createPromise));\n    return _anyCreator.v(values, timeout);\n}\n\nfunction createTimeoutPromise(timeout, resolveReject, message) {\n    return createPromise(function (resolve, reject) {\n        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.scheduleTimeout)(function () {\n            (resolveReject ? resolve : reject)(!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(message) ? message : \"Timeout of \" + timeout + \"ms exceeded\");\n        }, timeout);\n    });\n}\n\nfunction _doneChk(isDone, state, value, thisArg) {\n    var result = isDone;\n    state.res = value;\n    if (!result) {\n        if (state.isDone && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(state.isDone)) {\n            return doAwait(state.isDone.call(thisArg, state), function (done) {\n                state.iter++;\n                return !!done;\n            });\n        }\n        else {\n            result = !!state.isDone;\n        }\n    }\n    state.iter++;\n    return result;\n}\nfunction doWhileAsync(callbackFn, isDoneFn, thisArg) {\n    var promise;\n    var resolve;\n    var reject = function (reason) {\n        isDone = true;\n        throw reason;\n    };\n    var isDone = false;\n    var state = {\n        st: (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.utcNow)(),\n        iter: 0,\n        isDone: isDoneFn || false\n    };\n    if (callbackFn) {\n        var _createPromise_1 = function () {\n            return createPromise(function (res, rej) {\n                resolve = res;\n                reject = rej;\n            });\n        };\n        var _handleAsyncDone_1 = function (done) {\n            isDone = !!done;\n            if (!isDone) {\n                _processNext_1();\n            }\n            else {\n                resolve(state.res);\n            }\n        };\n        var _processNext_1 = function () {\n            while (!isDone) {\n                try {\n                    var cbResult = callbackFn.call(thisArg, state);\n                    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(cbResult)) {\n                        promise = promise || _createPromise_1();\n                        doAwait(cbResult, function (res) {\n                            try {\n                                doAwait(_doneChk(isDone, state, res, thisArg), _handleAsyncDone_1, reject);\n                            }\n                            catch (e) {\n                                reject(e);\n                            }\n                        }, reject);\n                        return promise;\n                    }\n                    else {\n                        var dnRes = _doneChk(isDone, state, cbResult, thisArg);\n                        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(dnRes)) {\n                            promise = promise || _createPromise_1();\n                            doAwait(dnRes, _handleAsyncDone_1, reject);\n                            return promise;\n                        }\n                        else {\n                            isDone = !!dnRes;\n                        }\n                    }\n                }\n                catch (e) {\n                    reject(e);\n                    return promise;\n                }\n            }\n            if (isDone && resolve) {\n                resolve(state.res);\n            }\n            return promise || state.res;\n        };\n        return _processNext_1();\n    }\n}\n\nfunction arrForEachAsync(theArray, callbackFn, thisArg) {\n    if (theArray) {\n        var len_1 = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getLength)(theArray);\n        if (len_1) {\n            var isDone = function (state) {\n                if (state.iter >= len_1 || state.res === -1) {\n                    return true;\n                }\n            };\n            return doWhileAsync(function (state) {\n                var idx = state.iter;\n                if (idx in theArray) {\n                    return callbackFn.call(thisArg || theArray, theArray[idx], idx, theArray);\n                }\n            }, isDone);\n        }\n    }\n}\n\nvar _iterSymbol;\nvar _iterAsyncSymbol;\nfunction iterForOfAsync(iter, callbackFn, thisArg) {\n    var err;\n    var iterResult;\n    var theIter = iter;\n    function onFailed(failed) {\n        err = { e: failed };\n        if (theIter.throw) {\n            iterResult = null;\n            theIter.throw(err);\n        }\n        throw failed;\n    }\n    function onFinally() {\n        try {\n            if (iterResult && !iterResult[DONE]) {\n                theIter[RETURN] && theIter[RETURN](iterResult);\n            }\n        }\n        finally {\n            if (err) {\n                throw err.e;\n            }\n        }\n    }\n    if (iter) {\n        if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isIterator)(iter)) {\n            !_iterAsyncSymbol && (_iterAsyncSymbol = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getKnownSymbol)(0 )));\n            theIter = iter[_iterAsyncSymbol.v] ? iter[_iterAsyncSymbol.v]() : null;\n            if (!theIter) {\n                !_iterSymbol && (_iterSymbol = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getKnownSymbol)(3 )));\n                theIter = iter[_iterSymbol.v] ? iter[_iterSymbol.v]() : null;\n            }\n        }\n        if (theIter && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isIterator)(theIter)) {\n            var result = void 0;\n            try {\n                result = doWhileAsync(function (state) {\n                    return doAwait(theIter.next(), function (res) {\n                        iterResult = res;\n                        if (!res[DONE]) {\n                            return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.fnCall)(callbackFn, thisArg || theIter, iterResult[VALUE], state.iter, theIter);\n                        }\n                    }, function (reason) {\n                        state.isDone = true;\n                        onFailed(reason);\n                    });\n                }, function (state) {\n                    if (!iterResult || iterResult[DONE] || state.res === -1) {\n                        onFinally();\n                        return true;\n                    }\n                }, thisArg || theIter);\n                if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(result)) {\n                    result = doFinally(result.catch(onFailed), onFinally);\n                }\n                return result;\n            }\n            catch (failed) {\n                onFailed(failed);\n            }\n            finally {\n                if (result && !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(result)) {\n                    onFinally();\n                }\n            }\n        }\n    }\n}\n\nvar REJECT = \"reject\";\nvar REJECTED_ERROR = \"Rejected\";\nvar _schedulerId = 0;\nvar _debugName;\nvar _debugIntState;\nvar _customErrors = {};\nfunction _rejectDone() {\n}\nfunction _createError(type, evt, message) {\n    !_customErrors[type] && (_customErrors[type] = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCustomError)(type));\n    var now = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.utcNow)();\n    return new (_customErrors[type])(\"Task [\".concat(evt.id, \"] \").concat(message || \"\", \"- \").concat((evt.st ? \"Running\" : \"Waiting\"), \": \").concat(_calcTime(now, evt.st || evt.cr)));\n}\nfunction _calcTime(now, start) {\n    return ((now - start) || \"0\") + \" ms\";\n}\nfunction _abortStaleTasks(taskQueue, staleTimeoutPeriod) {\n    var now = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.utcNow)();\n    var expired = now - staleTimeoutPeriod;\n    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(taskQueue, function (evt) {\n        if (evt && !evt.rj && (evt.st && evt.st < expired) || (!evt.st && evt.cr && evt.cr < expired)) {\n            evt && evt[REJECT](evt.rj || _createError(\"Aborted\", evt, \"Stale \"));\n        }\n    });\n}\nfunction _removeTask(queue, taskDetail) {\n    var idx = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrIndexOf)(queue, taskDetail);\n    if (idx !== -1) {\n        queue.splice(idx, 1);\n    }\n}\nfunction _addDebugState(theScheduler, nameFn, stateFn) {\n    _debugName = _debugName || { toString: function () { return \"[[SchedulerName]]\"; } };\n    _debugIntState = _debugIntState || { toString: function () { return \"[[SchedulerState]]\"; } };\n    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp)(theScheduler, _debugName, { get: nameFn });\n    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp)(theScheduler, _debugIntState, { get: stateFn });\n}\nfunction createTaskScheduler(newPromise, name) {\n    var _theTask;\n    var _running = [];\n    var _waiting = [];\n    var _staleTimeoutPeriod = 600000;\n    var _staleTimeoutCheckPeriod = _staleTimeoutPeriod / 10;\n    var _taskCount = 0;\n    var _schedulerName = (name ? (name + \".\") : \"\") + _schedulerId++;\n    var _blockedTimer;\n    newPromise = newPromise || createPromise;\n    var _startBlockedTimer = function () {\n        var hasTasks = ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getLength)(_running) + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getLength)(_waiting)) > 0;\n        if (_staleTimeoutPeriod > 0) {\n            if (!_blockedTimer) {\n                _blockedTimer = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.scheduleTimeout)(function () {\n                    _abortStaleTasks(_running, _staleTimeoutPeriod);\n                    _abortStaleTasks(_waiting, _staleTimeoutPeriod);\n                    _blockedTimer && (_blockedTimer.enabled = (((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getLength)(_running) + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getLength)(_waiting)) > 0));\n                }, _staleTimeoutCheckPeriod);\n                _blockedTimer.unref();\n            }\n            _blockedTimer && (_blockedTimer.enabled = hasTasks);\n        }\n    };\n    var _queueTask = function (startAction, taskName, timeout) {\n        var _a;\n        var taskId = _schedulerName + \".\" + _taskCount++;\n        if (taskName) {\n            taskId += \"-(\" + taskName + \")\";\n        }\n        var newTask = (_a = {\n                id: taskId,\n                cr: (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.utcNow)(),\n                to: timeout\n            },\n            _a[REJECT] = function (reason) {\n                newTask.rj = reason || _createError(REJECTED_ERROR, newTask);\n                newTask[REJECT] = _rejectDone;\n            },\n            _a);\n        if (!_theTask) {\n            newTask.p = newPromise(_runTask(newTask, startAction));\n        }\n        else {\n            newTask.p = _waitForPreviousTask(newTask, _theTask, startAction);\n        }\n        _theTask = newTask;\n        return newTask.p;\n    };\n    var _runTask = function (taskDetail, startAction) {\n        taskDetail.st = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.utcNow)();\n        _running.push(taskDetail);\n        _startBlockedTimer();\n        return function (onTaskResolve, onTaskReject) {\n            var _promiseReject = function (reason) {\n                taskDetail.rj = taskDetail.rj || reason || _createError(REJECTED_ERROR, taskDetail);\n                taskDetail[REJECT] = _rejectDone;\n                _doCleanup(taskDetail);\n                onTaskResolve = null;\n                onTaskReject && onTaskReject(reason);\n                onTaskReject = null;\n            };\n            var taskId = taskDetail.id;\n            if (taskDetail.rj) {\n                _promiseReject(taskDetail.rj);\n            }\n            else {\n                taskDetail[REJECT] = _promiseReject;\n                try {\n                    var startResult = startAction(taskId);\n                    if (taskDetail.to && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(startResult)) {\n                        taskDetail.t = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.scheduleTimeout)(function () {\n                            _promiseReject(_createError(\"Timeout\", taskDetail));\n                        }, taskDetail.to);\n                    }\n                    doAwait(startResult, function (theResult) {\n                        _doCleanup(taskDetail);\n                        try {\n                            onTaskResolve && onTaskResolve(theResult);\n                        }\n                        catch (e) {\n                            onTaskReject && onTaskReject(e);\n                        }\n                        onTaskReject = null;\n                        onTaskResolve = null;\n                    }, _promiseReject);\n                }\n                catch (e) {\n                    _promiseReject(e);\n                }\n            }\n        };\n    };\n    var _waitForPreviousTask = function (taskDetail, prevTask, startAction) {\n        _waiting.push(taskDetail);\n        _startBlockedTimer();\n        return newPromise(function (onWaitResolve, onWaitReject) {\n            doAwaitResponse(prevTask.p, function () {\n                _removeTask(_waiting, taskDetail);\n                _runTask(taskDetail, startAction)(onWaitResolve, onWaitReject);\n            });\n        });\n    };\n    var _doCleanup = function (taskDetail) {\n        _removeTask(_running, taskDetail);\n        taskDetail.t && taskDetail.t.cancel();\n        taskDetail.t = null;\n        if (_theTask && _theTask === taskDetail) {\n            _theTask = null;\n            if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getLength)(_running) + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getLength)(_waiting) === 0) {\n                _blockedTimer && _blockedTimer.cancel();\n                _blockedTimer = null;\n            }\n        }\n    };\n    var theScheduler = {\n        idle: true,\n        queue: _queueTask,\n        setStaleTimeout: function (staleTimeout, staleCheckPeriod) {\n            _blockedTimer && _blockedTimer.cancel();\n            _blockedTimer = null;\n            _staleTimeoutPeriod = staleTimeout;\n            _staleTimeoutCheckPeriod = staleCheckPeriod || staleTimeout / 10;\n            _startBlockedTimer();\n        }\n    };\n    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefine)(theScheduler, \"idle\", {\n        g: function () {\n            return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getLength)(_running) + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getLength)(_waiting) === 0;\n        }\n    });\n    _addDebugState(theScheduler, function () { return _schedulerName; }, function () {\n        return {\n            l: _theTask,\n            r: _running,\n            w: _waiting\n        };\n    });\n    return theScheduler;\n}\n\nvar toStringTagSymbol = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getKnownSymbol)(11 );\nvar PolyPromise = /*#__PURE__*/ (function () {\n    function PolyPromiseImpl(executor) {\n        this._$ = createAsyncPromise(executor);\n        if (toStringTagSymbol) {\n            this[toStringTagSymbol] = \"Promise\";\n        }\n        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp)(this, \"state\", {\n            get: function () {\n                return this._$.state;\n            }\n        });\n    }\n    PolyPromiseImpl.all = createAsyncAllPromise;\n    PolyPromiseImpl.race = createAsyncRacePromise;\n    PolyPromiseImpl.any = createAsyncAnyPromise;\n    PolyPromiseImpl.reject = createAsyncRejectedPromise;\n    PolyPromiseImpl.resolve = createAsyncResolvedPromise;\n    PolyPromiseImpl.allSettled = createAsyncAllSettledPromise;\n    var theProto = PolyPromiseImpl.prototype;\n    theProto.then = function (onResolved, onRejected) {\n        return this._$.then(onResolved, onRejected);\n    };\n    theProto.catch = function (onRejected) {\n        return this._$.catch(onRejected);\n    };\n    theProto.finally = function (onfinally) {\n        return this._$.finally(onfinally);\n    };\n    return PolyPromiseImpl;\n}());\n\n\n//# sourceMappingURL=ts-async.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5ldndhcmUyMS90cy1hc3luYy9kaXN0L2VzNS9tb2QvdHMtYXN5bmMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN1Yjs7QUFFdmI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0VBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrRUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx3QkFBd0I7QUFDM0QscUNBQXFDLHdCQUF3QjtBQUM3RCx1Q0FBdUMsd0JBQXdCO0FBQy9EO0FBQ0EsMkJBQTJCO0FBQzNCLDRCQUE0QjtBQUM1Qiw2QkFBNkI7QUFDN0IsSUFBSSx3RUFBbUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnRUFBVztBQUN6Qix1Q0FBdUMsc0VBQWlCLEdBQUcseURBQUk7QUFDL0Qsb0dBQW9HO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDREQUFPO0FBQ3BDLDhFQUE4RSw0REFBTztBQUNyRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQVU7QUFDbEI7QUFDQTtBQUNBLFdBQVcsNERBQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHNFQUFpQixDQUFDLHlEQUFJLENBQUMsd0RBQU8sNkJBQTZCLHNFQUFpQjtBQUMzSDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkRBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZ0VBQVcsNkJBQTZCLCtEQUFVO0FBQ3RGLDRCQUE0QixrRUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtFQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxvRUFBZTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyREFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOERBQVMsTUFBTSw4REFBUztBQUNsRCwyRUFBMkUsc0VBQWlCLENBQUMseURBQUksRUFBRSx3REFBTztBQUMxRztBQUNBLG9CQUFvQiw4REFBUyxzQkFBc0IsaUJBQWlCLHVCQUF1QjtBQUMzRjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGtFQUFhO0FBQ2pCO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0RBQStELE9BQU8sZ0VBQVcsa0JBQWtCLGdCQUFnQixrQkFBa0I7QUFDckk7QUFDQSxRQUFRLDhEQUFTO0FBQ2pCLG9CQUFvQixtRUFBYztBQUNsQztBQUNBO0FBQ0Esa0VBQWtFLGdFQUFXO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0RBQVU7QUFDdkIsWUFBWSxtRUFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNkRBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOERBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDZEQUFRO0FBQ3JDLFlBQVksa0VBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2REFBUTtBQUNyQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzRUFBaUI7QUFDNUIsNkJBQTZCLDZEQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esb0JBQW9CLDREQUFPO0FBQzNCLG9CQUFvQiwrREFBVTtBQUM5QjtBQUNBLHlCQUF5QiwrREFBVTtBQUNuQyxvQkFBb0IsOERBQVM7QUFDN0I7QUFDQTtBQUNBLG9CQUFvQixtRUFBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0VBQWlCO0FBQzVCLDZCQUE2Qiw2REFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esb0JBQW9CLDREQUFPO0FBQzNCLG9CQUFvQiwrREFBVTtBQUM5QjtBQUNBLHlCQUF5QiwrREFBVTtBQUNuQyxvQkFBb0IsOERBQVM7QUFDN0I7QUFDQTtBQUNBLG9CQUFvQixtRUFBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNFQUFpQjtBQUM1Qiw2QkFBNkIsNkRBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxvQkFBb0IsNERBQU87QUFDM0Isb0JBQW9CLCtEQUFVO0FBQzlCO0FBQ0EseUJBQXlCLCtEQUFVO0FBQ25DLG9CQUFvQiw4REFBUztBQUM3QjtBQUNBO0FBQ0Esb0JBQW9CLG1FQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxJQUFJLCtEQUFVO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMEJBQTBCLDZEQUFRO0FBQ2xDO0FBQ0EsUUFBUSxvRUFBZTtBQUN2QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseUVBQW9CO0FBQzVCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHNFQUFpQixFQUFFLHlEQUFJLENBQUMsd0RBQU87QUFDbEU7QUFDQSxlQUFlLHNFQUFpQjtBQUNoQztBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxzRUFBaUIsRUFBRSx5REFBSSxDQUFDLHdEQUFPO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywrREFBVTtBQUNuQixRQUFRLG1FQUFjLG1EQUFtRCw0REFBTztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxrRUFBYTtBQUNqQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsT0FBTyxzRUFBaUIsMkNBQTJDO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSEFBb0gsdURBQXVEO0FBQzNLO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRyxpREFBaUQ7QUFDbko7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLGdEQUFnRDtBQUMvSTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0VBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNFQUFpQjtBQUNqRDtBQUNBO0FBQ0EsMkNBQTJDLHNFQUFpQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLG9FQUFlO0FBQ3ZCLGdEQUFnRCxnRUFBVztBQUMzRCxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0VBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrRUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLDhEQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrREFBVTtBQUN2QixxREFBcUQsc0VBQWlCLENBQUMsbUVBQWM7QUFDckY7QUFDQTtBQUNBLCtDQUErQyxzRUFBaUIsQ0FBQyxtRUFBYztBQUMvRTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0RBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDJEQUFNO0FBQ3pDO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLG9CQUFvQixrRUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtFQUFhO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsc0VBQWlCO0FBQ3BFLGNBQWMsMkRBQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyREFBTTtBQUNwQjtBQUNBLElBQUksK0RBQVU7QUFDZDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsK0RBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx3QkFBd0I7QUFDekQseUNBQXlDLHdCQUF3QjtBQUNqRSxJQUFJLGtFQUFhLDZCQUE2QixhQUFhO0FBQzNELElBQUksa0VBQWEsaUNBQWlDLGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhEQUFTLGFBQWEsOERBQVM7QUFDdkQ7QUFDQTtBQUNBLGdDQUFnQyxvRUFBZTtBQUMvQztBQUNBO0FBQ0EsZ0VBQWdFLDhEQUFTLGFBQWEsOERBQVM7QUFDL0YsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJEQUFNO0FBQzFCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJEQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGtFQUFhO0FBQ3RELHVDQUF1QyxvRUFBZTtBQUN0RDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhEQUFTLGFBQWEsOERBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDhEQUFTO0FBQ2I7QUFDQSxtQkFBbUIsOERBQVMsYUFBYSw4REFBUztBQUNsRDtBQUNBLEtBQUs7QUFDTCwrQ0FBK0Msd0JBQXdCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSx3QkFBd0IsbUVBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrRUFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFNGpDO0FBQzdqQyIsInNvdXJjZXMiOlsiQzpcXHNtYXJ0LWFpLWF2YXRhci1hZ2VudFxcbm9kZV9tb2R1bGVzXFxAbmV2d2FyZTIxXFx0cy1hc3luY1xcZGlzdFxcZXM1XFxtb2RcXHRzLWFzeW5jLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTmV2V2FyZTIxIFNvbHV0aW9ucyBMTEMgLSB0cy1hc3luYywgMC41LjRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uZXZ3YXJlMjEvdHMtYXN5bmNcbiAqIENvcHlyaWdodCAoYykgTmV2V2FyZTIxIFNvbHV0aW9ucyBMTEMgYW5kIGNvbnRyaWJ1dG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgaXNQcm9taXNlTGlrZSwgb2JqRGVmaW5lUHJvcGVydGllcywgZ2V0RG9jdW1lbnQsIGNyZWF0ZUNhY2hlZFZhbHVlLCBzYWZlLCBnZXRJbnN0LCBkdW1wT2JqLCBhcnJTbGljZSwgb2JqRGVmaW5lUHJvcCwgaGFzU3ltYm9sLCBnZXRLbm93blN5bWJvbCwgaXNGdW5jdGlvbiwgdGhyb3dUeXBlRXJyb3IsIGl0ZXJGb3JPZiwgc2NoZWR1bGVUaW1lb3V0LCBpc05vZGUsIGdldFdpbmRvdywgZ2V0R2xvYmFsLCBvYmpEZWZpbmUsIG9ialRvU3RyaW5nLCBpc1VuZGVmaW5lZCwgaXNBcnJheSwgYXJyRm9yRWFjaCwgaXNJdGVyYWJsZSwgY3JlYXRlQ3VzdG9tRXJyb3IsIGlzTnVtYmVyLCBzY2hlZHVsZUlkbGVDYWxsYmFjaywgdXRjTm93LCBnZXRMZW5ndGgsIGlzSXRlcmF0b3IsIGZuQ2FsbCwgYXJySW5kZXhPZiB9IGZyb20gJ0BuZXZ3YXJlMjEvdHMtdXRpbHMnO1xuXG52YXIgU1RSX1BST01JU0UgPSBcIlByb21pc2VcIjtcbnZhciBET05FID0gXCJkb25lXCI7XG52YXIgVkFMVUUgPSBcInZhbHVlXCI7XG52YXIgUkVUVVJOID0gXCJyZXR1cm5cIjtcbnZhciBSRUpFQ1RFRCA9IFwicmVqZWN0ZWRcIjtcblxuZnVuY3Rpb24gZG9Bd2FpdFJlc3BvbnNlKHZhbHVlLCBjYikge1xuICAgIHJldHVybiBkb0F3YWl0KHZhbHVlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNiID8gY2Ioe1xuICAgICAgICAgICAgc3RhdHVzOiBcImZ1bGZpbGxlZFwiLFxuICAgICAgICAgICAgcmVqZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pIDogdmFsdWU7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICByZXR1cm4gY2IgPyBjYih7XG4gICAgICAgICAgICBzdGF0dXM6IFJFSkVDVEVELFxuICAgICAgICAgICAgcmVqZWN0ZWQ6IHRydWUsXG4gICAgICAgICAgICByZWFzb246IHJlYXNvblxuICAgICAgICB9KSA6IHJlYXNvbjtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGRvQXdhaXQodmFsdWUsIHJlc29sdmVGbiwgcmVqZWN0Rm4sIGZpbmFsbHlGbikge1xuICAgIHZhciByZXN1bHQgPSB2YWx1ZTtcbiAgICB0cnkge1xuICAgICAgICBpZiAoaXNQcm9taXNlTGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlRm4gfHwgcmVqZWN0Rm4pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZS50aGVuKHJlc29sdmVGbiwgcmVqZWN0Rm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZUZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc29sdmVGbih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChyZWplY3RGbikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZWplY3RGbihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGZpbmFsbHlGbikge1xuICAgICAgICAgICAgZG9GaW5hbGx5KHJlc3VsdCwgZmluYWxseUZuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZG9GaW5hbGx5KHZhbHVlLCBmaW5hbGx5Rm4pIHtcbiAgICB2YXIgcmVzdWx0ID0gdmFsdWU7XG4gICAgaWYgKGZpbmFsbHlGbikge1xuICAgICAgICBpZiAoaXNQcm9taXNlTGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5maW5hbGx5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUuZmluYWxseShmaW5hbGx5Rm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxseUZuKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHlGbigpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaW5hbGx5Rm4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIF9wdXJlQXNzaWduKGZ1bmMxLCBmdW5jMikge1xuICAgIHJldHVybiBmdW5jMSB8fCBmdW5jMjtcbn1cblxudmFyIF9kZWJ1Z1N0YXRlO1xudmFyIF9kZWJ1Z1Jlc3VsdDtcbnZhciBfZGVidWdIYW5kbGVkO1xudmFyIF9wcm9taXNlRGVidWdFbmFibGVkID0gZmFsc2U7XG5mdW5jdGlvbiBfYWRkRGVidWdTdGF0ZSQxKHRoZVByb21pc2UsIHN0YXRlRm4sIHJlc3VsdEZuLCBoYW5kbGVkRm4pIHtcbiAgICBfZGVidWdTdGF0ZSA9IF9kZWJ1Z1N0YXRlIHx8IHsgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiW1tQcm9taXNlU3RhdGVdXVwiOyB9IH07XG4gICAgX2RlYnVnUmVzdWx0ID0gX2RlYnVnUmVzdWx0IHx8IHsgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiW1tQcm9taXNlUmVzdWx0XV1cIjsgfSB9O1xuICAgIF9kZWJ1Z0hhbmRsZWQgPSBfZGVidWdIYW5kbGVkIHx8IHsgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiW1tQcm9taXNlSXNIYW5kbGVkXV1cIjsgfSB9O1xuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHByb3BzW19kZWJ1Z1N0YXRlXSA9IHsgZ2V0OiBzdGF0ZUZuIH07XG4gICAgcHJvcHNbX2RlYnVnUmVzdWx0XSA9IHsgZ2V0OiByZXN1bHRGbiB9O1xuICAgIHByb3BzW19kZWJ1Z0hhbmRsZWRdID0geyBnZXQ6IGhhbmRsZWRGbiB9O1xuICAgIG9iakRlZmluZVByb3BlcnRpZXModGhlUHJvbWlzZSwgcHJvcHMpO1xufVxuZnVuY3Rpb24gc2V0UHJvbWlzZURlYnVnU3RhdGUoZW5hYmxlZCwgbG9nZ2VyKSB7XG4gICAgX3Byb21pc2VEZWJ1Z0VuYWJsZWQgPSBlbmFibGVkO1xufVxuXG52YXIgU1RSSU5HX1NUQVRFUyA9ICBbXG4gICAgXCJwZW5kaW5nXCIsIFwicmVzb2x2aW5nXCIsIFwicmVzb2x2ZWRcIiwgUkVKRUNURURcbl07XG5cbnZhciBESVNQQVRDSF9FVkVOVCA9IFwiZGlzcGF0Y2hFdmVudFwiO1xudmFyIF9oYXNJbml0RXZlbnQ7XG5mdW5jdGlvbiBfaGFzSW5pdEV2ZW50Rm4oZG9jKSB7XG4gICAgdmFyIGV2dDtcbiAgICBpZiAoZG9jICYmIGRvYy5jcmVhdGVFdmVudCkge1xuICAgICAgICBldnQgPSBkb2MuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtcbiAgICB9XG4gICAgcmV0dXJuICghIWV2dCAmJiBldnQuaW5pdEV2ZW50KTtcbn1cbmZ1bmN0aW9uIGVtaXRFdmVudCh0YXJnZXQsIGV2dE5hbWUsIHBvcHVsYXRlRXZlbnQsIHVzZU5ld0V2ZW50KSB7XG4gICAgdmFyIGRvYyA9IGdldERvY3VtZW50KCk7XG4gICAgIV9oYXNJbml0RXZlbnQgJiYgKF9oYXNJbml0RXZlbnQgPSBjcmVhdGVDYWNoZWRWYWx1ZSghIXNhZmUoX2hhc0luaXRFdmVudEZuLCBbZG9jXSkudikpO1xuICAgIHZhciB0aGVFdnQgPSBfaGFzSW5pdEV2ZW50LnYgPyBkb2MuY3JlYXRlRXZlbnQoXCJFdmVudFwiKSA6ICh1c2VOZXdFdmVudCA/IG5ldyBFdmVudChldnROYW1lKSA6IHt9KTtcbiAgICBwb3B1bGF0ZUV2ZW50ICYmIHBvcHVsYXRlRXZlbnQodGhlRXZ0KTtcbiAgICBpZiAoX2hhc0luaXRFdmVudC52KSB7XG4gICAgICAgIHRoZUV2dC5pbml0RXZlbnQoZXZ0TmFtZSwgZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgICBpZiAodGhlRXZ0ICYmIHRhcmdldFtESVNQQVRDSF9FVkVOVF0pIHtcbiAgICAgICAgdGFyZ2V0W0RJU1BBVENIX0VWRU5UXSh0aGVFdnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSB0YXJnZXRbXCJvblwiICsgZXZ0TmFtZV07XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICBoYW5kbGVyKHRoZUV2dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGhlQ29uc29sZSA9IGdldEluc3QoXCJjb25zb2xlXCIpO1xuICAgICAgICAgICAgdGhlQ29uc29sZSAmJiAodGhlQ29uc29sZVtcImVycm9yXCJdIHx8IHRoZUNvbnNvbGVbXCJsb2dcIl0pKGV2dE5hbWUsIGR1bXBPYmoodGhlRXZ0KSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBOT0RFX1VOSEFORExFRF9SRUpFQ1RJT04gPSBcInVuaGFuZGxlZFJlamVjdGlvblwiO1xudmFyIFVOSEFORExFRF9SRUpFQ1RJT04gPSBOT0RFX1VOSEFORExFRF9SRUpFQ1RJT04udG9Mb3dlckNhc2UoKTtcbnZhciBfY3VycmVudFByb21pc2VJZCA9IFtdO1xudmFyIF91bmlxdWVQcm9taXNlSWQgPSAwO1xudmFyIF91bmhhbmRsZWRSZWplY3Rpb25UaW1lb3V0ID0gMTA7XG52YXIgX2FnZ3JlZ2F0aW9uRXJyb3I7XG52YXIgX2hhc1Byb21pc2VSZWplY3Rpb25FdmVudDtcbmZ1bmN0aW9uIGR1bXBGbk9iaih2YWx1ZSkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIGR1bXBPYmoodmFsdWUpO1xufVxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBfY3JlYXRlQWdncmVnYXRpb25FcnJvcih2YWx1ZXMpIHtcbiAgICAhX2FnZ3JlZ2F0aW9uRXJyb3IgJiYgKF9hZ2dyZWdhdGlvbkVycm9yID0gY3JlYXRlQ2FjaGVkVmFsdWUoc2FmZShnZXRJbnN0LCBbXCJBZ2dyZWdhdGlvbkVycm9yXCJdKS52IHx8IGNyZWF0ZUN1c3RvbUVycm9yKFwiQWdncmVnYXRpb25FcnJvclwiLCBmdW5jdGlvbiAoc2VsZiwgYXJncykge1xuICAgICAgICBzZWxmLmVycm9ycyA9IGFyZ3NbMF07XG4gICAgfSkpKTtcbiAgICByZXR1cm4gbmV3IF9hZ2dyZWdhdGlvbkVycm9yLnYodmFsdWVzKTtcbn1cbmZ1bmN0aW9uIF9jcmVhdGVQcm9taXNlKG5ld1Byb21pc2UsIHByb2Nlc3NvciwgZXhlY3V0b3IpIHtcbiAgICB2YXIgYWRkaXRpb25hbEFyZ3MgPSBhcnJTbGljZShhcmd1bWVudHMsIDMpO1xuICAgIHZhciBfc3RhdGUgPSAwIDtcbiAgICB2YXIgX2hhc1Jlc29sdmVkID0gZmFsc2U7XG4gICAgdmFyIF9zZXR0bGVkVmFsdWU7XG4gICAgdmFyIF9xdWV1ZSA9IFtdO1xuICAgIHZhciBfaWQgPSBfdW5pcXVlUHJvbWlzZUlkKys7XG4gICAgdmFyIF9wYXJlbnRJZCA9IF9jdXJyZW50UHJvbWlzZUlkLmxlbmd0aCA+IDAgPyBfY3VycmVudFByb21pc2VJZFtfY3VycmVudFByb21pc2VJZC5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgX2hhbmRsZWQgPSBmYWxzZTtcbiAgICB2YXIgX3VuSGFuZGxlZFJlamVjdGlvbkhhbmRsZXIgPSBudWxsO1xuICAgIHZhciBfdGhlUHJvbWlzZTtcbiAgICBmdW5jdGlvbiBfdGhlbihvblJlc29sdmVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBfY3VycmVudFByb21pc2VJZC5wdXNoKF9pZCk7XG4gICAgICAgICAgICBfaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICBfdW5IYW5kbGVkUmVqZWN0aW9uSGFuZGxlciAmJiBfdW5IYW5kbGVkUmVqZWN0aW9uSGFuZGxlci5jYW5jZWwoKTtcbiAgICAgICAgICAgIF91bkhhbmRsZWRSZWplY3Rpb25IYW5kbGVyID0gbnVsbDtcbiAgICAgICAgICAgIHZhciB0aGVuUHJvbWlzZSA9IG5ld1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIF9xdWV1ZS5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gX3N0YXRlID09PSAyICA/IG9uUmVzb2x2ZWQgOiBvblJlamVjdGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gaXNVbmRlZmluZWQoaGFuZGxlcikgPyBfc2V0dGxlZFZhbHVlIDogKGlzRnVuY3Rpb24oaGFuZGxlcikgPyBoYW5kbGVyKF9zZXR0bGVkVmFsdWUpIDogaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcm9taXNlTGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChfc3RhdGUgPT09IDMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoX2hhc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF9wcm9jZXNzUXVldWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBhZGRpdGlvbmFsQXJncyk7XG4gICAgICAgICAgICByZXR1cm4gdGhlblByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBfY3VycmVudFByb21pc2VJZC5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBfY2F0Y2gob25SZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gX3RoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2ZpbmFsbHkob25GaW5hbGx5KSB7XG4gICAgICAgIHZhciB0aGVuRmluYWxseSA9IG9uRmluYWxseTtcbiAgICAgICAgdmFyIGNhdGNoRmluYWxseSA9IG9uRmluYWxseTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ob25GaW5hbGx5KSkge1xuICAgICAgICAgICAgdGhlbkZpbmFsbHkgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBvbkZpbmFsbHkgJiYgb25GaW5hbGx5KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhdGNoRmluYWxseSA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICBvbkZpbmFsbHkgJiYgb25GaW5hbGx5KCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoZW4odGhlbkZpbmFsbHksIGNhdGNoRmluYWxseSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9zdHJTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIFNUUklOR19TVEFURVNbX3N0YXRlXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX3Byb2Nlc3NRdWV1ZSgpIHtcbiAgICAgICAgaWYgKF9xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgcGVuZGluZyA9IF9xdWV1ZS5zbGljZSgpO1xuICAgICAgICAgICAgX3F1ZXVlID0gW107XG4gICAgICAgICAgICBfaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICBfdW5IYW5kbGVkUmVqZWN0aW9uSGFuZGxlciAmJiBfdW5IYW5kbGVkUmVqZWN0aW9uSGFuZGxlci5jYW5jZWwoKTtcbiAgICAgICAgICAgIF91bkhhbmRsZWRSZWplY3Rpb25IYW5kbGVyID0gbnVsbDtcbiAgICAgICAgICAgIHByb2Nlc3NvcihwZW5kaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBfY3JlYXRlU2V0dGxlSWZGbihuZXdTdGF0ZSwgYWxsb3dTdGF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRoZVZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoX3N0YXRlID09PSBhbGxvd1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1N0YXRlID09PSAyICAmJiBpc1Byb21pc2VMaWtlKHRoZVZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBfc3RhdGUgPSAxIDtcbiAgICAgICAgICAgICAgICAgICAgdGhlVmFsdWUudGhlbihfY3JlYXRlU2V0dGxlSWZGbigyICwgMSApLCBfY3JlYXRlU2V0dGxlSWZGbigzICwgMSApKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgICAgICAgICBfaGFzUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF9zZXR0bGVkVmFsdWUgPSB0aGVWYWx1ZTtcbiAgICAgICAgICAgICAgICBfcHJvY2Vzc1F1ZXVlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFfaGFuZGxlZCAmJiBuZXdTdGF0ZSA9PT0gMyAgJiYgIV91bkhhbmRsZWRSZWplY3Rpb25IYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIF91bkhhbmRsZWRSZWplY3Rpb25IYW5kbGVyID0gc2NoZWR1bGVUaW1lb3V0KF9ub3RpZnlVbmhhbmRsZWRSZWplY3Rpb24sIF91bmhhbmRsZWRSZWplY3Rpb25UaW1lb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9ub3RpZnlVbmhhbmRsZWRSZWplY3Rpb24oKSB7XG4gICAgICAgIGlmICghX2hhbmRsZWQpIHtcbiAgICAgICAgICAgIF9oYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChpc05vZGUoKSkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW1pdChOT0RFX1VOSEFORExFRF9SRUpFQ1RJT04sIF9zZXR0bGVkVmFsdWUsIF90aGVQcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBnYmwgPSBnZXRXaW5kb3coKSB8fCBnZXRHbG9iYWwoKTtcbiAgICAgICAgICAgICAgICAhX2hhc1Byb21pc2VSZWplY3Rpb25FdmVudCAmJiAoX2hhc1Byb21pc2VSZWplY3Rpb25FdmVudCA9IGNyZWF0ZUNhY2hlZFZhbHVlKHNhZmUoKGdldEluc3QpLCBbU1RSX1BST01JU0UgKyBcIlJlamVjdGlvbkV2ZW50XCJdKS52KSk7XG4gICAgICAgICAgICAgICAgZW1pdEV2ZW50KGdibCwgVU5IQU5ETEVEX1JFSkVDVElPTiwgZnVuY3Rpb24gKHRoZUV2dCkge1xuICAgICAgICAgICAgICAgICAgICBvYmpEZWZpbmUodGhlRXZ0LCBcInByb21pc2VcIiwgeyBnOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhlUHJvbWlzZTsgfSB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhlRXZ0LnJlYXNvbiA9IF9zZXR0bGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGVFdnQ7XG4gICAgICAgICAgICAgICAgfSwgISFfaGFzUHJvbWlzZVJlamVjdGlvbkV2ZW50LnYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF90aGVQcm9taXNlID0ge1xuICAgICAgICB0aGVuOiBfdGhlbixcbiAgICAgICAgXCJjYXRjaFwiOiBfY2F0Y2gsXG4gICAgICAgIGZpbmFsbHk6IF9maW5hbGx5XG4gICAgfTtcbiAgICBvYmpEZWZpbmVQcm9wKF90aGVQcm9taXNlLCBcInN0YXRlXCIsIHtcbiAgICAgICAgZ2V0OiBfc3RyU3RhdGVcbiAgICB9KTtcbiAgICBpZiAoX3Byb21pc2VEZWJ1Z0VuYWJsZWQpIHtcbiAgICAgICAgX2FkZERlYnVnU3RhdGUkMShfdGhlUHJvbWlzZSwgX3N0clN0YXRlLCBmdW5jdGlvbiAoKSB7IHJldHVybiBvYmpUb1N0cmluZyhfc2V0dGxlZFZhbHVlKTsgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX2hhbmRsZWQ7IH0pO1xuICAgIH1cbiAgICBpZiAoaGFzU3ltYm9sKCkpIHtcbiAgICAgICAgX3RoZVByb21pc2VbZ2V0S25vd25TeW1ib2woMTEgKV0gPSBcIklQcm9taXNlXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF90b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwiSVByb21pc2VcIiArIChfcHJvbWlzZURlYnVnRW5hYmxlZCA/IFwiW1wiICsgX2lkICsgKCFpc1VuZGVmaW5lZChfcGFyZW50SWQpID8gKFwiOlwiICsgX3BhcmVudElkKSA6IFwiXCIpICsgXCJdXCIgOiBcIlwiKSArIFwiIFwiICsgX3N0clN0YXRlKCkgKyAoX2hhc1Jlc29sdmVkID8gKFwiIC0gXCIgKyBkdW1wRm5PYmooX3NldHRsZWRWYWx1ZSkpIDogXCJcIikgKyAoXCJcIik7XG4gICAgfVxuICAgIF90aGVQcm9taXNlLnRvU3RyaW5nID0gX3RvU3RyaW5nO1xuICAgIChmdW5jdGlvbiBfaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGV4ZWN1dG9yKSkge1xuICAgICAgICAgICAgdGhyb3dUeXBlRXJyb3IoU1RSX1BST01JU0UgKyBcIjogZXhlY3V0b3IgaXMgbm90IGEgZnVuY3Rpb24gLSBcIiArIGR1bXBGbk9iaihleGVjdXRvcikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfcmVqZWN0Rm4gPSBfY3JlYXRlU2V0dGxlSWZGbigzICwgMCApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZXhlY3V0b3IuY2FsbChfdGhlUHJvbWlzZSwgX2NyZWF0ZVNldHRsZUlmRm4oMiAsIDAgKSwgX3JlamVjdEZuKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgX3JlamVjdEZuKGUpO1xuICAgICAgICB9XG4gICAgfSkoKTtcbiAgICByZXR1cm4gX3RoZVByb21pc2U7XG59XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIF9jcmVhdGVBbGxQcm9taXNlKG5ld1Byb21pc2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHZhciBhZGRpdGlvbmFsQXJncyA9IGFyclNsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBuZXdQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlc18xID0gW107XG4gICAgICAgICAgICAgICAgdmFyIHBlbmRpbmdfMSA9IDE7XG4gICAgICAgICAgICAgICAgaXRlckZvck9mKGlucHV0LCBmdW5jdGlvbiAoaXRlbSwgaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nXzErKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvQXdhaXQoaXRlbSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzXzFbaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtLXBlbmRpbmdfMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHZhbHVlc18xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcGVuZGluZ18xLS07XG4gICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdfMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHZhbHVlc18xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgYWRkaXRpb25hbEFyZ3MpO1xuICAgIH07XG59XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIF9jcmVhdGVSZXNvbHZlZFByb21pc2UobmV3UHJvbWlzZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGFkZGl0aW9uYWxBcmdzID0gYXJyU2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZUxpa2UodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9LCBhZGRpdGlvbmFsQXJncyk7XG4gICAgfTtcbn1cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gX2NyZWF0ZVJlamVjdGVkUHJvbWlzZShuZXdQcm9taXNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgdmFyIGFkZGl0aW9uYWxBcmdzID0gYXJyU2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgcmV0dXJuIG5ld1Byb21pc2UoZnVuY3Rpb24gKF9yZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICB9LCBhZGRpdGlvbmFsQXJncyk7XG4gICAgfTtcbn1cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gX2NyZWF0ZUFsbFNldHRsZWRQcm9taXNlKG5ld1Byb21pc2UpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2FjaGVkVmFsdWUoZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHZhciBhZGRpdGlvbmFsQXJncyA9IGFyclNsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBuZXdQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBwZW5kaW5nID0gMTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NJdGVtKGl0ZW0sIGlkeCkge1xuICAgICAgICAgICAgICAgIHBlbmRpbmcrKztcbiAgICAgICAgICAgICAgICBkb0F3YWl0UmVzcG9uc2UoaXRlbSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5yZWplY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2lkeF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBSRUpFQ1RFRCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IHZhbHVlLnJlYXNvblxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlc1tpZHhdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJmdWxmaWxsZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKC0tcGVuZGluZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgICAgICAgICBhcnJGb3JFYWNoKGlucHV0LCBwcm9jZXNzSXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzSXRlcmFibGUoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJGb3JPZihpbnB1dCwgcHJvY2Vzc0l0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dUeXBlRXJyb3IoXCJJbnB1dCBpcyBub3QgYW4gaXRlcmFibGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBlbmRpbmctLTtcbiAgICAgICAgICAgICAgICBpZiAocGVuZGluZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGFkZGl0aW9uYWxBcmdzKTtcbiAgICB9KTtcbn1cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gX2NyZWF0ZVJhY2VQcm9taXNlKG5ld1Byb21pc2UpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2FjaGVkVmFsdWUoZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHZhciBhZGRpdGlvbmFsQXJncyA9IGFyclNsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBuZXdQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBpc0RvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NJdGVtKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBkb0F3YWl0UmVzcG9uc2UoaXRlbSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNEb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnJlamVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHZhbHVlLnJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyRm9yRWFjaChpbnB1dCwgcHJvY2Vzc0l0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0l0ZXJhYmxlKGlucHV0KSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVyRm9yT2YoaW5wdXQsIHByb2Nlc3NJdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93VHlwZUVycm9yKFwiSW5wdXQgaXMgbm90IGFuIGl0ZXJhYmxlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBhZGRpdGlvbmFsQXJncyk7XG4gICAgfSk7XG59XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIF9jcmVhdGVBbnlQcm9taXNlKG5ld1Byb21pc2UpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2FjaGVkVmFsdWUoZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHZhciBhZGRpdGlvbmFsQXJncyA9IGFyclNsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBuZXdQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciB0aGVFcnJvcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHBlbmRpbmcgPSAxO1xuICAgICAgICAgICAgdmFyIGlzRG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc0l0ZW0oaXRlbSwgaWR4KSB7XG4gICAgICAgICAgICAgICAgcGVuZGluZysrO1xuICAgICAgICAgICAgICAgIGRvQXdhaXRSZXNwb25zZShpdGVtLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZS5yZWplY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhlRXJyb3NbaWR4XSA9IHZhbHVlLnJlYXNvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoLS1wZW5kaW5nID09PSAwICYmICFpc0RvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChfY3JlYXRlQWdncmVnYXRpb25FcnJvcih0aGVFcnJvcykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgICAgICAgICBhcnJGb3JFYWNoKGlucHV0LCBwcm9jZXNzSXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzSXRlcmFibGUoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJGb3JPZihpbnB1dCwgcHJvY2Vzc0l0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dUeXBlRXJyb3IoXCJJbnB1dCBpcyBub3QgYW4gaXRlcmFibGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBlbmRpbmctLTtcbiAgICAgICAgICAgICAgICBpZiAocGVuZGluZyA9PT0gMCAmJiAhaXNEb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChfY3JlYXRlQWdncmVnYXRpb25FcnJvcih0aGVFcnJvcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBhZGRpdGlvbmFsQXJncyk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHN5bmNJdGVtUHJvY2Vzc29yKHBlbmRpbmcpIHtcbiAgICBhcnJGb3JFYWNoKHBlbmRpbmcsIGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiB0aW1lb3V0SXRlbVByb2Nlc3Nvcih0aW1lb3V0KSB7XG4gICAgdmFyIGNhbGxiYWNrVGltZW91dCA9IGlzTnVtYmVyKHRpbWVvdXQpID8gdGltZW91dCA6IDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwZW5kaW5nKSB7XG4gICAgICAgIHNjaGVkdWxlVGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzeW5jSXRlbVByb2Nlc3NvcihwZW5kaW5nKTtcbiAgICAgICAgfSwgY2FsbGJhY2tUaW1lb3V0KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gaWRsZUl0ZW1Qcm9jZXNzb3IodGltZW91dCkge1xuICAgIHZhciBvcHRpb25zO1xuICAgIGlmICh0aW1lb3V0ID49IDApIHtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHRpbWVvdXQ6ICt0aW1lb3V0XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAocGVuZGluZykge1xuICAgICAgICBzY2hlZHVsZUlkbGVDYWxsYmFjayhmdW5jdGlvbiAoZGVhZGxpbmUpIHtcbiAgICAgICAgICAgIHN5bmNJdGVtUHJvY2Vzc29yKHBlbmRpbmcpO1xuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICB9O1xufVxuXG52YXIgX2FsbEFzeW5jU2V0dGxlZENyZWF0b3I7XG52YXIgX3JhY2VBc3luY0NyZWF0b3I7XG52YXIgX2FueUFzeW5jQ3JlYXRvcjtcbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jUHJvbWlzZShleGVjdXRvciwgdGltZW91dCkge1xuICAgIHJldHVybiBfY3JlYXRlUHJvbWlzZShjcmVhdGVBc3luY1Byb21pc2UsIHRpbWVvdXRJdGVtUHJvY2Vzc29yKHRpbWVvdXQpLCBleGVjdXRvciwgdGltZW91dCk7XG59XG52YXIgY3JlYXRlQXN5bmNBbGxQcm9taXNlID0gLyojX19QVVJFX18qLyBfY3JlYXRlQWxsUHJvbWlzZShjcmVhdGVBc3luY1Byb21pc2UpO1xudmFyIGNyZWF0ZUFzeW5jUmVzb2x2ZWRQcm9taXNlID0gLyojX19QVVJFX18qLyBfY3JlYXRlUmVzb2x2ZWRQcm9taXNlKGNyZWF0ZUFzeW5jUHJvbWlzZSk7XG52YXIgY3JlYXRlQXN5bmNSZWplY3RlZFByb21pc2UgPSAvKiNfX1BVUkVfXyovIF9jcmVhdGVSZWplY3RlZFByb21pc2UoY3JlYXRlQXN5bmNQcm9taXNlKTtcbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jQWxsU2V0dGxlZFByb21pc2UoaW5wdXQsIHRpbWVvdXQpIHtcbiAgICAhX2FsbEFzeW5jU2V0dGxlZENyZWF0b3IgJiYgKF9hbGxBc3luY1NldHRsZWRDcmVhdG9yID0gX2NyZWF0ZUFsbFNldHRsZWRQcm9taXNlKGNyZWF0ZUFzeW5jUHJvbWlzZSkpO1xuICAgIHJldHVybiBfYWxsQXN5bmNTZXR0bGVkQ3JlYXRvci52KGlucHV0LCB0aW1lb3V0KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jUmFjZVByb21pc2UodmFsdWVzLCB0aW1lb3V0KSB7XG4gICAgIV9yYWNlQXN5bmNDcmVhdG9yICYmIChfcmFjZUFzeW5jQ3JlYXRvciA9IF9jcmVhdGVSYWNlUHJvbWlzZShjcmVhdGVBc3luY1Byb21pc2UpKTtcbiAgICByZXR1cm4gX3JhY2VBc3luY0NyZWF0b3Iudih2YWx1ZXMsIHRpbWVvdXQpO1xufVxuZnVuY3Rpb24gY3JlYXRlQXN5bmNBbnlQcm9taXNlKHZhbHVlcywgdGltZW91dCkge1xuICAgICFfYW55QXN5bmNDcmVhdG9yICYmIChfYW55QXN5bmNDcmVhdG9yID0gX2NyZWF0ZUFueVByb21pc2UoY3JlYXRlQXN5bmNQcm9taXNlKSk7XG4gICAgcmV0dXJuIF9hbnlBc3luY0NyZWF0b3Iudih2YWx1ZXMsIHRpbWVvdXQpO1xufVxuXG52YXIgX3Byb21pc2VDbHM7XG52YXIgX2FsbENyZWF0b3I7XG52YXIgX2FsbE5hdGl2ZVNldHRsZWRDcmVhdG9yO1xudmFyIF9yYWNlTmF0aXZlQ3JlYXRvcjtcbnZhciBfYW55TmF0aXZlQ3JlYXRvcjtcbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gX2NyZWF0ZU5hdGl2ZVByb21pc2VIZWxwZXIobmFtZSwgZnVuYykge1xuICAgICFfcHJvbWlzZUNscyAmJiAoX3Byb21pc2VDbHMgPSBjcmVhdGVDYWNoZWRWYWx1ZSgoc2FmZShnZXRJbnN0LCBbU1RSX1BST01JU0VdKS52KSB8fCBudWxsKSk7XG4gICAgaWYgKF9wcm9taXNlQ2xzLnYgJiYgX3Byb21pc2VDbHMudltuYW1lXSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQ2FjaGVkVmFsdWUoZnVuY3Rpb24gKGlucHV0LCB0aW1lb3V0KSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTmF0aXZlUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgX3Byb21pc2VDbHMudltuYW1lXShpbnB1dCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYygpO1xufVxuZnVuY3Rpb24gY3JlYXRlTmF0aXZlUHJvbWlzZShleGVjdXRvciwgdGltZW91dCkge1xuICAgICFfcHJvbWlzZUNscyAmJiAoX3Byb21pc2VDbHMgPSBjcmVhdGVDYWNoZWRWYWx1ZSgoc2FmZShnZXRJbnN0LCBbU1RSX1BST01JU0VdKS52KSB8fCBudWxsKSk7XG4gICAgdmFyIFBybUNscyA9IF9wcm9taXNlQ2xzLnY7XG4gICAgaWYgKCFQcm1DbHMpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUFzeW5jUHJvbWlzZShleGVjdXRvcik7XG4gICAgfVxuICAgIGlmICghaXNGdW5jdGlvbihleGVjdXRvcikpIHtcbiAgICAgICAgdGhyb3dUeXBlRXJyb3IoU1RSX1BST01JU0UgKyBcIjogZXhlY3V0b3IgaXMgbm90IGEgZnVuY3Rpb24gLSBcIiArIGR1bXBPYmooZXhlY3V0b3IpKTtcbiAgICB9XG4gICAgdmFyIF9zdGF0ZSA9IDAgO1xuICAgIGZ1bmN0aW9uIF9zdHJTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIFNUUklOR19TVEFURVNbX3N0YXRlXTtcbiAgICB9XG4gICAgdmFyIHRoZVByb21pc2UgPSBuZXcgUHJtQ2xzKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gX3Jlc29sdmUodmFsdWUpIHtcbiAgICAgICAgICAgIF9zdGF0ZSA9IDIgO1xuICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gX3JlamVjdChyZWFzb24pIHtcbiAgICAgICAgICAgIF9zdGF0ZSA9IDMgO1xuICAgICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgZXhlY3V0b3IoX3Jlc29sdmUsIF9yZWplY3QpO1xuICAgIH0pO1xuICAgIG9iakRlZmluZVByb3AodGhlUHJvbWlzZSwgXCJzdGF0ZVwiLCB7XG4gICAgICAgIGdldDogX3N0clN0YXRlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoZVByb21pc2U7XG59XG5mdW5jdGlvbiBjcmVhdGVOYXRpdmVBbGxQcm9taXNlKGlucHV0LCB0aW1lb3V0KSB7XG4gICAgIV9hbGxDcmVhdG9yICYmIChfYWxsQ3JlYXRvciA9IF9jcmVhdGVOYXRpdmVQcm9taXNlSGVscGVyKFwiYWxsXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyZWF0ZUNhY2hlZFZhbHVlKF9jcmVhdGVBbGxQcm9taXNlKGNyZWF0ZU5hdGl2ZVByb21pc2UpKTsgfSkpO1xuICAgIHJldHVybiBfYWxsQ3JlYXRvci52KGlucHV0LCB0aW1lb3V0KTtcbn1cbnZhciBjcmVhdGVOYXRpdmVSZXNvbHZlZFByb21pc2UgPSAvKiNfX1BVUkVfXyovIF9jcmVhdGVSZXNvbHZlZFByb21pc2UoY3JlYXRlTmF0aXZlUHJvbWlzZSk7XG52YXIgY3JlYXRlTmF0aXZlUmVqZWN0ZWRQcm9taXNlID0gLyojX19QVVJFX18qLyBfY3JlYXRlUmVqZWN0ZWRQcm9taXNlKGNyZWF0ZU5hdGl2ZVByb21pc2UpO1xuZnVuY3Rpb24gY3JlYXRlTmF0aXZlQWxsU2V0dGxlZFByb21pc2UoaW5wdXQsIHRpbWVvdXQpIHtcbiAgICAhX2FsbE5hdGl2ZVNldHRsZWRDcmVhdG9yICYmIChfYWxsTmF0aXZlU2V0dGxlZENyZWF0b3IgPSBfY3JlYXRlTmF0aXZlUHJvbWlzZUhlbHBlcihcImFsbFNldHRsZWRcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX2NyZWF0ZUFsbFNldHRsZWRQcm9taXNlKGNyZWF0ZU5hdGl2ZVByb21pc2UpOyB9KSk7XG4gICAgcmV0dXJuIF9hbGxOYXRpdmVTZXR0bGVkQ3JlYXRvci52KGlucHV0LCB0aW1lb3V0KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZVJhY2VQcm9taXNlKHZhbHVlcywgdGltZW91dCkge1xuICAgICFfcmFjZU5hdGl2ZUNyZWF0b3IgJiYgKF9yYWNlTmF0aXZlQ3JlYXRvciA9IF9jcmVhdGVOYXRpdmVQcm9taXNlSGVscGVyKFwicmFjZVwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfY3JlYXRlUmFjZVByb21pc2UoY3JlYXRlTmF0aXZlUHJvbWlzZSk7IH0pKTtcbiAgICByZXR1cm4gX3JhY2VOYXRpdmVDcmVhdG9yLnYodmFsdWVzLCB0aW1lb3V0KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZUFueVByb21pc2UodmFsdWVzLCB0aW1lb3V0KSB7XG4gICAgIV9hbnlOYXRpdmVDcmVhdG9yICYmIChfYW55TmF0aXZlQ3JlYXRvciA9IF9jcmVhdGVOYXRpdmVQcm9taXNlSGVscGVyKFwiYW55XCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9jcmVhdGVBbnlQcm9taXNlKGNyZWF0ZU5hdGl2ZVByb21pc2UpOyB9KSk7XG4gICAgcmV0dXJuIF9hbnlOYXRpdmVDcmVhdG9yLnYodmFsdWVzLCB0aW1lb3V0KTtcbn1cblxudmFyIF9hbGxTeW5jU2V0dGxlZENyZWF0b3I7XG52YXIgX3JhY2VTeW5jQ3JlYXRvcjtcbnZhciBfYW55U3luY0NyZWF0b3I7XG5mdW5jdGlvbiBjcmVhdGVTeW5jUHJvbWlzZShleGVjdXRvcikge1xuICAgIHJldHVybiBfY3JlYXRlUHJvbWlzZShjcmVhdGVTeW5jUHJvbWlzZSwgc3luY0l0ZW1Qcm9jZXNzb3IsIGV4ZWN1dG9yKTtcbn1cbnZhciBjcmVhdGVTeW5jQWxsUHJvbWlzZSA9IC8qI19fUFVSRV9fKi8gX2NyZWF0ZUFsbFByb21pc2UoY3JlYXRlU3luY1Byb21pc2UpO1xudmFyIGNyZWF0ZVN5bmNSZXNvbHZlZFByb21pc2UgPSAvKiNfX1BVUkVfXyovIF9jcmVhdGVSZXNvbHZlZFByb21pc2UoY3JlYXRlU3luY1Byb21pc2UpO1xudmFyIGNyZWF0ZVN5bmNSZWplY3RlZFByb21pc2UgPSAvKiNfX1BVUkVfXyovIF9jcmVhdGVSZWplY3RlZFByb21pc2UoY3JlYXRlU3luY1Byb21pc2UpO1xuZnVuY3Rpb24gY3JlYXRlU3luY0FsbFNldHRsZWRQcm9taXNlKGlucHV0LCB0aW1lb3V0KSB7XG4gICAgIV9hbGxTeW5jU2V0dGxlZENyZWF0b3IgJiYgKF9hbGxTeW5jU2V0dGxlZENyZWF0b3IgPSBfY3JlYXRlQWxsU2V0dGxlZFByb21pc2UoY3JlYXRlU3luY1Byb21pc2UpKTtcbiAgICByZXR1cm4gX2FsbFN5bmNTZXR0bGVkQ3JlYXRvci52KGlucHV0LCB0aW1lb3V0KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN5bmNSYWNlUHJvbWlzZSh2YWx1ZXMsIHRpbWVvdXQpIHtcbiAgICAhX3JhY2VTeW5jQ3JlYXRvciAmJiAoX3JhY2VTeW5jQ3JlYXRvciA9IF9jcmVhdGVSYWNlUHJvbWlzZShjcmVhdGVTeW5jUHJvbWlzZSkpO1xuICAgIHJldHVybiBfcmFjZVN5bmNDcmVhdG9yLnYodmFsdWVzLCB0aW1lb3V0KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN5bmNBbnlQcm9taXNlKHZhbHVlcywgdGltZW91dCkge1xuICAgICFfYW55U3luY0NyZWF0b3IgJiYgKF9hbnlTeW5jQ3JlYXRvciA9IF9jcmVhdGVBbnlQcm9taXNlKGNyZWF0ZVN5bmNQcm9taXNlKSk7XG4gICAgcmV0dXJuIF9hbnlTeW5jQ3JlYXRvci52KHZhbHVlcywgdGltZW91dCk7XG59XG5cbnZhciBfZGVmYXVsdElkbGVUaW1lb3V0O1xudmFyIF9hbGxJZGxlU2V0dGxlZENyZWF0b3I7XG52YXIgX3JhY2VJZGxlQ3JlYXRvcjtcbnZhciBfYW55SWRsZUNyZWF0b3I7XG5mdW5jdGlvbiBzZXREZWZhdWx0SWRsZVByb21pc2VUaW1lb3V0KGlkbGVEZWFkbGluZSkge1xuICAgIF9kZWZhdWx0SWRsZVRpbWVvdXQgPSBpZGxlRGVhZGxpbmU7XG59XG52YXIgc2V0RGVmYXVsdElkbGVUaW1lb3V0ID0gKCAvKiNfX1BVUkVfXyovX3B1cmVBc3NpZ24oc2V0RGVmYXVsdElkbGVQcm9taXNlVGltZW91dCkpO1xuZnVuY3Rpb24gY3JlYXRlSWRsZVByb21pc2UoZXhlY3V0b3IsIHRpbWVvdXQpIHtcbiAgICB2YXIgdGhlVGltZW91dCA9IGlzVW5kZWZpbmVkKHRpbWVvdXQpID8gX2RlZmF1bHRJZGxlVGltZW91dCA6IHRpbWVvdXQ7XG4gICAgcmV0dXJuIF9jcmVhdGVQcm9taXNlKGNyZWF0ZUlkbGVQcm9taXNlLCBpZGxlSXRlbVByb2Nlc3Nvcih0aGVUaW1lb3V0KSwgZXhlY3V0b3IsIHRoZVRpbWVvdXQpO1xufVxudmFyIGNyZWF0ZUlkbGVBbGxQcm9taXNlID0gLyojX19QVVJFX18qLyBfY3JlYXRlQWxsUHJvbWlzZShjcmVhdGVJZGxlUHJvbWlzZSk7XG52YXIgY3JlYXRlSWRsZVJlc29sdmVkUHJvbWlzZSA9IC8qI19fUFVSRV9fKi8gX2NyZWF0ZVJlc29sdmVkUHJvbWlzZShjcmVhdGVJZGxlUHJvbWlzZSk7XG52YXIgY3JlYXRlSWRsZVJlamVjdGVkUHJvbWlzZSA9IC8qI19fUFVSRV9fKi8gX2NyZWF0ZVJlamVjdGVkUHJvbWlzZShjcmVhdGVJZGxlUHJvbWlzZSk7XG5mdW5jdGlvbiBjcmVhdGVJZGxlQWxsU2V0dGxlZFByb21pc2UoaW5wdXQsIHRpbWVvdXQpIHtcbiAgICAhX2FsbElkbGVTZXR0bGVkQ3JlYXRvciAmJiAoX2FsbElkbGVTZXR0bGVkQ3JlYXRvciA9IF9jcmVhdGVBbGxTZXR0bGVkUHJvbWlzZShjcmVhdGVJZGxlUHJvbWlzZSkpO1xuICAgIHJldHVybiBfYWxsSWRsZVNldHRsZWRDcmVhdG9yLnYoaW5wdXQsIHRpbWVvdXQpO1xufVxuZnVuY3Rpb24gY3JlYXRlSWRsZVJhY2VQcm9taXNlKHZhbHVlcywgdGltZW91dCkge1xuICAgICFfcmFjZUlkbGVDcmVhdG9yICYmIChfcmFjZUlkbGVDcmVhdG9yID0gX2NyZWF0ZVJhY2VQcm9taXNlKGNyZWF0ZUlkbGVQcm9taXNlKSk7XG4gICAgcmV0dXJuIF9yYWNlSWRsZUNyZWF0b3Iudih2YWx1ZXMsIHRpbWVvdXQpO1xufVxuZnVuY3Rpb24gY3JlYXRlSWRsZUFueVByb21pc2UodmFsdWVzLCB0aW1lb3V0KSB7XG4gICAgIV9hbnlJZGxlQ3JlYXRvciAmJiAoX2FueUlkbGVDcmVhdG9yID0gX2NyZWF0ZUFueVByb21pc2UoY3JlYXRlSWRsZVByb21pc2UpKTtcbiAgICByZXR1cm4gX2FueUlkbGVDcmVhdG9yLnYodmFsdWVzLCB0aW1lb3V0KTtcbn1cblxudmFyIF9wcm9taXNlQ3JlYXRvcjtcbnZhciBfYWxsU2V0dGxlZENyZWF0b3I7XG52YXIgX3JhY2VDcmVhdG9yO1xudmFyIF9hbnlDcmVhdG9yO1xuZnVuY3Rpb24gc2V0Q3JlYXRlUHJvbWlzZUltcGwoY3JlYXRvcikge1xuICAgIF9wcm9taXNlQ3JlYXRvciA9IGNyZWF0b3IgPyBjcmVhdGVDYWNoZWRWYWx1ZShjcmVhdG9yKSA6IG51bGw7XG59XG5mdW5jdGlvbiBjcmVhdGVQcm9taXNlKGV4ZWN1dG9yLCB0aW1lb3V0KSB7XG4gICAgIV9wcm9taXNlQ3JlYXRvciAmJiAoX3Byb21pc2VDcmVhdG9yID0gY3JlYXRlQ2FjaGVkVmFsdWUoY3JlYXRlTmF0aXZlUHJvbWlzZSkpO1xuICAgIHJldHVybiBfcHJvbWlzZUNyZWF0b3Iudi5jYWxsKHRoaXMsIGV4ZWN1dG9yLCB0aW1lb3V0KTtcbn1cbnZhciBjcmVhdGVBbGxQcm9taXNlID0gLyojX19QVVJFX18qLyBfY3JlYXRlQWxsUHJvbWlzZShjcmVhdGVQcm9taXNlKTtcbnZhciBjcmVhdGVSZXNvbHZlZFByb21pc2UgPSAvKiNfX1BVUkVfXyovIF9jcmVhdGVSZXNvbHZlZFByb21pc2UoY3JlYXRlUHJvbWlzZSk7XG52YXIgY3JlYXRlUmVqZWN0ZWRQcm9taXNlID0gLyojX19QVVJFX18qLyBfY3JlYXRlUmVqZWN0ZWRQcm9taXNlKGNyZWF0ZVByb21pc2UpO1xuZnVuY3Rpb24gY3JlYXRlQWxsU2V0dGxlZFByb21pc2UoaW5wdXQsIHRpbWVvdXQpIHtcbiAgICAhX2FsbFNldHRsZWRDcmVhdG9yICYmIChfYWxsU2V0dGxlZENyZWF0b3IgPSBfY3JlYXRlQWxsU2V0dGxlZFByb21pc2UoY3JlYXRlUHJvbWlzZSkpO1xuICAgIHJldHVybiBfYWxsU2V0dGxlZENyZWF0b3IudihpbnB1dCwgdGltZW91dCk7XG59XG5mdW5jdGlvbiBjcmVhdGVSYWNlUHJvbWlzZSh2YWx1ZXMsIHRpbWVvdXQpIHtcbiAgICAhX3JhY2VDcmVhdG9yICYmIChfcmFjZUNyZWF0b3IgPSBfY3JlYXRlUmFjZVByb21pc2UoY3JlYXRlUHJvbWlzZSkpO1xuICAgIHJldHVybiBfcmFjZUNyZWF0b3Iudih2YWx1ZXMsIHRpbWVvdXQpO1xufVxuZnVuY3Rpb24gY3JlYXRlQW55UHJvbWlzZSh2YWx1ZXMsIHRpbWVvdXQpIHtcbiAgICAhX2FueUNyZWF0b3IgJiYgKF9hbnlDcmVhdG9yID0gX2NyZWF0ZUFueVByb21pc2UoY3JlYXRlUHJvbWlzZSkpO1xuICAgIHJldHVybiBfYW55Q3JlYXRvci52KHZhbHVlcywgdGltZW91dCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRpbWVvdXRQcm9taXNlKHRpbWVvdXQsIHJlc29sdmVSZWplY3QsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gY3JlYXRlUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNjaGVkdWxlVGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAocmVzb2x2ZVJlamVjdCA/IHJlc29sdmUgOiByZWplY3QpKCFpc1VuZGVmaW5lZChtZXNzYWdlKSA/IG1lc3NhZ2UgOiBcIlRpbWVvdXQgb2YgXCIgKyB0aW1lb3V0ICsgXCJtcyBleGNlZWRlZFwiKTtcbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIF9kb25lQ2hrKGlzRG9uZSwgc3RhdGUsIHZhbHVlLCB0aGlzQXJnKSB7XG4gICAgdmFyIHJlc3VsdCA9IGlzRG9uZTtcbiAgICBzdGF0ZS5yZXMgPSB2YWx1ZTtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICBpZiAoc3RhdGUuaXNEb25lICYmIGlzRnVuY3Rpb24oc3RhdGUuaXNEb25lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRvQXdhaXQoc3RhdGUuaXNEb25lLmNhbGwodGhpc0FyZywgc3RhdGUpLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLml0ZXIrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gISFkb25lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSAhIXN0YXRlLmlzRG9uZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZS5pdGVyKys7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGRvV2hpbGVBc3luYyhjYWxsYmFja0ZuLCBpc0RvbmVGbiwgdGhpc0FyZykge1xuICAgIHZhciBwcm9taXNlO1xuICAgIHZhciByZXNvbHZlO1xuICAgIHZhciByZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIGlzRG9uZSA9IHRydWU7XG4gICAgICAgIHRocm93IHJlYXNvbjtcbiAgICB9O1xuICAgIHZhciBpc0RvbmUgPSBmYWxzZTtcbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIHN0OiB1dGNOb3coKSxcbiAgICAgICAgaXRlcjogMCxcbiAgICAgICAgaXNEb25lOiBpc0RvbmVGbiB8fCBmYWxzZVxuICAgIH07XG4gICAgaWYgKGNhbGxiYWNrRm4pIHtcbiAgICAgICAgdmFyIF9jcmVhdGVQcm9taXNlXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlUHJvbWlzZShmdW5jdGlvbiAocmVzLCByZWopIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlID0gcmVzO1xuICAgICAgICAgICAgICAgIHJlamVjdCA9IHJlajtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgX2hhbmRsZUFzeW5jRG9uZV8xID0gZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgICAgICAgIGlzRG9uZSA9ICEhZG9uZTtcbiAgICAgICAgICAgIGlmICghaXNEb25lKSB7XG4gICAgICAgICAgICAgICAgX3Byb2Nlc3NOZXh0XzEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoc3RhdGUucmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9wcm9jZXNzTmV4dF8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgd2hpbGUgKCFpc0RvbmUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2JSZXN1bHQgPSBjYWxsYmFja0ZuLmNhbGwodGhpc0FyZywgc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcm9taXNlTGlrZShjYlJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlIHx8IF9jcmVhdGVQcm9taXNlXzEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvQXdhaXQoY2JSZXN1bHQsIGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb0F3YWl0KF9kb25lQ2hrKGlzRG9uZSwgc3RhdGUsIHJlcywgdGhpc0FyZyksIF9oYW5kbGVBc3luY0RvbmVfMSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkblJlcyA9IF9kb25lQ2hrKGlzRG9uZSwgc3RhdGUsIGNiUmVzdWx0LCB0aGlzQXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1Byb21pc2VMaWtlKGRuUmVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlIHx8IF9jcmVhdGVQcm9taXNlXzEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb0F3YWl0KGRuUmVzLCBfaGFuZGxlQXN5bmNEb25lXzEsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0RvbmUgPSAhIWRuUmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRG9uZSAmJiByZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShzdGF0ZS5yZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UgfHwgc3RhdGUucmVzO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3Byb2Nlc3NOZXh0XzEoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFyckZvckVhY2hBc3luYyh0aGVBcnJheSwgY2FsbGJhY2tGbiwgdGhpc0FyZykge1xuICAgIGlmICh0aGVBcnJheSkge1xuICAgICAgICB2YXIgbGVuXzEgPSBnZXRMZW5ndGgodGhlQXJyYXkpO1xuICAgICAgICBpZiAobGVuXzEpIHtcbiAgICAgICAgICAgIHZhciBpc0RvbmUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaXRlciA+PSBsZW5fMSB8fCBzdGF0ZS5yZXMgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZG9XaGlsZUFzeW5jKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSBzdGF0ZS5pdGVyO1xuICAgICAgICAgICAgICAgIGlmIChpZHggaW4gdGhlQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrRm4uY2FsbCh0aGlzQXJnIHx8IHRoZUFycmF5LCB0aGVBcnJheVtpZHhdLCBpZHgsIHRoZUFycmF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBpc0RvbmUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG52YXIgX2l0ZXJTeW1ib2w7XG52YXIgX2l0ZXJBc3luY1N5bWJvbDtcbmZ1bmN0aW9uIGl0ZXJGb3JPZkFzeW5jKGl0ZXIsIGNhbGxiYWNrRm4sIHRoaXNBcmcpIHtcbiAgICB2YXIgZXJyO1xuICAgIHZhciBpdGVyUmVzdWx0O1xuICAgIHZhciB0aGVJdGVyID0gaXRlcjtcbiAgICBmdW5jdGlvbiBvbkZhaWxlZChmYWlsZWQpIHtcbiAgICAgICAgZXJyID0geyBlOiBmYWlsZWQgfTtcbiAgICAgICAgaWYgKHRoZUl0ZXIudGhyb3cpIHtcbiAgICAgICAgICAgIGl0ZXJSZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgdGhlSXRlci50aHJvdyhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGZhaWxlZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25GaW5hbGx5KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGl0ZXJSZXN1bHQgJiYgIWl0ZXJSZXN1bHRbRE9ORV0pIHtcbiAgICAgICAgICAgICAgICB0aGVJdGVyW1JFVFVSTl0gJiYgdGhlSXRlcltSRVRVUk5dKGl0ZXJSZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRocm93IGVyci5lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpdGVyKSB7XG4gICAgICAgIGlmICghaXNJdGVyYXRvcihpdGVyKSkge1xuICAgICAgICAgICAgIV9pdGVyQXN5bmNTeW1ib2wgJiYgKF9pdGVyQXN5bmNTeW1ib2wgPSBjcmVhdGVDYWNoZWRWYWx1ZShnZXRLbm93blN5bWJvbCgwICkpKTtcbiAgICAgICAgICAgIHRoZUl0ZXIgPSBpdGVyW19pdGVyQXN5bmNTeW1ib2wudl0gPyBpdGVyW19pdGVyQXN5bmNTeW1ib2wudl0oKSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoIXRoZUl0ZXIpIHtcbiAgICAgICAgICAgICAgICAhX2l0ZXJTeW1ib2wgJiYgKF9pdGVyU3ltYm9sID0gY3JlYXRlQ2FjaGVkVmFsdWUoZ2V0S25vd25TeW1ib2woMyApKSk7XG4gICAgICAgICAgICAgICAgdGhlSXRlciA9IGl0ZXJbX2l0ZXJTeW1ib2wudl0gPyBpdGVyW19pdGVyU3ltYm9sLnZdKCkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGVJdGVyICYmIGlzSXRlcmF0b3IodGhlSXRlcikpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRvV2hpbGVBc3luYyhmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvQXdhaXQodGhlSXRlci5uZXh0KCksIGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJSZXN1bHQgPSByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc1tET05FXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmbkNhbGwoY2FsbGJhY2tGbiwgdGhpc0FyZyB8fCB0aGVJdGVyLCBpdGVyUmVzdWx0W1ZBTFVFXSwgc3RhdGUuaXRlciwgdGhlSXRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmlzRG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkZhaWxlZChyZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVyUmVzdWx0IHx8IGl0ZXJSZXN1bHRbRE9ORV0gfHwgc3RhdGUucmVzID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25GaW5hbGx5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXNBcmcgfHwgdGhlSXRlcik7XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJvbWlzZUxpa2UocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBkb0ZpbmFsbHkocmVzdWx0LmNhdGNoKG9uRmFpbGVkKSwgb25GaW5hbGx5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChmYWlsZWQpIHtcbiAgICAgICAgICAgICAgICBvbkZhaWxlZChmYWlsZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiAhaXNQcm9taXNlTGlrZShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRmluYWxseSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIFJFSkVDVCA9IFwicmVqZWN0XCI7XG52YXIgUkVKRUNURURfRVJST1IgPSBcIlJlamVjdGVkXCI7XG52YXIgX3NjaGVkdWxlcklkID0gMDtcbnZhciBfZGVidWdOYW1lO1xudmFyIF9kZWJ1Z0ludFN0YXRlO1xudmFyIF9jdXN0b21FcnJvcnMgPSB7fTtcbmZ1bmN0aW9uIF9yZWplY3REb25lKCkge1xufVxuZnVuY3Rpb24gX2NyZWF0ZUVycm9yKHR5cGUsIGV2dCwgbWVzc2FnZSkge1xuICAgICFfY3VzdG9tRXJyb3JzW3R5cGVdICYmIChfY3VzdG9tRXJyb3JzW3R5cGVdID0gY3JlYXRlQ3VzdG9tRXJyb3IodHlwZSkpO1xuICAgIHZhciBub3cgPSB1dGNOb3coKTtcbiAgICByZXR1cm4gbmV3IChfY3VzdG9tRXJyb3JzW3R5cGVdKShcIlRhc2sgW1wiLmNvbmNhdChldnQuaWQsIFwiXSBcIikuY29uY2F0KG1lc3NhZ2UgfHwgXCJcIiwgXCItIFwiKS5jb25jYXQoKGV2dC5zdCA/IFwiUnVubmluZ1wiIDogXCJXYWl0aW5nXCIpLCBcIjogXCIpLmNvbmNhdChfY2FsY1RpbWUobm93LCBldnQuc3QgfHwgZXZ0LmNyKSkpO1xufVxuZnVuY3Rpb24gX2NhbGNUaW1lKG5vdywgc3RhcnQpIHtcbiAgICByZXR1cm4gKChub3cgLSBzdGFydCkgfHwgXCIwXCIpICsgXCIgbXNcIjtcbn1cbmZ1bmN0aW9uIF9hYm9ydFN0YWxlVGFza3ModGFza1F1ZXVlLCBzdGFsZVRpbWVvdXRQZXJpb2QpIHtcbiAgICB2YXIgbm93ID0gdXRjTm93KCk7XG4gICAgdmFyIGV4cGlyZWQgPSBub3cgLSBzdGFsZVRpbWVvdXRQZXJpb2Q7XG4gICAgYXJyRm9yRWFjaCh0YXNrUXVldWUsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgaWYgKGV2dCAmJiAhZXZ0LnJqICYmIChldnQuc3QgJiYgZXZ0LnN0IDwgZXhwaXJlZCkgfHwgKCFldnQuc3QgJiYgZXZ0LmNyICYmIGV2dC5jciA8IGV4cGlyZWQpKSB7XG4gICAgICAgICAgICBldnQgJiYgZXZ0W1JFSkVDVF0oZXZ0LnJqIHx8IF9jcmVhdGVFcnJvcihcIkFib3J0ZWRcIiwgZXZ0LCBcIlN0YWxlIFwiKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIF9yZW1vdmVUYXNrKHF1ZXVlLCB0YXNrRGV0YWlsKSB7XG4gICAgdmFyIGlkeCA9IGFyckluZGV4T2YocXVldWUsIHRhc2tEZXRhaWwpO1xuICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgIHF1ZXVlLnNwbGljZShpZHgsIDEpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9hZGREZWJ1Z1N0YXRlKHRoZVNjaGVkdWxlciwgbmFtZUZuLCBzdGF0ZUZuKSB7XG4gICAgX2RlYnVnTmFtZSA9IF9kZWJ1Z05hbWUgfHwgeyB0b1N0cmluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJbW1NjaGVkdWxlck5hbWVdXVwiOyB9IH07XG4gICAgX2RlYnVnSW50U3RhdGUgPSBfZGVidWdJbnRTdGF0ZSB8fCB7IHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7IHJldHVybiBcIltbU2NoZWR1bGVyU3RhdGVdXVwiOyB9IH07XG4gICAgb2JqRGVmaW5lUHJvcCh0aGVTY2hlZHVsZXIsIF9kZWJ1Z05hbWUsIHsgZ2V0OiBuYW1lRm4gfSk7XG4gICAgb2JqRGVmaW5lUHJvcCh0aGVTY2hlZHVsZXIsIF9kZWJ1Z0ludFN0YXRlLCB7IGdldDogc3RhdGVGbiB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRhc2tTY2hlZHVsZXIobmV3UHJvbWlzZSwgbmFtZSkge1xuICAgIHZhciBfdGhlVGFzaztcbiAgICB2YXIgX3J1bm5pbmcgPSBbXTtcbiAgICB2YXIgX3dhaXRpbmcgPSBbXTtcbiAgICB2YXIgX3N0YWxlVGltZW91dFBlcmlvZCA9IDYwMDAwMDtcbiAgICB2YXIgX3N0YWxlVGltZW91dENoZWNrUGVyaW9kID0gX3N0YWxlVGltZW91dFBlcmlvZCAvIDEwO1xuICAgIHZhciBfdGFza0NvdW50ID0gMDtcbiAgICB2YXIgX3NjaGVkdWxlck5hbWUgPSAobmFtZSA/IChuYW1lICsgXCIuXCIpIDogXCJcIikgKyBfc2NoZWR1bGVySWQrKztcbiAgICB2YXIgX2Jsb2NrZWRUaW1lcjtcbiAgICBuZXdQcm9taXNlID0gbmV3UHJvbWlzZSB8fCBjcmVhdGVQcm9taXNlO1xuICAgIHZhciBfc3RhcnRCbG9ja2VkVGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoYXNUYXNrcyA9IChnZXRMZW5ndGgoX3J1bm5pbmcpICsgZ2V0TGVuZ3RoKF93YWl0aW5nKSkgPiAwO1xuICAgICAgICBpZiAoX3N0YWxlVGltZW91dFBlcmlvZCA+IDApIHtcbiAgICAgICAgICAgIGlmICghX2Jsb2NrZWRUaW1lcikge1xuICAgICAgICAgICAgICAgIF9ibG9ja2VkVGltZXIgPSBzY2hlZHVsZVRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfYWJvcnRTdGFsZVRhc2tzKF9ydW5uaW5nLCBfc3RhbGVUaW1lb3V0UGVyaW9kKTtcbiAgICAgICAgICAgICAgICAgICAgX2Fib3J0U3RhbGVUYXNrcyhfd2FpdGluZywgX3N0YWxlVGltZW91dFBlcmlvZCk7XG4gICAgICAgICAgICAgICAgICAgIF9ibG9ja2VkVGltZXIgJiYgKF9ibG9ja2VkVGltZXIuZW5hYmxlZCA9ICgoZ2V0TGVuZ3RoKF9ydW5uaW5nKSArIGdldExlbmd0aChfd2FpdGluZykpID4gMCkpO1xuICAgICAgICAgICAgICAgIH0sIF9zdGFsZVRpbWVvdXRDaGVja1BlcmlvZCk7XG4gICAgICAgICAgICAgICAgX2Jsb2NrZWRUaW1lci51bnJlZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2Jsb2NrZWRUaW1lciAmJiAoX2Jsb2NrZWRUaW1lci5lbmFibGVkID0gaGFzVGFza3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgX3F1ZXVlVGFzayA9IGZ1bmN0aW9uIChzdGFydEFjdGlvbiwgdGFza05hbWUsIHRpbWVvdXQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgdGFza0lkID0gX3NjaGVkdWxlck5hbWUgKyBcIi5cIiArIF90YXNrQ291bnQrKztcbiAgICAgICAgaWYgKHRhc2tOYW1lKSB7XG4gICAgICAgICAgICB0YXNrSWQgKz0gXCItKFwiICsgdGFza05hbWUgKyBcIilcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3VGFzayA9IChfYSA9IHtcbiAgICAgICAgICAgICAgICBpZDogdGFza0lkLFxuICAgICAgICAgICAgICAgIGNyOiB1dGNOb3coKSxcbiAgICAgICAgICAgICAgICB0bzogdGltZW91dFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9hW1JFSkVDVF0gPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgbmV3VGFzay5yaiA9IHJlYXNvbiB8fCBfY3JlYXRlRXJyb3IoUkVKRUNURURfRVJST1IsIG5ld1Rhc2spO1xuICAgICAgICAgICAgICAgIG5ld1Rhc2tbUkVKRUNUXSA9IF9yZWplY3REb25lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9hKTtcbiAgICAgICAgaWYgKCFfdGhlVGFzaykge1xuICAgICAgICAgICAgbmV3VGFzay5wID0gbmV3UHJvbWlzZShfcnVuVGFzayhuZXdUYXNrLCBzdGFydEFjdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3VGFzay5wID0gX3dhaXRGb3JQcmV2aW91c1Rhc2sobmV3VGFzaywgX3RoZVRhc2ssIHN0YXJ0QWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhlVGFzayA9IG5ld1Rhc2s7XG4gICAgICAgIHJldHVybiBuZXdUYXNrLnA7XG4gICAgfTtcbiAgICB2YXIgX3J1blRhc2sgPSBmdW5jdGlvbiAodGFza0RldGFpbCwgc3RhcnRBY3Rpb24pIHtcbiAgICAgICAgdGFza0RldGFpbC5zdCA9IHV0Y05vdygpO1xuICAgICAgICBfcnVubmluZy5wdXNoKHRhc2tEZXRhaWwpO1xuICAgICAgICBfc3RhcnRCbG9ja2VkVGltZXIoKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvblRhc2tSZXNvbHZlLCBvblRhc2tSZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBfcHJvbWlzZVJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICB0YXNrRGV0YWlsLnJqID0gdGFza0RldGFpbC5yaiB8fCByZWFzb24gfHwgX2NyZWF0ZUVycm9yKFJFSkVDVEVEX0VSUk9SLCB0YXNrRGV0YWlsKTtcbiAgICAgICAgICAgICAgICB0YXNrRGV0YWlsW1JFSkVDVF0gPSBfcmVqZWN0RG9uZTtcbiAgICAgICAgICAgICAgICBfZG9DbGVhbnVwKHRhc2tEZXRhaWwpO1xuICAgICAgICAgICAgICAgIG9uVGFza1Jlc29sdmUgPSBudWxsO1xuICAgICAgICAgICAgICAgIG9uVGFza1JlamVjdCAmJiBvblRhc2tSZWplY3QocmVhc29uKTtcbiAgICAgICAgICAgICAgICBvblRhc2tSZWplY3QgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB0YXNrSWQgPSB0YXNrRGV0YWlsLmlkO1xuICAgICAgICAgICAgaWYgKHRhc2tEZXRhaWwucmopIHtcbiAgICAgICAgICAgICAgICBfcHJvbWlzZVJlamVjdCh0YXNrRGV0YWlsLnJqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhc2tEZXRhaWxbUkVKRUNUXSA9IF9wcm9taXNlUmVqZWN0O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydFJlc3VsdCA9IHN0YXJ0QWN0aW9uKHRhc2tJZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXNrRGV0YWlsLnRvICYmIGlzUHJvbWlzZUxpa2Uoc3RhcnRSZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrRGV0YWlsLnQgPSBzY2hlZHVsZVRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wcm9taXNlUmVqZWN0KF9jcmVhdGVFcnJvcihcIlRpbWVvdXRcIiwgdGFza0RldGFpbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGFza0RldGFpbC50byk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZG9Bd2FpdChzdGFydFJlc3VsdCwgZnVuY3Rpb24gKHRoZVJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2RvQ2xlYW51cCh0YXNrRGV0YWlsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25UYXNrUmVzb2x2ZSAmJiBvblRhc2tSZXNvbHZlKHRoZVJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uVGFza1JlamVjdCAmJiBvblRhc2tSZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvblRhc2tSZWplY3QgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25UYXNrUmVzb2x2ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH0sIF9wcm9taXNlUmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3Byb21pc2VSZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgdmFyIF93YWl0Rm9yUHJldmlvdXNUYXNrID0gZnVuY3Rpb24gKHRhc2tEZXRhaWwsIHByZXZUYXNrLCBzdGFydEFjdGlvbikge1xuICAgICAgICBfd2FpdGluZy5wdXNoKHRhc2tEZXRhaWwpO1xuICAgICAgICBfc3RhcnRCbG9ja2VkVGltZXIoKTtcbiAgICAgICAgcmV0dXJuIG5ld1Byb21pc2UoZnVuY3Rpb24gKG9uV2FpdFJlc29sdmUsIG9uV2FpdFJlamVjdCkge1xuICAgICAgICAgICAgZG9Bd2FpdFJlc3BvbnNlKHByZXZUYXNrLnAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfcmVtb3ZlVGFzayhfd2FpdGluZywgdGFza0RldGFpbCk7XG4gICAgICAgICAgICAgICAgX3J1blRhc2sodGFza0RldGFpbCwgc3RhcnRBY3Rpb24pKG9uV2FpdFJlc29sdmUsIG9uV2FpdFJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgX2RvQ2xlYW51cCA9IGZ1bmN0aW9uICh0YXNrRGV0YWlsKSB7XG4gICAgICAgIF9yZW1vdmVUYXNrKF9ydW5uaW5nLCB0YXNrRGV0YWlsKTtcbiAgICAgICAgdGFza0RldGFpbC50ICYmIHRhc2tEZXRhaWwudC5jYW5jZWwoKTtcbiAgICAgICAgdGFza0RldGFpbC50ID0gbnVsbDtcbiAgICAgICAgaWYgKF90aGVUYXNrICYmIF90aGVUYXNrID09PSB0YXNrRGV0YWlsKSB7XG4gICAgICAgICAgICBfdGhlVGFzayA9IG51bGw7XG4gICAgICAgICAgICBpZiAoZ2V0TGVuZ3RoKF9ydW5uaW5nKSArIGdldExlbmd0aChfd2FpdGluZykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBfYmxvY2tlZFRpbWVyICYmIF9ibG9ja2VkVGltZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgX2Jsb2NrZWRUaW1lciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciB0aGVTY2hlZHVsZXIgPSB7XG4gICAgICAgIGlkbGU6IHRydWUsXG4gICAgICAgIHF1ZXVlOiBfcXVldWVUYXNrLFxuICAgICAgICBzZXRTdGFsZVRpbWVvdXQ6IGZ1bmN0aW9uIChzdGFsZVRpbWVvdXQsIHN0YWxlQ2hlY2tQZXJpb2QpIHtcbiAgICAgICAgICAgIF9ibG9ja2VkVGltZXIgJiYgX2Jsb2NrZWRUaW1lci5jYW5jZWwoKTtcbiAgICAgICAgICAgIF9ibG9ja2VkVGltZXIgPSBudWxsO1xuICAgICAgICAgICAgX3N0YWxlVGltZW91dFBlcmlvZCA9IHN0YWxlVGltZW91dDtcbiAgICAgICAgICAgIF9zdGFsZVRpbWVvdXRDaGVja1BlcmlvZCA9IHN0YWxlQ2hlY2tQZXJpb2QgfHwgc3RhbGVUaW1lb3V0IC8gMTA7XG4gICAgICAgICAgICBfc3RhcnRCbG9ja2VkVGltZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgb2JqRGVmaW5lKHRoZVNjaGVkdWxlciwgXCJpZGxlXCIsIHtcbiAgICAgICAgZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldExlbmd0aChfcnVubmluZykgKyBnZXRMZW5ndGgoX3dhaXRpbmcpID09PSAwO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgX2FkZERlYnVnU3RhdGUodGhlU2NoZWR1bGVyLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfc2NoZWR1bGVyTmFtZTsgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbDogX3RoZVRhc2ssXG4gICAgICAgICAgICByOiBfcnVubmluZyxcbiAgICAgICAgICAgIHc6IF93YWl0aW5nXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoZVNjaGVkdWxlcjtcbn1cblxudmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gZ2V0S25vd25TeW1ib2woMTEgKTtcbnZhciBQb2x5UHJvbWlzZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQb2x5UHJvbWlzZUltcGwoZXhlY3V0b3IpIHtcbiAgICAgICAgdGhpcy5fJCA9IGNyZWF0ZUFzeW5jUHJvbWlzZShleGVjdXRvcik7XG4gICAgICAgIGlmICh0b1N0cmluZ1RhZ1N5bWJvbCkge1xuICAgICAgICAgICAgdGhpc1t0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIlByb21pc2VcIjtcbiAgICAgICAgfVxuICAgICAgICBvYmpEZWZpbmVQcm9wKHRoaXMsIFwic3RhdGVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXyQuc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBQb2x5UHJvbWlzZUltcGwuYWxsID0gY3JlYXRlQXN5bmNBbGxQcm9taXNlO1xuICAgIFBvbHlQcm9taXNlSW1wbC5yYWNlID0gY3JlYXRlQXN5bmNSYWNlUHJvbWlzZTtcbiAgICBQb2x5UHJvbWlzZUltcGwuYW55ID0gY3JlYXRlQXN5bmNBbnlQcm9taXNlO1xuICAgIFBvbHlQcm9taXNlSW1wbC5yZWplY3QgPSBjcmVhdGVBc3luY1JlamVjdGVkUHJvbWlzZTtcbiAgICBQb2x5UHJvbWlzZUltcGwucmVzb2x2ZSA9IGNyZWF0ZUFzeW5jUmVzb2x2ZWRQcm9taXNlO1xuICAgIFBvbHlQcm9taXNlSW1wbC5hbGxTZXR0bGVkID0gY3JlYXRlQXN5bmNBbGxTZXR0bGVkUHJvbWlzZTtcbiAgICB2YXIgdGhlUHJvdG8gPSBQb2x5UHJvbWlzZUltcGwucHJvdG90eXBlO1xuICAgIHRoZVByb3RvLnRoZW4gPSBmdW5jdGlvbiAob25SZXNvbHZlZCwgb25SZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fJC50aGVuKG9uUmVzb2x2ZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH07XG4gICAgdGhlUHJvdG8uY2F0Y2ggPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fJC5jYXRjaChvblJlamVjdGVkKTtcbiAgICB9O1xuICAgIHRoZVByb3RvLmZpbmFsbHkgPSBmdW5jdGlvbiAob25maW5hbGx5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl8kLmZpbmFsbHkob25maW5hbGx5KTtcbiAgICB9O1xuICAgIHJldHVybiBQb2x5UHJvbWlzZUltcGw7XG59KCkpO1xuXG5leHBvcnQgeyBQb2x5UHJvbWlzZSwgYXJyRm9yRWFjaEFzeW5jLCBjcmVhdGVBbGxQcm9taXNlLCBjcmVhdGVBbGxTZXR0bGVkUHJvbWlzZSwgY3JlYXRlQW55UHJvbWlzZSwgY3JlYXRlQXN5bmNBbGxQcm9taXNlLCBjcmVhdGVBc3luY0FsbFNldHRsZWRQcm9taXNlLCBjcmVhdGVBc3luY0FueVByb21pc2UsIGNyZWF0ZUFzeW5jUHJvbWlzZSwgY3JlYXRlQXN5bmNSYWNlUHJvbWlzZSwgY3JlYXRlQXN5bmNSZWplY3RlZFByb21pc2UsIGNyZWF0ZUFzeW5jUmVzb2x2ZWRQcm9taXNlLCBjcmVhdGVJZGxlQWxsUHJvbWlzZSwgY3JlYXRlSWRsZUFsbFNldHRsZWRQcm9taXNlLCBjcmVhdGVJZGxlQW55UHJvbWlzZSwgY3JlYXRlSWRsZVByb21pc2UsIGNyZWF0ZUlkbGVSYWNlUHJvbWlzZSwgY3JlYXRlSWRsZVJlamVjdGVkUHJvbWlzZSwgY3JlYXRlSWRsZVJlc29sdmVkUHJvbWlzZSwgY3JlYXRlTmF0aXZlQWxsUHJvbWlzZSwgY3JlYXRlTmF0aXZlQWxsU2V0dGxlZFByb21pc2UsIGNyZWF0ZU5hdGl2ZUFueVByb21pc2UsIGNyZWF0ZU5hdGl2ZVByb21pc2UsIGNyZWF0ZU5hdGl2ZVJhY2VQcm9taXNlLCBjcmVhdGVOYXRpdmVSZWplY3RlZFByb21pc2UsIGNyZWF0ZU5hdGl2ZVJlc29sdmVkUHJvbWlzZSwgY3JlYXRlUHJvbWlzZSwgY3JlYXRlUmFjZVByb21pc2UsIGNyZWF0ZVJlamVjdGVkUHJvbWlzZSwgY3JlYXRlUmVzb2x2ZWRQcm9taXNlLCBjcmVhdGVTeW5jQWxsUHJvbWlzZSwgY3JlYXRlU3luY0FsbFNldHRsZWRQcm9taXNlLCBjcmVhdGVTeW5jQW55UHJvbWlzZSwgY3JlYXRlU3luY1Byb21pc2UsIGNyZWF0ZVN5bmNSYWNlUHJvbWlzZSwgY3JlYXRlU3luY1JlamVjdGVkUHJvbWlzZSwgY3JlYXRlU3luY1Jlc29sdmVkUHJvbWlzZSwgY3JlYXRlVGFza1NjaGVkdWxlciwgY3JlYXRlVGltZW91dFByb21pc2UsIGRvQXdhaXQsIGRvQXdhaXRSZXNwb25zZSwgZG9GaW5hbGx5LCBkb1doaWxlQXN5bmMsIGl0ZXJGb3JPZkFzeW5jLCBzZXRDcmVhdGVQcm9taXNlSW1wbCwgc2V0RGVmYXVsdElkbGVQcm9taXNlVGltZW91dCwgc2V0RGVmYXVsdElkbGVUaW1lb3V0LCBzZXRQcm9taXNlRGVidWdTdGF0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHMtYXN5bmMuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nevware21/ts-async/dist/es5/mod/ts-async.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nevware21/ts-utils/dist/es5/mod/ts-utils.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@nevware21/ts-utils/dist/es5/mod/ts-utils.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrAppend: () => (/* binding */ arrAppend),\n/* harmony export */   arrContains: () => (/* binding */ arrContains),\n/* harmony export */   arrEvery: () => (/* binding */ arrEvery),\n/* harmony export */   arrFilter: () => (/* binding */ arrFilter),\n/* harmony export */   arrFind: () => (/* binding */ arrFind),\n/* harmony export */   arrFindIndex: () => (/* binding */ arrFindIndex),\n/* harmony export */   arrFindLast: () => (/* binding */ arrFindLast),\n/* harmony export */   arrFindLastIndex: () => (/* binding */ arrFindLastIndex),\n/* harmony export */   arrForEach: () => (/* binding */ arrForEach),\n/* harmony export */   arrFrom: () => (/* binding */ arrFrom),\n/* harmony export */   arrIncludes: () => (/* binding */ arrIncludes),\n/* harmony export */   arrIndexOf: () => (/* binding */ arrIndexOf),\n/* harmony export */   arrLastIndexOf: () => (/* binding */ arrLastIndexOf),\n/* harmony export */   arrMap: () => (/* binding */ arrMap),\n/* harmony export */   arrReduce: () => (/* binding */ arrReduce),\n/* harmony export */   arrSlice: () => (/* binding */ arrSlice),\n/* harmony export */   arrSome: () => (/* binding */ arrSome),\n/* harmony export */   arrayDeepCopyHandler: () => (/* binding */ arrayDeepCopyHandler),\n/* harmony export */   asString: () => (/* binding */ asString),\n/* harmony export */   createArrayIterator: () => (/* binding */ createArrayIterator),\n/* harmony export */   createCachedValue: () => (/* binding */ createCachedValue),\n/* harmony export */   createCustomError: () => (/* binding */ createCustomError),\n/* harmony export */   createDeferredCachedValue: () => (/* binding */ createDeferredCachedValue),\n/* harmony export */   createEnum: () => (/* binding */ createEnum),\n/* harmony export */   createEnumKeyMap: () => (/* binding */ createEnumKeyMap),\n/* harmony export */   createEnumValueMap: () => (/* binding */ createEnumValueMap),\n/* harmony export */   createFilenameRegex: () => (/* binding */ createFilenameRegex),\n/* harmony export */   createFnDeferredProxy: () => (/* binding */ createFnDeferredProxy),\n/* harmony export */   createIterable: () => (/* binding */ createIterable),\n/* harmony export */   createIterator: () => (/* binding */ createIterator),\n/* harmony export */   createProxyFuncs: () => (/* binding */ createProxyFuncs),\n/* harmony export */   createRangeIterator: () => (/* binding */ createRangeIterator),\n/* harmony export */   createSimpleMap: () => (/* binding */ createSimpleMap),\n/* harmony export */   createTimeout: () => (/* binding */ createTimeout),\n/* harmony export */   createTimeoutWith: () => (/* binding */ createTimeoutWith),\n/* harmony export */   createTypeMap: () => (/* binding */ createTypeMap),\n/* harmony export */   createWildcardRegex: () => (/* binding */ createWildcardRegex),\n/* harmony export */   dateDeepCopyHandler: () => (/* binding */ dateDeepCopyHandler),\n/* harmony export */   deepExtend: () => (/* binding */ deepExtend),\n/* harmony export */   dumpObj: () => (/* binding */ dumpObj),\n/* harmony export */   elapsedTime: () => (/* binding */ elapsedTime),\n/* harmony export */   encodeAsHtml: () => (/* binding */ encodeAsHtml),\n/* harmony export */   encodeAsJson: () => (/* binding */ encodeAsJson),\n/* harmony export */   fnApply: () => (/* binding */ fnApply),\n/* harmony export */   fnBind: () => (/* binding */ fnBind),\n/* harmony export */   fnCall: () => (/* binding */ fnCall),\n/* harmony export */   functionDeepCopyHandler: () => (/* binding */ functionDeepCopyHandler),\n/* harmony export */   getCancelIdleCallback: () => (/* binding */ getCancelIdleCallback),\n/* harmony export */   getDeferred: () => (/* binding */ getDeferred),\n/* harmony export */   getDocument: () => (/* binding */ getDocument),\n/* harmony export */   getGlobal: () => (/* binding */ getGlobal),\n/* harmony export */   getHistory: () => (/* binding */ getHistory),\n/* harmony export */   getIdleCallback: () => (/* binding */ getIdleCallback),\n/* harmony export */   getInst: () => (/* binding */ getInst),\n/* harmony export */   getIntValue: () => (/* binding */ getIntValue),\n/* harmony export */   getKnownSymbol: () => (/* binding */ getKnownSymbol),\n/* harmony export */   getLazy: () => (/* binding */ getLazy),\n/* harmony export */   getLength: () => (/* binding */ getLength),\n/* harmony export */   getNavigator: () => (/* binding */ getNavigator),\n/* harmony export */   getPerformance: () => (/* binding */ getPerformance),\n/* harmony export */   getSymbol: () => (/* binding */ getSymbol),\n/* harmony export */   getValueByIter: () => (/* binding */ getValueByIter),\n/* harmony export */   getValueByKey: () => (/* binding */ getValueByKey),\n/* harmony export */   getWindow: () => (/* binding */ getWindow),\n/* harmony export */   getWritableDeferred: () => (/* binding */ getWritableDeferred),\n/* harmony export */   getWritableLazy: () => (/* binding */ getWritableLazy),\n/* harmony export */   hasDocument: () => (/* binding */ hasDocument),\n/* harmony export */   hasHistory: () => (/* binding */ hasHistory),\n/* harmony export */   hasIdleCallback: () => (/* binding */ hasIdleCallback),\n/* harmony export */   hasNavigator: () => (/* binding */ hasNavigator),\n/* harmony export */   hasPerformance: () => (/* binding */ hasPerformance),\n/* harmony export */   hasSymbol: () => (/* binding */ hasSymbol),\n/* harmony export */   hasValue: () => (/* binding */ hasValue),\n/* harmony export */   hasWindow: () => (/* binding */ hasWindow),\n/* harmony export */   isArray: () => (/* binding */ isArray),\n/* harmony export */   isArrayBuffer: () => (/* binding */ isArrayBuffer),\n/* harmony export */   isAsyncFunction: () => (/* binding */ isAsyncFunction),\n/* harmony export */   isAsyncGenerator: () => (/* binding */ isAsyncGenerator),\n/* harmony export */   isBigInt: () => (/* binding */ isBigInt),\n/* harmony export */   isBlob: () => (/* binding */ isBlob),\n/* harmony export */   isBoolean: () => (/* binding */ isBoolean),\n/* harmony export */   isDate: () => (/* binding */ isDate),\n/* harmony export */   isDefined: () => (/* binding */ isDefined),\n/* harmony export */   isElement: () => (/* binding */ isElement),\n/* harmony export */   isElementLike: () => (/* binding */ isElementLike),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   isError: () => (/* binding */ isError),\n/* harmony export */   isFile: () => (/* binding */ isFile),\n/* harmony export */   isFiniteNumber: () => (/* binding */ isFiniteNumber),\n/* harmony export */   isFormData: () => (/* binding */ isFormData),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isGenerator: () => (/* binding */ isGenerator),\n/* harmony export */   isInteger: () => (/* binding */ isInteger),\n/* harmony export */   isIterable: () => (/* binding */ isIterable),\n/* harmony export */   isIterator: () => (/* binding */ isIterator),\n/* harmony export */   isMap: () => (/* binding */ isMap),\n/* harmony export */   isMapLike: () => (/* binding */ isMapLike),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isNotTruthy: () => (/* binding */ isNotTruthy),\n/* harmony export */   isNullOrUndefined: () => (/* binding */ isNullOrUndefined),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isPrimitive: () => (/* binding */ isPrimitive),\n/* harmony export */   isPrimitiveType: () => (/* binding */ isPrimitiveType),\n/* harmony export */   isPromise: () => (/* binding */ isPromise),\n/* harmony export */   isPromiseLike: () => (/* binding */ isPromiseLike),\n/* harmony export */   isRegExp: () => (/* binding */ isRegExp),\n/* harmony export */   isSet: () => (/* binding */ isSet),\n/* harmony export */   isSetLike: () => (/* binding */ isSetLike),\n/* harmony export */   isStrictNullOrUndefined: () => (/* binding */ isStrictNullOrUndefined),\n/* harmony export */   isStrictUndefined: () => (/* binding */ isStrictUndefined),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isSymbol: () => (/* binding */ isSymbol),\n/* harmony export */   isThenable: () => (/* binding */ isThenable),\n/* harmony export */   isTruthy: () => (/* binding */ isTruthy),\n/* harmony export */   isTypeof: () => (/* binding */ isTypeof),\n/* harmony export */   isUndefined: () => (/* binding */ isUndefined),\n/* harmony export */   isWeakMap: () => (/* binding */ isWeakMap),\n/* harmony export */   isWeakSet: () => (/* binding */ isWeakSet),\n/* harmony export */   isWebWorker: () => (/* binding */ isWebWorker),\n/* harmony export */   iterForOf: () => (/* binding */ iterForOf),\n/* harmony export */   lazySafeGetInst: () => (/* binding */ lazySafeGetInst),\n/* harmony export */   makeGlobRegex: () => (/* binding */ makeGlobRegex),\n/* harmony export */   makeIterable: () => (/* binding */ makeIterable),\n/* harmony export */   mathAbs: () => (/* binding */ mathAbs),\n/* harmony export */   mathAcos: () => (/* binding */ mathAcos),\n/* harmony export */   mathAsin: () => (/* binding */ mathAsin),\n/* harmony export */   mathAtan: () => (/* binding */ mathAtan),\n/* harmony export */   mathAtan2: () => (/* binding */ mathAtan2),\n/* harmony export */   mathCeil: () => (/* binding */ mathCeil),\n/* harmony export */   mathCos: () => (/* binding */ mathCos),\n/* harmony export */   mathExp: () => (/* binding */ mathExp),\n/* harmony export */   mathFloor: () => (/* binding */ mathFloor),\n/* harmony export */   mathLog: () => (/* binding */ mathLog),\n/* harmony export */   mathMax: () => (/* binding */ mathMax),\n/* harmony export */   mathMin: () => (/* binding */ mathMin),\n/* harmony export */   mathPow: () => (/* binding */ mathPow),\n/* harmony export */   mathRandom: () => (/* binding */ mathRandom),\n/* harmony export */   mathRound: () => (/* binding */ mathRound),\n/* harmony export */   mathSin: () => (/* binding */ mathSin),\n/* harmony export */   mathSqrt: () => (/* binding */ mathSqrt),\n/* harmony export */   mathTan: () => (/* binding */ mathTan),\n/* harmony export */   mathToInt: () => (/* binding */ mathToInt),\n/* harmony export */   mathTrunc: () => (/* binding */ mathTrunc),\n/* harmony export */   newSymbol: () => (/* binding */ newSymbol),\n/* harmony export */   normalizeJsName: () => (/* binding */ normalizeJsName),\n/* harmony export */   objAssign: () => (/* binding */ objAssign),\n/* harmony export */   objCopyProps: () => (/* binding */ objCopyProps),\n/* harmony export */   objCreate: () => (/* binding */ objCreate),\n/* harmony export */   objDeepCopy: () => (/* binding */ objDeepCopy),\n/* harmony export */   objDeepFreeze: () => (/* binding */ objDeepFreeze),\n/* harmony export */   objDefine: () => (/* binding */ objDefine),\n/* harmony export */   objDefineAccessors: () => (/* binding */ objDefineAccessors),\n/* harmony export */   objDefineGet: () => (/* binding */ objDefineGet),\n/* harmony export */   objDefineProp: () => (/* binding */ objDefineProp),\n/* harmony export */   objDefineProperties: () => (/* binding */ objDefineProperties),\n/* harmony export */   objDefineProps: () => (/* binding */ objDefineProps),\n/* harmony export */   objEntries: () => (/* binding */ objEntries),\n/* harmony export */   objExtend: () => (/* binding */ objExtend),\n/* harmony export */   objForEachKey: () => (/* binding */ objForEachKey),\n/* harmony export */   objFreeze: () => (/* binding */ objFreeze),\n/* harmony export */   objFromEntries: () => (/* binding */ objFromEntries),\n/* harmony export */   objGetOwnPropertyDescriptor: () => (/* binding */ objGetOwnPropertyDescriptor),\n/* harmony export */   objGetOwnPropertyDescriptors: () => (/* binding */ objGetOwnPropertyDescriptors),\n/* harmony export */   objGetOwnPropertyNames: () => (/* binding */ objGetOwnPropertyNames),\n/* harmony export */   objGetOwnPropertySymbols: () => (/* binding */ objGetOwnPropertySymbols),\n/* harmony export */   objGetPrototypeOf: () => (/* binding */ objGetPrototypeOf),\n/* harmony export */   objHasOwn: () => (/* binding */ objHasOwn),\n/* harmony export */   objHasOwnProperty: () => (/* binding */ objHasOwnProperty),\n/* harmony export */   objIs: () => (/* binding */ objIs),\n/* harmony export */   objIsExtensible: () => (/* binding */ objIsExtensible),\n/* harmony export */   objIsFrozen: () => (/* binding */ objIsFrozen),\n/* harmony export */   objIsSealed: () => (/* binding */ objIsSealed),\n/* harmony export */   objKeys: () => (/* binding */ objKeys),\n/* harmony export */   objPreventExtensions: () => (/* binding */ objPreventExtensions),\n/* harmony export */   objPropertyIsEnumerable: () => (/* binding */ objPropertyIsEnumerable),\n/* harmony export */   objSeal: () => (/* binding */ objSeal),\n/* harmony export */   objSetPrototypeOf: () => (/* binding */ objSetPrototypeOf),\n/* harmony export */   objToString: () => (/* binding */ objToString),\n/* harmony export */   objValues: () => (/* binding */ objValues),\n/* harmony export */   perfNow: () => (/* binding */ perfNow),\n/* harmony export */   plainObjDeepCopyHandler: () => (/* binding */ plainObjDeepCopyHandler),\n/* harmony export */   polyArrFind: () => (/* binding */ polyArrFind),\n/* harmony export */   polyArrFindIndex: () => (/* binding */ polyArrFindIndex),\n/* harmony export */   polyArrFindLast: () => (/* binding */ polyArrFindLast),\n/* harmony export */   polyArrFindLastIndex: () => (/* binding */ polyArrFindLastIndex),\n/* harmony export */   polyArrFrom: () => (/* binding */ polyArrFrom),\n/* harmony export */   polyArrIncludes: () => (/* binding */ polyArrIncludes),\n/* harmony export */   polyGetKnownSymbol: () => (/* binding */ polyGetKnownSymbol),\n/* harmony export */   polyIsArray: () => (/* binding */ polyIsArray),\n/* harmony export */   polyNewSymbol: () => (/* binding */ polyNewSymbol),\n/* harmony export */   polyObjEntries: () => (/* binding */ polyObjEntries),\n/* harmony export */   polyObjHasOwn: () => (/* binding */ polyObjHasOwn),\n/* harmony export */   polyObjIs: () => (/* binding */ polyObjIs),\n/* harmony export */   polyObjKeys: () => (/* binding */ polyObjKeys),\n/* harmony export */   polyStrIncludes: () => (/* binding */ polyStrIncludes),\n/* harmony export */   polyStrSubstr: () => (/* binding */ polyStrSubstr),\n/* harmony export */   polyStrSymSplit: () => (/* binding */ polyStrSymSplit),\n/* harmony export */   polyStrTrim: () => (/* binding */ polyStrTrim),\n/* harmony export */   polyStrTrimEnd: () => (/* binding */ polyStrTrimEnd),\n/* harmony export */   polyStrTrimStart: () => (/* binding */ polyStrTrimStart),\n/* harmony export */   polySymbolFor: () => (/* binding */ polySymbolFor),\n/* harmony export */   polySymbolKeyFor: () => (/* binding */ polySymbolKeyFor),\n/* harmony export */   polyUtcNow: () => (/* binding */ polyUtcNow),\n/* harmony export */   readArgs: () => (/* binding */ readArgs),\n/* harmony export */   safe: () => (/* binding */ safe),\n/* harmony export */   safeGet: () => (/* binding */ safeGet),\n/* harmony export */   safeGetDeferred: () => (/* binding */ safeGetDeferred),\n/* harmony export */   safeGetLazy: () => (/* binding */ safeGetLazy),\n/* harmony export */   safeGetWritableDeferred: () => (/* binding */ safeGetWritableDeferred),\n/* harmony export */   safeGetWritableLazy: () => (/* binding */ safeGetWritableLazy),\n/* harmony export */   scheduleIdleCallback: () => (/* binding */ scheduleIdleCallback),\n/* harmony export */   scheduleInterval: () => (/* binding */ scheduleInterval),\n/* harmony export */   scheduleTimeout: () => (/* binding */ scheduleTimeout),\n/* harmony export */   scheduleTimeoutWith: () => (/* binding */ scheduleTimeoutWith),\n/* harmony export */   setBypassLazyCache: () => (/* binding */ setBypassLazyCache),\n/* harmony export */   setDefaultIdleTimeout: () => (/* binding */ setDefaultIdleTimeout),\n/* harmony export */   setDefaultMaxExecutionTime: () => (/* binding */ setDefaultMaxExecutionTime),\n/* harmony export */   setGlobalTimeoutOverrides: () => (/* binding */ setGlobalTimeoutOverrides),\n/* harmony export */   setTimeoutOverrides: () => (/* binding */ setTimeoutOverrides),\n/* harmony export */   setValueByIter: () => (/* binding */ setValueByIter),\n/* harmony export */   setValueByKey: () => (/* binding */ setValueByKey),\n/* harmony export */   strCamelCase: () => (/* binding */ strCamelCase),\n/* harmony export */   strContains: () => (/* binding */ strContains),\n/* harmony export */   strEndsWith: () => (/* binding */ strEndsWith),\n/* harmony export */   strIncludes: () => (/* binding */ strIncludes),\n/* harmony export */   strIndexOf: () => (/* binding */ strIndexOf),\n/* harmony export */   strIsNullOrEmpty: () => (/* binding */ strIsNullOrEmpty),\n/* harmony export */   strIsNullOrWhiteSpace: () => (/* binding */ strIsNullOrWhiteSpace),\n/* harmony export */   strKebabCase: () => (/* binding */ strKebabCase),\n/* harmony export */   strLastIndexOf: () => (/* binding */ strLastIndexOf),\n/* harmony export */   strLeft: () => (/* binding */ strLeft),\n/* harmony export */   strLetterCase: () => (/* binding */ strLetterCase),\n/* harmony export */   strLower: () => (/* binding */ strLower),\n/* harmony export */   strPadEnd: () => (/* binding */ strPadEnd),\n/* harmony export */   strPadStart: () => (/* binding */ strPadStart),\n/* harmony export */   strRepeat: () => (/* binding */ strRepeat),\n/* harmony export */   strRight: () => (/* binding */ strRight),\n/* harmony export */   strSlice: () => (/* binding */ strSlice),\n/* harmony export */   strSnakeCase: () => (/* binding */ strSnakeCase),\n/* harmony export */   strSplit: () => (/* binding */ strSplit),\n/* harmony export */   strStartsWith: () => (/* binding */ strStartsWith),\n/* harmony export */   strSubstr: () => (/* binding */ strSubstr),\n/* harmony export */   strSubstring: () => (/* binding */ strSubstring),\n/* harmony export */   strSymSplit: () => (/* binding */ strSymSplit),\n/* harmony export */   strTrim: () => (/* binding */ strTrim),\n/* harmony export */   strTrimEnd: () => (/* binding */ strTrimEnd),\n/* harmony export */   strTrimLeft: () => (/* binding */ strTrimLeft),\n/* harmony export */   strTrimRight: () => (/* binding */ strTrimRight),\n/* harmony export */   strTrimStart: () => (/* binding */ strTrimStart),\n/* harmony export */   strUpper: () => (/* binding */ strUpper),\n/* harmony export */   symbolFor: () => (/* binding */ symbolFor),\n/* harmony export */   symbolKeyFor: () => (/* binding */ symbolKeyFor),\n/* harmony export */   throwError: () => (/* binding */ throwError),\n/* harmony export */   throwRangeError: () => (/* binding */ throwRangeError),\n/* harmony export */   throwTypeError: () => (/* binding */ throwTypeError),\n/* harmony export */   throwUnsupported: () => (/* binding */ throwUnsupported),\n/* harmony export */   utcNow: () => (/* binding */ utcNow)\n/* harmony export */ });\n/*! https://github.com/nevware21/ts-utils v0.12.5 */\n/*\n * Copyright (c) NevWare21 Solutions LLC and contributors. All rights reserved.\n * Licensed under the MIT license.\n */\n/*#__NO_SIDE_EFFECTS__*/\nfunction _pureAssign(func1, func2) {\n    return func1 || func2;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction _pureRef(value, name) {\n    return value[name];\n}\n\nvar UNDEF_VALUE = undefined;\nvar NULL_VALUE = null;\nvar EMPTY = \"\";\nvar FUNCTION = \"function\";\nvar OBJECT = \"object\";\nvar PROTOTYPE = \"prototype\";\nvar __PROTO__ = \"__proto__\";\nvar UNDEFINED = \"undefined\";\nvar CONSTRUCTOR = \"constructor\";\nvar SYMBOL = \"Symbol\";\nvar LENGTH = \"length\";\nvar NAME = \"name\";\nvar CALL = \"call\";\nvar TO_STRING = \"toString\";\nvar GET_OWN_PROPERTY_DESCRIPTOR = \"getOwnPropertyDescriptor\";\nvar GET_OWN_PROPERTY_NAMES = \"getOwnPropertyNames\";\nvar GET_OWN_PROPERTY_SYMBOLS = \"getOwnPropertySymbols\";\nvar ObjClass = ( /*#__PURE__*/_pureAssign(Object));\nvar ObjProto = ( /*#__PURE__*/_pureRef(ObjClass, PROTOTYPE));\nvar StrCls = ( /*#__PURE__*/_pureAssign(String));\nvar StrProto = ( /*#__PURE__*/_pureRef(StrCls, PROTOTYPE));\nvar MathCls = ( /*#__PURE__*/_pureAssign(Math));\nvar ArrCls = ( /*#__PURE__*/_pureAssign(Array));\nvar ArrProto = ( /*#__PURE__*/_pureRef(ArrCls, PROTOTYPE));\nvar ArrSlice = ( /*#__PURE__*/_pureRef(ArrProto, \"slice\"));\nvar NumberCls = ( /*#__PURE__*/_pureAssign(Number));\n\nvar POLYFILL_TAG = \"_polyfill\";\nvar POLYFILL_TYPE_NAME = \"__nw21$polytype__\";\nfunction _isPolyfill(obj) {\n    return !!(obj && obj[POLYFILL_TAG]);\n}\nfunction _isPolyfillType(obj, polyfillTypeName) {\n    return !!(obj && obj[POLYFILL_TYPE_NAME] === polyfillTypeName);\n}\n\nfunction safe(func, argArray) {\n    try {\n        return {\n            v: func.apply(this, argArray)\n        };\n    }\n    catch (e) {\n        return { e: e };\n    }\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction safeGet(cb, defValue, argArray) {\n    var result = safe(cb, argArray);\n    return result.e ? defValue : result.v;\n}\n\nvar _primitiveTypes;\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createIs(theType) {\n    return function (value) {\n        return typeof value === theType;\n    };\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createIsWithPoly(theType) {\n    return function (value) {\n        return typeof value === theType || _isPolyfillType(value, theType);\n    };\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createObjIs(theName) {\n    var theType = \"[object \" + theName + \"]\";\n    return function (value) {\n        return !!(value && objToString(value) === theType);\n    };\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction objToString(value) {\n    return ObjProto[TO_STRING].call(value);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction isTypeof(value, theType) {\n    return typeof value === theType;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction isUndefined(value) {\n    return typeof value === UNDEFINED || value === UNDEFINED;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction isStrictUndefined(arg) {\n    return arg === UNDEF_VALUE;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction isNullOrUndefined(value) {\n    return value === NULL_VALUE || isUndefined(value);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction isStrictNullOrUndefined(value) {\n    return value === NULL_VALUE || value === UNDEF_VALUE;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction isDefined(arg) {\n    return !!arg || arg !== UNDEF_VALUE;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction isPrimitive(value) {\n    return value === NULL_VALUE || isPrimitiveType(typeof value);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction isPrimitiveType(theType) {\n    !_primitiveTypes && (_primitiveTypes = [\"string\", \"number\", \"boolean\", UNDEFINED, \"symbol\", \"bigint\"]);\n    return !!(theType !== OBJECT && _primitiveTypes.indexOf(theType) !== -1);\n}\nvar isString = ( /*#__PURE__*/_createIs(\"string\"));\nvar isFunction = ( /*#__PURE__*/_createIs(FUNCTION));\nvar isAsyncFunction = ( /*#__PURE__*/_createObjIs(\"AsyncFunction\"));\nvar isGenerator = ( /*#__PURE__*/_createObjIs(\"GeneratorFunction\"));\nvar isAsyncGenerator = ( /*#__PURE__*/_createObjIs(\"AsyncGeneratorFunction\"));\n/*#__NO_SIDE_EFFECTS__*/\nfunction isObject(value) {\n    if (!value && isNullOrUndefined(value)) {\n        return false;\n    }\n    return !!value && typeof value === OBJECT;\n}\nvar isArray = ( /* #__PURE__*/_pureRef(ArrCls, \"isArray\"));\nvar isDate = ( /*#__PURE__*/_createObjIs(\"Date\"));\nvar isNumber = ( /*#__PURE__*/_createIs(\"number\"));\nvar isBoolean = ( /*#__PURE__*/_createIs(\"boolean\"));\nvar isRegExp = ( /*#__PURE__*/_createObjIs(\"RegExp\"));\nvar isFile = ( /*#__PURE__*/_createObjIs(\"File\"));\nvar isFormData = ( /*#__PURE__*/_createObjIs(\"FormData\"));\nvar isBlob = ( /*#__PURE__*/_createObjIs(\"Blob\"));\nvar isArrayBuffer = ( /*#__PURE__*/_createObjIs(\"ArrayBuffer\"));\nvar isError = ( /*#__PURE__*/_createObjIs(\"Error\"));\n/*#__NO_SIDE_EFFECTS__*/\nfunction isPromiseLike(value) {\n    return !!(value && value.then && isFunction(value.then));\n}\nvar isThenable = isPromiseLike;\n/*#__NO_SIDE_EFFECTS__*/\nfunction isPromise(value) {\n    return !!(value && value.then && value.catch && isFunction(value.then) && isFunction(value.catch));\n}\nvar isMap = ( /*#__PURE__*/_createObjIs(\"Map\"));\nvar isWeakMap = ( /*#__PURE__*/_createObjIs(\"WeakMap\"));\nvar isSet = ( /*#__PURE__*/_createObjIs(\"Set\"));\nvar isWeakSet = ( /*#__PURE__*/_createObjIs(\"WeakSet\"));\n/*#__NO_SIDE_EFFECTS__*/\nfunction isMapLike(value) {\n    return !!(value &&\n        isFunction(value.get) &&\n        isFunction(value.set) &&\n        isFunction(value.has) &&\n        isFunction(value.delete) &&\n        isNumber(value.size));\n}\nfunction isSetLike(value) {\n    return !!(value &&\n        isFunction(value.add) &&\n        isFunction(value.has) &&\n        isFunction(value.delete) &&\n        isNumber(value.size));\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction isNotTruthy(value) {\n    return !value || !isTruthy(value);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction isTruthy(value) {\n    return !(!value || safeGet(function () { return !(value && (0 + value)); }, !value));\n}\nvar isBigInt = ( /*#__PURE__*/_createIsWithPoly(\"bigint\"));\n\nfunction _returnNothing() {\n    return;\n}\nfunction _returnEmptyArray() {\n    return [];\n}\nfunction _returnFalse() {\n    return false;\n}\n\nvar asString = ( /*#__PURE__*/_pureAssign(StrCls));\n\nvar ERROR_TYPE = \"[object Error]\";\n/*#__NO_SIDE_EFFECTS__*/\nfunction dumpObj(object, format) {\n    var propertyValueDump = EMPTY;\n    var objType = ObjProto[TO_STRING][CALL](object);\n    if (objType === ERROR_TYPE) {\n        object = { stack: asString(object.stack), message: asString(object.message), name: asString(object.name) };\n    }\n    try {\n        propertyValueDump = JSON.stringify(object, NULL_VALUE, format ? ((typeof format === \"number\") ? format : 4) : UNDEF_VALUE);\n        propertyValueDump = (propertyValueDump ? propertyValueDump.replace(/\"(\\w+)\"\\s*:\\s{0,1}/g, \"$1: \") : NULL_VALUE) || asString(object);\n    }\n    catch (e) {\n        propertyValueDump = \" - \" + dumpObj(e, format);\n    }\n    return objType + \": \" + propertyValueDump;\n}\n\nfunction throwError(message) {\n    throw new Error(message);\n}\nfunction throwTypeError(message) {\n    throw new TypeError(message);\n}\nfunction throwRangeError(message) {\n    throw new RangeError(message);\n}\n\nfunction _throwIfNullOrUndefined(obj) {\n    if (isStrictNullOrUndefined(obj)) {\n        throwTypeError(\"Cannot convert undefined or null to object\");\n    }\n}\nfunction _throwIfNotString(value) {\n    if (!isString(value)) {\n        throwTypeError(\"'\" + dumpObj(value) + \"' is not a string\");\n    }\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction objHasOwnProperty(obj, prop) {\n    return !!obj && ObjProto.hasOwnProperty[CALL](obj, prop);\n}\n\nvar _objGetOwnPropertyDescriptor$2 = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, GET_OWN_PROPERTY_DESCRIPTOR)), _returnNothing));\nvar objHasOwn = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, \"hasOwn\")), polyObjHasOwn));\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyObjHasOwn(obj, prop) {\n    _throwIfNullOrUndefined(obj);\n    return objHasOwnProperty(obj, prop) || !!_objGetOwnPropertyDescriptor$2(obj, prop);\n}\n\nfunction objForEachKey(theObject, callbackfn, thisArg) {\n    if (theObject && (isObject(theObject) || isFunction(theObject))) {\n        for (var prop in theObject) {\n            if (objHasOwn(theObject, prop)) {\n                if (callbackfn[CALL](thisArg || theObject, prop, theObject[prop]) === -1) {\n                    break;\n                }\n            }\n        }\n    }\n}\n\nfunction arrForEach(theArray, callbackfn, thisArg) {\n    if (theArray) {\n        var len = theArray[LENGTH] >>> 0;\n        for (var idx = 0; idx < len; idx++) {\n            if (idx in theArray) {\n                if (callbackfn[CALL](thisArg || theArray, theArray[idx], idx, theArray) === -1) {\n                    break;\n                }\n            }\n        }\n    }\n}\n\nvar _unwrapFunction = ( _unwrapFunctionWithPoly);\n/*#__NO_SIDE_EFFECTS__*/\nfunction _unwrapFunctionWithPoly(funcName, clsProto, polyFunc) {\n    var clsFn = clsProto ? clsProto[funcName] : NULL_VALUE;\n    return function (thisArg) {\n        var theFunc = (thisArg ? thisArg[funcName] : NULL_VALUE) || clsFn;\n        if (theFunc || polyFunc) {\n            var theArgs = arguments;\n            return (theFunc || polyFunc).apply(thisArg, theFunc ? ArrSlice[CALL](theArgs, 1) : theArgs);\n        }\n        throwTypeError(\"\\\"\" + asString(funcName) + \"\\\" not defined for \" + dumpObj(thisArg));\n    };\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction _unwrapProp(propName) {\n    return function (thisArg) {\n        return thisArg[propName];\n    };\n}\n\nfunction _objPropertyIsEnum(obj, propKey) {\n    var desc;\n    var fn = ObjClass.getOwnPropertyDescriptor;\n    if (!isStrictNullOrUndefined(obj) && fn) {\n        desc = safe(fn, [obj, propKey]).v || NULL_VALUE;\n    }\n    if (!desc) {\n        desc = safe(function () {\n            for (var key in obj) {\n                if (key === propKey) {\n                    return { enumerable: true };\n                }\n            }\n        }).v;\n    }\n    return (desc && desc.enumerable) || false;\n}\nvar objPropertyIsEnumerable = ( /*#__PURE__*/_unwrapFunctionWithPoly(\"propertyIsEnumerable\", NULL_VALUE, _objPropertyIsEnum));\n\nvar _objGetOwnPropertyDescriptor$1 = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, GET_OWN_PROPERTY_DESCRIPTOR)), _returnNothing));\nvar _objGetOwnPropertySymbols = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, GET_OWN_PROPERTY_SYMBOLS)), _returnEmptyArray));\nvar propMap = {\n    e: \"enumerable\",\n    c: \"configurable\",\n    v: \"value\",\n    w: \"writable\",\n    g: \"get\",\n    s: \"set\"\n};\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createProp(value) {\n    var prop = {};\n    prop[propMap[\"c\"]] = true;\n    prop[propMap[\"e\"]] = true;\n    if (value.l) {\n        prop.get = function () { return value.l.v; };\n        var desc = _objGetOwnPropertyDescriptor$1(value.l, \"v\");\n        if (desc && desc.set) {\n            prop.set = function (newValue) {\n                value.l.v = newValue;\n            };\n        }\n    }\n    objForEachKey(value, function (key, value) {\n        prop[propMap[key]] = isStrictUndefined(value) ? prop[propMap[key]] : value;\n    });\n    return prop;\n}\nvar objDefineProp = ( /*#__PURE__*/_pureRef(ObjClass, \"defineProperty\"));\nvar objDefineProperties = ( /*#__PURE__*/_pureRef(ObjClass, \"defineProperties\"));\nfunction objDefineGet(target, key, value, configurable, enumerable) {\n    var _a;\n    return objDefineProp(target, key, _createProp((_a = {\n            e: enumerable,\n            c: configurable\n        },\n        _a[isFunction(value) ? \"g\" : \"v\"] = value,\n        _a)));\n}\nfunction objDefineAccessors(target, prop, getProp, setProp, configurable, enumerable) {\n    var desc = {\n        e: enumerable,\n        c: configurable\n    };\n    if (getProp) {\n        desc.g = getProp;\n    }\n    if (setProp) {\n        desc.s = setProp;\n    }\n    return objDefineProp(target, prop, _createProp(desc));\n}\nfunction objDefine(target, key, propDesc) {\n    return objDefineProp(target, key, _createProp(propDesc));\n}\nfunction objDefineProps(target, propDescMap) {\n    var props = {};\n    objForEachKey(propDescMap, function (key, value) {\n        props[key] = _createProp(value);\n    });\n    arrForEach(_objGetOwnPropertySymbols(propDescMap), function (sym) {\n        if (objPropertyIsEnumerable(propDescMap, sym)) {\n            props[sym] = _createProp(propDescMap[sym]);\n        }\n    });\n    return objDefineProperties(target, props);\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createKeyValueMap(values, keyType, valueType, completeFn, writable) {\n    var theMap = {};\n    objForEachKey(values, function (key, value) {\n        _assignMapValue(theMap, key, keyType ? value : key);\n        _assignMapValue(theMap, value, valueType ? value : key);\n    });\n    return completeFn ? completeFn(theMap) : theMap;\n}\nfunction _assignMapValue(theMap, key, value, writable) {\n    objDefineProp(theMap, key, {\n        value: value,\n        enumerable: true,\n        writable: false\n    });\n}\n\nfunction _objIterateEntries(obj, mapper) {\n    var result = [];\n    objForEachKey(obj, function (key, val) {\n        result.push(mapper(key, val));\n    });\n    return result;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyObjKeys(obj) {\n    _throwIfNullOrUndefined(obj);\n    if (!isObject(obj)) {\n        throwTypeError(\"non-object \" + dumpObj(obj));\n    }\n    return _objIterateEntries(obj, function (k, _) { return k; });\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyObjEntries(value) {\n    return _objIterateEntries(value, function (k, v) { return [k, v]; });\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyObjValues(value) {\n    return _objIterateEntries(value, function (_, v) { return v; });\n}\n\nfunction polyObjIs(value1, value2) {\n    if (value1 !== value1) {\n        return value2 !== value2;\n    }\n    if (value1 === 0 && value2 === 0) {\n        return 1 / value1 === 1 / value2;\n    }\n    return value1 === value2;\n}\n\nvar objIsFrozen = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, \"isFrozen\")), _returnFalse));\nvar objIsSealed = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, \"isSealed\")), _returnFalse));\n\nvar _objFreeze = ( /*#__PURE__*/_pureRef(ObjClass, \"freeze\"));\nfunction _doNothing(value) {\n    return value;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction _getProto(value) {\n    _throwIfNullOrUndefined(value);\n    return value[__PROTO__] || NULL_VALUE;\n}\nvar objAssign = ( /*#__PURE__*/_pureRef(ObjClass, \"assign\"));\nvar objKeys = ( /*#__PURE__*/_pureRef(ObjClass, \"keys\"));\nfunction _deepFreeze(val, visited) {\n    if ((isArray(val) || isObject(val) || isFunction(val)) && !objIsFrozen(val)) {\n        for (var lp = 0; lp < visited.length; lp++) {\n            if (visited[lp] === val) {\n                return val;\n            }\n        }\n        visited.push(val);\n        objForEachKey(val, function (_key, propValue) {\n            _deepFreeze(propValue, visited);\n        });\n        objFreeze(val);\n    }\n    return val;\n}\nfunction objDeepFreeze(value) {\n    return _objFreeze ? _deepFreeze(value, []) : value;\n}\nvar objFreeze = ( /*#__PURE__*/_pureAssign(_objFreeze, _doNothing));\nvar objSeal = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, \"seal\")), _doNothing));\nvar objGetPrototypeOf = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, \"getPrototypeOf\")), _getProto));\nvar objEntries = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, \"entries\")), polyObjEntries));\nvar objValues = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, \"values\")), polyObjValues));\nvar objIs = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, \"is\")), polyObjIs));\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction createEnum(values) {\n    return _createKeyValueMap(values, 1 , 0 , objFreeze);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction createEnumKeyMap(values) {\n    return _createKeyValueMap(values, 0 , 0 , objFreeze);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction createEnumValueMap(values) {\n    return _createKeyValueMap(values, 1 , 1 , objFreeze);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction createSimpleMap(values) {\n    var mapClass = {};\n    objForEachKey(values, function (key, value) {\n        _assignMapValue(mapClass, key, value[1]);\n        _assignMapValue(mapClass, value[0], value[1]);\n    });\n    return objFreeze(mapClass);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction createTypeMap(values) {\n    return createSimpleMap(values);\n}\n\nvar _wellKnownSymbolMap = ( /*#__PURE__*/createEnumKeyMap({\n    asyncIterator: 0 ,\n    hasInstance: 1 ,\n    isConcatSpreadable: 2 ,\n    iterator: 3 ,\n    match: 4 ,\n    matchAll: 5 ,\n    replace: 6 ,\n    search: 7 ,\n    species: 8 ,\n    split: 9 ,\n    toPrimitive: 10 ,\n    toStringTag: 11 ,\n    unscopables: 12\n}));\n\nvar GLOBAL_CONFIG_KEY = \"__tsUtils$gblCfg\";\nvar _globalCfg;\n/*#__NO_SIDE_EFFECTS__*/\nfunction _getGlobalValue() {\n    var result;\n    if (typeof globalThis !== UNDEFINED) {\n        result = globalThis;\n    }\n    if (!result && typeof self !== UNDEFINED) {\n        result = self;\n    }\n    if (!result && typeof window !== UNDEFINED) {\n        result = window;\n    }\n    if (!result && typeof global !== UNDEFINED) {\n        result = global;\n    }\n    return result;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction _getGlobalConfig() {\n    if (!_globalCfg) {\n        var gbl = safe(_getGlobalValue).v || {};\n        _globalCfg = gbl[GLOBAL_CONFIG_KEY] = gbl[GLOBAL_CONFIG_KEY] || {};\n    }\n    return _globalCfg;\n}\n\nvar mathMin = ( /*#__PURE__*/_pureRef(MathCls, \"min\"));\nvar mathMax = ( /*#__PURE__*/_pureRef(MathCls, \"max\"));\n\nvar strSlice = ( /*#__PURE__*/_unwrapFunction(\"slice\", StrProto));\n\nvar strSubstring = ( /*#__PURE__*/_unwrapFunction(\"substring\", StrProto));\nvar strSubstr = ( /*#__PURE__*/_unwrapFunctionWithPoly(\"substr\", StrProto, polyStrSubstr));\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyStrSubstr(value, start, length) {\n    _throwIfNullOrUndefined(value);\n    if (length < 0) {\n        return EMPTY;\n    }\n    start = start || 0;\n    if (start < 0) {\n        start = mathMax(start + value[LENGTH], 0);\n    }\n    if (isUndefined(length)) {\n        return strSlice(value, start);\n    }\n    return strSlice(value, start, start + length);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction strLeft(value, count) {\n    return strSubstring(value, 0, count);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction strRight(value, count) {\n    return count <= 0 ? EMPTY : (value[LENGTH] > count ? strSlice(value, -count) : value);\n}\n\nfunction _tagAsPolyfill(target, polyfillTypeName) {\n    if (target) {\n        safe(function () {\n            target[POLYFILL_TAG] = true;\n            target[POLYFILL_TYPE_NAME] = polyfillTypeName;\n        });\n        safe(objDefine, [target, POLYFILL_TAG, {\n                v: true,\n                w: false,\n                e: false\n            }]);\n        safe(objDefine, [target, POLYFILL_TYPE_NAME, {\n                v: polyfillTypeName,\n                w: false,\n                e: false\n            }]);\n    }\n    return target;\n}\n\nvar objCreate = ( /* #__PURE__*/_pureAssign(( /* #__PURE__*/_pureRef(ObjClass, \"create\")), polyObjCreate));\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyObjCreate(obj, properties) {\n    var newObj = null;\n    function tempFunc() { }\n    if (!isStrictNullOrUndefined(obj)) {\n        var type = typeof obj;\n        if (type !== OBJECT && type !== FUNCTION) {\n            throwTypeError(\"Prototype must be an Object or function: \" + dumpObj(obj));\n        }\n        tempFunc[PROTOTYPE] = obj;\n        safe(function () {\n            tempFunc[__PROTO__] = obj;\n        });\n        newObj = new tempFunc();\n    }\n    else {\n        newObj = {};\n    }\n    if (properties) {\n        safe(objDefineProperties, [newObj, properties]);\n    }\n    return newObj;\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction utcNow() {\n    return (Date.now || polyUtcNow)();\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyUtcNow() {\n    return new Date().getTime();\n}\n\nfunction fnApply(fn, thisArg, argArray) {\n    return fn.apply(thisArg, argArray);\n}\nfunction fnCall(fn, thisArg) {\n    return fn.apply(thisArg, ArrSlice[CALL](arguments, 2));\n}\nfunction fnBind(fn, thisArg) {\n    return fn.bind.apply(fn, ArrSlice[CALL](arguments, 1));\n}\n\nvar _globalLazyTestHooks;\nfunction _initTestHooks() {\n    _globalLazyTestHooks = _getGlobalConfig();\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction getLazy(cb, argArray) {\n    var lazyValue = {};\n    !_globalLazyTestHooks && _initTestHooks();\n    lazyValue.b = _globalLazyTestHooks.lzy;\n    objDefineProp(lazyValue, \"v\", {\n        configurable: true,\n        get: function () {\n            var result = fnApply(cb, null, argArray);\n            if (!_globalLazyTestHooks.lzy) {\n                objDefineProp(lazyValue, \"v\", {\n                    value: result\n                });\n            }\n            lazyValue.b = _globalLazyTestHooks.lzy;\n            return result;\n        }\n    });\n    return lazyValue;\n}\nfunction setBypassLazyCache(newValue) {\n    !_globalLazyTestHooks && _initTestHooks();\n    _globalLazyTestHooks.lzy = newValue;\n}\nfunction getWritableLazy(cb, argArray) {\n    var lazyValue = {};\n    !_globalLazyTestHooks && _initTestHooks();\n    lazyValue.b = _globalLazyTestHooks.lzy;\n    var _setValue = function (newValue) {\n        objDefineProp(lazyValue, \"v\", {\n            value: newValue,\n            writable: true\n        });\n        if (lazyValue.b) {\n            delete lazyValue.b;\n        }\n    };\n    objDefineProp(lazyValue, \"v\", {\n        configurable: true,\n        get: function () {\n            var result = fnApply(cb, null, argArray);\n            if (!_globalLazyTestHooks.lzy) {\n                _setValue(result);\n            }\n            if (_globalLazyTestHooks.lzy && lazyValue.b !== _globalLazyTestHooks.lzy) {\n                lazyValue.b = _globalLazyTestHooks.lzy;\n            }\n            return result;\n        },\n        set: _setValue\n    });\n    return lazyValue;\n}\n\nvar mathRandom = ( /*#__PURE__*/_pureRef(MathCls, \"random\"));\n\nvar _uniqueInstanceId = ( /*#__PURE__*/getLazy(function () {\n    var value = (utcNow().toString(36).slice(2));\n    while (value.length < 16) {\n        value += mathRandom().toString(36).slice(2);\n    }\n    value = value.substring(0, 16);\n    return value;\n}));\n\nvar UNIQUE_REGISTRY_ID = \"_urid\";\nvar POLY_SYM = \"$nw21sym\";\nvar _polySymbols;\nvar _polyId = 0;\n/*#__NO_SIDE_EFFECTS__*/\nfunction _globalSymbolRegistry() {\n    if (!_polySymbols) {\n        var gblCfg = _getGlobalConfig();\n        _polySymbols = gblCfg.gblSym = gblCfg.gblSym || { k: {}, s: {} };\n    }\n    return _polySymbols;\n}\nvar _wellKnownSymbolCache;\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyNewSymbol(description) {\n    var uniqueId = \"_\" + _polyId++ + \"_\" + _uniqueInstanceId.v;\n    var symString = SYMBOL + \"(\" + description + \")\";\n    function _setProp(name, value) {\n        objDefine(theSymbol, name, {\n            v: value,\n            e: false,\n            w: false\n        });\n    }\n    var theSymbol = objCreate(null);\n    _setProp(\"description\", asString(description));\n    _setProp(TO_STRING, function () { return symString + POLY_SYM + uniqueId; });\n    _setProp(\"valueOf\", function () { return theSymbol; });\n    _setProp(\"v\", symString);\n    _setProp(\"_uid\", uniqueId);\n    return _tagAsPolyfill(theSymbol, \"symbol\");\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction polySymbolFor(key) {\n    var registry = _globalSymbolRegistry();\n    if (!objHasOwn(registry.k, key)) {\n        var newSymbol_1 = polyNewSymbol(key);\n        var regId_1 = objKeys(registry.s).length;\n        newSymbol_1[UNIQUE_REGISTRY_ID] = function () { return regId_1 + \"_\" + newSymbol_1[TO_STRING](); };\n        registry.k[key] = newSymbol_1;\n        registry.s[newSymbol_1[UNIQUE_REGISTRY_ID]()] = asString(key);\n    }\n    return registry.k[key];\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction polySymbolKeyFor(sym) {\n    if (!sym || !sym[TO_STRING] || strSubstring(sym[TO_STRING](), 0, 6) != SYMBOL) {\n        throwTypeError(sym + \" is not a symbol\");\n    }\n    var regId = _isPolyfill(sym) && sym[UNIQUE_REGISTRY_ID] && sym[UNIQUE_REGISTRY_ID]();\n    return regId ? _globalSymbolRegistry().s[regId] : undefined;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyGetKnownSymbol(name) {\n    !_wellKnownSymbolCache && (_wellKnownSymbolCache = {});\n    var result;\n    var knownName = _wellKnownSymbolMap[name];\n    if (knownName) {\n        result = _wellKnownSymbolCache[knownName] = _wellKnownSymbolCache[knownName] || polyNewSymbol(SYMBOL + \".\" + knownName);\n    }\n    return result;\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction createCachedValue(value) {\n    return objDefineProp({\n        toJSON: function () { return value; }\n    }, \"v\", { value: value });\n}\nvar createDeferredCachedValue = getDeferred;\n/*#__NO_SIDE_EFFECTS__*/\nfunction getDeferred(cb, argArray) {\n    var theValue = {\n        toJSON: function () { return theValue.v; }\n    };\n    return objDefineProp(theValue, \"v\", {\n        get: function () {\n            var result = fnApply(cb, null, argArray);\n            cb = NULL_VALUE;\n            objDefineProp(theValue, \"v\", { value: result });\n            return result;\n        },\n        configurable: true\n    });\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction getWritableDeferred(cb, argArray) {\n    var theValue = {\n        toJSON: function () { return theValue.v; }\n    };\n    var _setValue = function (newValue) {\n        objDefineProp(theValue, \"v\", {\n            value: newValue,\n            writable: true\n        });\n    };\n    return objDefineProp(theValue, \"v\", {\n        get: function () {\n            var result = fnApply(cb, null, argArray);\n            _setValue(result);\n            cb = NULL_VALUE;\n            return result;\n        },\n        set: _setValue,\n        configurable: true\n    });\n}\n\nvar WINDOW = \"window\";\nvar _cachedGlobal;\nfunction _getGlobalInstFn(getFn, theArgs) {\n    var cachedValue;\n    return function () {\n        !_globalLazyTestHooks && _initTestHooks();\n        if (!cachedValue || _globalLazyTestHooks.lzy) {\n            cachedValue = createCachedValue(safe(getFn, theArgs).v);\n        }\n        return cachedValue.v;\n    };\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction lazySafeGetInst(name) {\n    return getLazy(function () { return safe((getInst), [name]).v || UNDEF_VALUE; });\n}\nfunction getGlobal(useCached) {\n    !_globalLazyTestHooks && _initTestHooks();\n    if (!_cachedGlobal || useCached === false || _globalLazyTestHooks.lzy) {\n        _cachedGlobal = createCachedValue(safe(_getGlobalValue).v || NULL_VALUE);\n    }\n    return _cachedGlobal.v;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction getInst(name, useCached) {\n    var gbl;\n    if (!_cachedGlobal || useCached === false) {\n        gbl = getGlobal(useCached);\n    }\n    else {\n        gbl = _cachedGlobal.v;\n    }\n    if (gbl && gbl[name]) {\n        return gbl[name];\n    }\n    if (name === WINDOW) {\n        try {\n            return window;\n        }\n        catch (e) {\n        }\n    }\n    return NULL_VALUE;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction hasDocument() {\n    return !!( /*#__PURE__*/getDocument());\n}\nvar getDocument = ( /*#__PURE__*/_getGlobalInstFn(getInst, [\"document\"]));\n/*#__NO_SIDE_EFFECTS__*/\nfunction hasWindow() {\n    return !!( /*#__PURE__*/getWindow());\n}\nvar getWindow = ( /*#__PURE__*/_getGlobalInstFn(getInst, [WINDOW]));\n/*#__NO_SIDE_EFFECTS__*/\nfunction hasNavigator() {\n    return !!( /*#__PURE__*/getNavigator());\n}\nvar getNavigator = ( /*#__PURE__*/_getGlobalInstFn(getInst, [\"navigator\"]));\n/*#__NO_SIDE_EFFECTS__*/\nfunction hasHistory() {\n    return !!( /*#__PURE__*/getHistory());\n}\nvar getHistory = ( /*#__PURE__*/_getGlobalInstFn(getInst, [\"history\"]));\nvar isNode = ( /*#__PURE__*/_getGlobalInstFn(function () {\n    return !!( /*#__PURE__*/safe(function () { return (process && (process.versions || {}).node); }).v);\n}));\nvar isWebWorker = ( /*#__PURE__*/_getGlobalInstFn(function () {\n    return !!( /*#__PURE__*/safe(function () { return self && self instanceof WorkerGlobalScope; }).v);\n}));\n\nvar _symbol;\nvar _symbolFor;\nvar _symbolKeyFor;\n/*#__NO_SIDE_EFFECTS__*/\nfunction _initSymbol() {\n    _symbol = ( /*#__PURE__*/createCachedValue(safe((getInst), [SYMBOL]).v));\n    return _symbol;\n}\nfunction _getSymbolKey(key) {\n    var gblSym = ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol());\n    return (gblSym.v ? gblSym.v[key] : UNDEF_VALUE);\n}\nvar isSymbol = ( /*#__PURE__*/_createIsWithPoly(\"symbol\"));\n/*#__NO_SIDE_EFFECTS__*/\nfunction hasSymbol() {\n    return !!( /*#__PURE__*/getSymbol());\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction getSymbol() {\n    !_globalLazyTestHooks && _initTestHooks();\n    return ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol()).v;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction getKnownSymbol(name, noPoly) {\n    var knownName = _wellKnownSymbolMap[name];\n    !_globalLazyTestHooks && _initTestHooks();\n    var sym = ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol());\n    return sym.v ? sym.v[knownName || name] : (!noPoly ? polyGetKnownSymbol(name) : UNDEF_VALUE);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction newSymbol(description, noPoly) {\n    !_globalLazyTestHooks && _initTestHooks();\n    var sym = ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol());\n    return sym.v ? sym.v(description) : (!noPoly ? polyNewSymbol(description) : NULL_VALUE);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction symbolFor(key) {\n    !_globalLazyTestHooks && _initTestHooks();\n    _symbolFor = ((!_globalLazyTestHooks.lzy ? _symbolFor : 0) || ( /*#__PURE__*/createCachedValue(safe((_getSymbolKey), [\"for\"]).v)));\n    return (_symbolFor.v || polySymbolFor)(key);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction symbolKeyFor(sym) {\n    !_globalLazyTestHooks && _initTestHooks();\n    _symbolKeyFor = ((!_globalLazyTestHooks.lzy ? _symbolKeyFor : 0) || ( /*#__PURE__*/createCachedValue(safe((_getSymbolKey), [\"keyFor\"]).v)));\n    return (_symbolKeyFor.v || polySymbolKeyFor)(sym);\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction isIterator(value) {\n    return !!value && isFunction(value.next);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction isIterable(value) {\n    return !isStrictNullOrUndefined(value) && isFunction(value[getKnownSymbol(3 )]);\n}\n\nvar _iterSymbol$1;\nfunction iterForOf(iter, callbackfn, thisArg) {\n    if (iter) {\n        if (!isIterator(iter)) {\n            !_iterSymbol$1 && (_iterSymbol$1 = createCachedValue(getKnownSymbol(3 )));\n            iter = iter[_iterSymbol$1.v] ? iter[_iterSymbol$1.v]() : NULL_VALUE;\n        }\n        if (isIterator(iter)) {\n            var err = UNDEF_VALUE;\n            var iterResult = UNDEF_VALUE;\n            try {\n                var count = 0;\n                while (!(iterResult = iter.next()).done) {\n                    if (callbackfn[CALL](thisArg || iter, iterResult.value, count, iter) === -1) {\n                        break;\n                    }\n                    count++;\n                }\n            }\n            catch (failed) {\n                err = { e: failed };\n                if (iter.throw) {\n                    iterResult = NULL_VALUE;\n                    iter.throw(err);\n                }\n            }\n            finally {\n                try {\n                    if (iterResult && !iterResult.done) {\n                        iter.return && iter.return(iterResult);\n                    }\n                }\n                finally {\n                    if (err) {\n                        // eslint-disable-next-line no-unsafe-finally\n                        throw err.e;\n                    }\n                }\n            }\n        }\n    }\n}\n\nfunction arrAppend(target, elms) {\n    if (!isUndefined(elms) && target) {\n        if (isArray(elms)) {\n            fnApply(target.push, target, elms);\n        }\n        else if (isIterator(elms) || isIterable(elms)) {\n            iterForOf(elms, function (elm) {\n                target.push(elm);\n            });\n        }\n        else {\n            target.push(elms);\n        }\n    }\n    return target;\n}\n\nvar arrEvery = /*#__PURE__*/ _unwrapFunction(\"every\", ArrProto);\nvar arrFilter = /*#__PURE__*/ _unwrapFunction(\"filter\", ArrProto);\n\nvar arrIndexOf = ( /*#__PURE__*/_unwrapFunction(\"indexOf\", ArrProto));\nvar arrLastIndexOf = ( /*#__PURE__*/_unwrapFunction(\"lastIndexOf\", ArrProto));\n\nvar arrMap = ( /*#__PURE__*/_unwrapFunction(\"map\", ArrProto));\n\nfunction arrSlice(theArray, start, end) {\n    return ((theArray ? theArray[\"slice\"] : NULL_VALUE) || ArrSlice).apply(theArray, ArrSlice[CALL](arguments, 1));\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyIsArray(value) {\n    if (isNullOrUndefined(value)) {\n        return false;\n    }\n    return objToString(value) === \"[object Array]\";\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyArrIncludes(theArray, searchElement, fromIndex) {\n    return arrIndexOf(theArray, searchElement, fromIndex) !== -1;\n}\nfunction polyArrFind(theArray, callbackFn, thisArg) {\n    var result;\n    var idx = polyArrFindIndex(theArray, callbackFn, thisArg);\n    return idx !== -1 ? theArray[idx] : result;\n}\nfunction polyArrFindIndex(theArray, callbackFn, thisArg) {\n    var result = -1;\n    arrForEach(theArray, function (value, index) {\n        if (callbackFn[CALL](thisArg | theArray, value, index, theArray)) {\n            result = index;\n            return -1;\n        }\n    });\n    return result;\n}\nfunction polyArrFindLast(theArray, callbackFn, thisArg) {\n    var result;\n    var idx = polyArrFindLastIndex(theArray, callbackFn, thisArg);\n    return idx !== -1 ? theArray[idx] : result;\n}\nfunction polyArrFindLastIndex(theArray, callbackFn, thisArg) {\n    var result = -1;\n    var len = theArray[LENGTH] >>> 0;\n    for (var idx = len - 1; idx >= 0; idx--) {\n        if (idx in theArray && callbackFn[CALL](thisArg | theArray, theArray[idx], idx, theArray)) {\n            result = idx;\n            break;\n        }\n    }\n    return result;\n}\nfunction polyArrFrom(theValue, mapFn, thisArg) {\n    if (isArray(theValue)) {\n        var result_1 = arrSlice(theValue);\n        return mapFn ? arrMap(result_1, mapFn, thisArg) : result_1;\n    }\n    var result = [];\n    iterForOf(theValue, function (value, cnt) {\n        return result.push(mapFn ? mapFn[CALL](thisArg, value, cnt) : value);\n    });\n    return result;\n}\n\nvar arrFind = /*#__PURE__*/ _unwrapFunctionWithPoly(\"find\", ArrProto, polyArrFind);\nvar arrFindIndex = /*#__PURE__*/ _unwrapFunctionWithPoly(\"findIndex\", ArrProto, polyArrFindIndex);\nvar arrFindLast = /*#__PURE__*/ _unwrapFunctionWithPoly(\"findLast\", ArrProto, polyArrFindLast);\nvar arrFindLastIndex = /*#__PURE__*/ _unwrapFunctionWithPoly(\"findLastIndex\", ArrProto, polyArrFindLastIndex);\n\nvar arrFrom = ( /* #__PURE__*/_pureAssign(( /* #__PURE__*/_pureRef(ArrCls, \"from\")), polyArrFrom));\n\nvar arrIncludes = ( /*#__PURE__*/_unwrapFunctionWithPoly(\"includes\", ArrProto, polyArrIncludes));\nvar arrContains = arrIncludes;\n\nvar arrReduce = ( /*#__PURE__*/_unwrapFunction(\"reduce\", ArrProto));\n\nvar arrSome = ( /*#__PURE__*/_unwrapFunction(\"some\", ArrProto));\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction createFnDeferredProxy(hostFn, funcName) {\n    return function () {\n        var theArgs = ArrSlice[CALL](arguments);\n        var theHost = hostFn();\n        return fnApply(theHost[funcName], theHost, theArgs);\n    };\n}\nfunction createProxyFuncs(target, host, funcDefs) {\n    if (target && host && isArray(funcDefs)) {\n        var isDeferred_1 = isFunction(host);\n        arrForEach(funcDefs, function (funcDef) {\n            var targetName = (funcDef.as || funcDef.n);\n            if (funcDef.rp === false && target[targetName]) {\n                return;\n            }\n            target[targetName] = isDeferred_1 ?\n                createFnDeferredProxy(host, funcDef.n) :\n                fnBind(host[funcDef.n], host);\n        });\n    }\n    return target;\n}\n\nvar _iterSymbol;\n/*#__NO_SIDE_EFFECTS__*/\nfunction readArgs(theArgs, start, end) {\n    if (!objHasOwn(theArgs, LENGTH)) {\n        !_iterSymbol && (_iterSymbol = createCachedValue(hasSymbol() && getKnownSymbol(3 )));\n        var iterFn = void 0;\n        if (_iterSymbol.v) {\n            iterFn = theArgs[_iterSymbol.v];\n        }\n        if (iterFn) {\n            var values_1 = [];\n            var from_1 = (start === UNDEF_VALUE || start < 0) ? 0 : start;\n            var to_1 = end < 0 || start < 0 ? UNDEF_VALUE : end;\n            iterForOf(iterFn[CALL](theArgs), function (value, cnt) {\n                if (to_1 !== UNDEF_VALUE && cnt >= to_1) {\n                    return -1;\n                }\n                if (cnt >= from_1) {\n                    values_1.push(value);\n                }\n            });\n            if ((start === UNDEF_VALUE || start >= 0) && (end === UNDEF_VALUE || end >= 0)) {\n                return values_1;\n            }\n            theArgs = values_1;\n        }\n    }\n    return arrSlice(theArgs, start, end);\n}\n\nvar _isProtoArray;\nvar objSetPrototypeOf = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, \"setPrototypeOf\")), _polyObjSetPrototypeOf));\nfunction _polyObjSetPrototypeOf(obj, proto) {\n    var _a;\n    !_isProtoArray && (_isProtoArray = createCachedValue((_a = {}, _a[__PROTO__] = [], _a) instanceof Array));\n    _isProtoArray.v ? obj[__PROTO__] = proto : objForEachKey(proto, function (key, value) { return obj[key] = value; });\n    return obj;\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createCustomError(name, d, b) {\n    safe(objDefine, [d, NAME, { v: name, c: true, e: false }]);\n    d = objSetPrototypeOf(d, b);\n    function __() {\n        this[CONSTRUCTOR] = d;\n        safe(objDefine, [this, NAME, { v: name, c: true, e: false }]);\n    }\n    d[PROTOTYPE] = b === NULL_VALUE ? objCreate(b) : (__[PROTOTYPE] = b[PROTOTYPE], new __());\n    return d;\n}\nfunction _setName(baseClass, name) {\n    name && (baseClass[NAME] = name);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction createCustomError(name, constructCb, errorBase) {\n    var theBaseClass = errorBase || Error;\n    var orgName = theBaseClass[PROTOTYPE][NAME];\n    var captureFn = Error.captureStackTrace;\n    return _createCustomError(name, function () {\n        var _this = this;\n        var theArgs = arguments;\n        try {\n            safe(_setName, [theBaseClass, name]);\n            var _self = fnApply(theBaseClass, _this, ArrSlice[CALL](theArgs)) || _this;\n            if (_self !== _this) {\n                var orgProto = objGetPrototypeOf(_this);\n                if (orgProto !== objGetPrototypeOf(_self)) {\n                    objSetPrototypeOf(_self, orgProto);\n                }\n            }\n            captureFn && captureFn(_self, _this[CONSTRUCTOR]);\n            constructCb && constructCb(_self, theArgs);\n            return _self;\n        }\n        finally {\n            safe(_setName, [theBaseClass, orgName]);\n        }\n    }, theBaseClass);\n}\nvar _unsupportedError;\nfunction throwUnsupported(message) {\n    if (!_unsupportedError) {\n        _unsupportedError = createCustomError(\"UnsupportedError\");\n    }\n    throw new _unsupportedError(message);\n}\n\nfunction isElement(value) {\n    return !!value && value.nodeType === 1 &&\n        !!value.nodeName &&\n        !!(typeof Element !== \"undefined\" && value instanceof Element);\n}\nfunction isElementLike(value) {\n    return !!value && value.nodeType === 1 && !!value.nodeName;\n}\n\nfunction isEmpty(value) {\n    var result = isStrictNullOrUndefined(value);\n    if (!result) {\n        if (isString(value) || isArray(value)) {\n            result = (value.length === 0);\n        }\n        else if (isMapLike(value) || isSetLike(value)) {\n            result = (value.size === 0);\n        }\n        else if (isObject(value)) {\n            result = objKeys(value).length === 0;\n        }\n    }\n    return result;\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createTrimFn(exp) {\n    return function _doTrim(value) {\n        _throwIfNullOrUndefined(value);\n        if (value && value.replace) {\n            value = value.replace(exp, EMPTY);\n        }\n        return value;\n    };\n}\nvar polyStrTrim = ( /*#__PURE__*/_createTrimFn(/^\\s+|(?=\\s)\\s+$/g));\nvar polyStrTrimStart = ( /*#__PURE__*/_createTrimFn(/^\\s+/g));\nvar polyStrTrimEnd = ( /*#__PURE__*/_createTrimFn(/(?=\\s)\\s+$/g));\n\nvar strTrim = ( /*#__PURE__*/_unwrapFunctionWithPoly(\"trim\", StrProto, polyStrTrim));\nvar strTrimStart = ( /*#__PURE__*/_unwrapFunctionWithPoly(\"trimStart\", StrProto, polyStrTrimStart));\nvar strTrimLeft = ( /*#__PURE__*/_pureAssign(strTrimStart));\nvar strTrimEnd = ( /*#__PURE__*/_unwrapFunctionWithPoly(\"trimEnd\", StrProto, polyStrTrimEnd));\nvar strTrimRight = ( /*#__PURE__*/_pureAssign(strTrimEnd));\n\nvar strUpper = ( /*#__PURE__*/_unwrapFunction(\"toUpperCase\", StrProto));\nvar strLower = ( /*#__PURE__*/_unwrapFunction(\"toLowerCase\", StrProto));\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction _convertCase(value, newPrefix, upperWord) {\n    return strTrim(asString(value)).replace(/((_|\\W)+(\\w){0,1}|([a-z])([A-Z]))/g, function (_match, _g1, _g2, wordStart, upperPrefix, upperLetter) {\n        var convertMatch = wordStart || upperLetter || EMPTY;\n        if (upperWord) {\n            convertMatch = strUpper(convertMatch);\n        }\n        return (upperPrefix || EMPTY) + newPrefix + convertMatch;\n    });\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction strLetterCase(value) {\n    return asString(value).replace(/(_|\\b)\\w/g, strUpper);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction strCamelCase(value, upperFirst) {\n    var result = _convertCase(value, \"\", true);\n    return result.replace(/^\\w/, upperFirst ? strUpper : strLower);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction strKebabCase(value, scream) {\n    var result = _convertCase(value, \"-\");\n    return (scream ? strUpper : strLower)(result);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction strSnakeCase(value, scream) {\n    var result = _convertCase(value, \"_\");\n    return (scream ? strUpper : strLower)(result);\n}\n\nvar mathFloor = ( /*#__PURE__*/_pureRef(MathCls, \"floor\"));\nvar mathCeil = ( /*#__PURE__*/_pureRef(MathCls, \"ceil\"));\n\nvar mathTrunc = ( /* #__PURE__*/_pureAssign(( /* #__PURE__*/_pureRef(MathCls, \"trunc\")), polyMathTrunc));\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyMathTrunc(value) {\n    var theValue = +value;\n    return (theValue > 0 ? mathFloor : mathCeil)(theValue);\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction mathToInt(value, throwInfinity) {\n    var result = +value;\n    if (throwInfinity && (result === Infinity || result == Infinity)) {\n        throwRangeError(\"invalid value [\" + dumpObj(value) + \"]\");\n    }\n    return result !== result || result === 0 ? 0 : mathTrunc(result);\n}\n\nvar strRepeat = ( /*#__PURE__*/_unwrapFunctionWithPoly(\"repeat\", StrProto, polyStrRepeat));\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyStrRepeat(value, count) {\n    _throwIfNullOrUndefined(value);\n    count = mathToInt(count, true);\n    if (count < 0) {\n        throwRangeError(\"invalid count must be >= 0 && < Infinity\");\n    }\n    var pad = isString(value) ? value : asString(value);\n    var result = EMPTY;\n    for (; count > 0; (count >>>= 1) && (pad += pad)) {\n        if (count & 1) {\n            result += pad;\n        }\n    }\n    return result;\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction _padValue(value, targetLength, padString) {\n    var result = EMPTY;\n    targetLength = mathToInt(targetLength, true);\n    targetLength >>= 0;\n    var len = value[LENGTH];\n    if (len < targetLength) {\n        result = isNullOrUndefined(padString) ? \" \" : asString(padString);\n        targetLength = targetLength - len;\n        if (targetLength > result[LENGTH]) {\n            result = strRepeat(result, mathCeil(targetLength / result[LENGTH]));\n        }\n        if (result[LENGTH] > targetLength) {\n            result = strSubstring(result, 0, targetLength);\n        }\n    }\n    return result;\n}\nvar strPadStart = ( /*#__PURE__*/_unwrapFunctionWithPoly(\"padStart\", StrProto, polyStrPadStart));\nvar strPadEnd = ( /*#__PURE__*/_unwrapFunctionWithPoly(\"padEnd\", StrProto, polyStrPadEnd));\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyStrPadStart(value, targetLength, padString) {\n    return _padValue(value, targetLength, padString) + value;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyStrPadEnd(value, targetLength, padString) {\n    return value + _padValue(value, targetLength, padString);\n}\n\nvar DBL_QUOTE = \"\\\"\";\nvar INVALID_JS_NAME = /([^\\w\\d_$])/g;\nvar _htmlEntityCache;\n/*#__NO_SIDE_EFFECTS__*/\nfunction normalizeJsName(jsName, camelCase) {\n    var result = asString(jsName).replace(INVALID_JS_NAME, \"_\");\n    return !isUndefined(camelCase) ? strCamelCase(result, !camelCase) : result;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction encodeAsJson(value, format) {\n    var result;\n    if (isString(value)) {\n        result = DBL_QUOTE + value.replace(/[^\\w .,\\-!@#$%\\^&*\\(\\)_+={}\\[\\]:;|<>?]/g, function (match) {\n            if (match === DBL_QUOTE || match === \"\\\\\") {\n                return \"\\\\\" + match;\n            }\n            var hex = match.charCodeAt(0)[TO_STRING](16);\n            return \"\\\\u\" + strPadStart(strUpper(hex), 4, \"0\");\n        }) + DBL_QUOTE;\n    }\n    else {\n        try {\n            result = JSON.stringify(value, NULL_VALUE, format ? (isNumber(format) ? format : 4) : UNDEF_VALUE);\n        }\n        catch (e) {\n            result = DBL_QUOTE + dumpObj(e) + DBL_QUOTE;\n        }\n    }\n    return result;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction encodeAsHtml(value) {\n    !_htmlEntityCache && (_htmlEntityCache = {\n        \"&\": \"amp\",\n        \"<\": \"lt\",\n        \">\": \"gt\",\n        \"\\\"\": \"quot\",\n        \"'\": \"#39\"\n    });\n    return asString(value).replace(/[&<>\"']/g, function (match) { return \"&\" + _htmlEntityCache[match] + \";\"; });\n}\n\nvar _fnToString;\nvar _objCtrFnString;\nvar _gblWindow;\n/*#__NO_SIDE_EFFECTS__*/\nfunction isPlainObject(value) {\n    if (!value || typeof value !== OBJECT) {\n        return false;\n    }\n    if (!_gblWindow) {\n        _gblWindow = hasWindow() ? getWindow() : true;\n    }\n    var result = false;\n    if (value !== _gblWindow) {\n        if (!_objCtrFnString) {\n            _fnToString = Function[PROTOTYPE][TO_STRING];\n            _objCtrFnString = _fnToString[CALL](ObjClass);\n        }\n        try {\n            var proto = objGetPrototypeOf(value);\n            result = !proto;\n            if (!result) {\n                if (objHasOwnProperty(proto, CONSTRUCTOR)) {\n                    proto = proto[CONSTRUCTOR];\n                }\n                result = !!(proto && typeof proto === FUNCTION && _fnToString[CALL](proto) === _objCtrFnString);\n            }\n        }\n        catch (ex) {\n        }\n    }\n    return result;\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction _defaultDeepCopyHandler(details) {\n    details.value && plainObjDeepCopyHandler(details);\n    return true;\n}\nvar defaultDeepCopyHandlers = [\n    arrayDeepCopyHandler,\n    plainObjDeepCopyHandler,\n    functionDeepCopyHandler,\n    dateDeepCopyHandler\n];\n/*#__NO_SIDE_EFFECTS__*/\nfunction _getSetVisited(visitMap, source, newPath, cb) {\n    var theEntry;\n    arrForEach(visitMap, function (entry) {\n        if (entry.k === source) {\n            theEntry = entry;\n            return -1;\n        }\n    });\n    if (!theEntry) {\n        theEntry = { k: source, v: source };\n        visitMap.push(theEntry);\n        cb(theEntry);\n    }\n    return theEntry.v;\n}\nfunction _deepCopy(visitMap, value, ctx, key) {\n    var userHandler = ctx.handler;\n    var newPath = ctx.path ? (key ? ctx.path.concat(key) : ctx.path) : [];\n    var newCtx = {\n        handler: ctx.handler,\n        src: ctx.src,\n        path: newPath\n    };\n    var theType = typeof value;\n    var isPlain = false;\n    var isPrim = value === NULL_VALUE;\n    if (!isPrim) {\n        if (value && theType === OBJECT) {\n            isPlain = isPlainObject(value);\n        }\n        else {\n            isPrim = isPrimitiveType(theType);\n        }\n    }\n    var details = {\n        type: theType,\n        isPrim: isPrim,\n        isPlain: isPlain,\n        value: value,\n        result: value,\n        path: newPath,\n        origin: ctx.src,\n        copy: function (source, newKey) {\n            return _deepCopy(visitMap, source, newKey ? newCtx : ctx, newKey);\n        },\n        copyTo: function (target, source) {\n            return _copyProps(visitMap, target, source, newCtx);\n        }\n    };\n    if (!details.isPrim) {\n        return _getSetVisited(visitMap, value, newPath, function (newEntry) {\n            objDefine(details, \"result\", {\n                g: function () {\n                    return newEntry.v;\n                },\n                s: function (newValue) {\n                    newEntry.v = newValue;\n                }\n            });\n            var idx = 0;\n            var handler = userHandler;\n            while (!(handler || (idx < defaultDeepCopyHandlers.length ? defaultDeepCopyHandlers[idx++] : _defaultDeepCopyHandler))[CALL](ctx, details)) {\n                handler = NULL_VALUE;\n            }\n        });\n    }\n    if (userHandler && userHandler[CALL](ctx, details)) {\n        return details.result;\n    }\n    return value;\n}\nfunction _copyProps(visitMap, target, source, ctx) {\n    if (!isNullOrUndefined(source)) {\n        for (var key in source) {\n            target[key] = _deepCopy(visitMap, source[key], ctx, key);\n        }\n    }\n    return target;\n}\nfunction objCopyProps(target, source, handler) {\n    var ctx = {\n        handler: handler,\n        src: source,\n        path: []\n    };\n    return _copyProps([], target, source, ctx);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction objDeepCopy(source, handler) {\n    var ctx = {\n        handler: handler,\n        src: source\n    };\n    return _deepCopy([], source, ctx);\n}\nfunction arrayDeepCopyHandler(details) {\n    var value = details.value;\n    if (isArray(value)) {\n        var target = details.result = [];\n        target.length = value.length;\n        details.copyTo(target, value);\n        return true;\n    }\n    return false;\n}\nfunction dateDeepCopyHandler(details) {\n    var value = details.value;\n    if (isDate(value)) {\n        details.result = new Date(value.getTime());\n        return true;\n    }\n    return false;\n}\nfunction functionDeepCopyHandler(details) {\n    if (details.type === FUNCTION) {\n        return true;\n    }\n    return false;\n}\nfunction plainObjDeepCopyHandler(details) {\n    var value = details.value;\n    if (value && details.isPlain) {\n        var target = details.result = {};\n        details.copyTo(target, value);\n        return true;\n    }\n    return false;\n}\n\nfunction _doExtend(target, theArgs) {\n    arrForEach(theArgs, function (theArg) {\n        objCopyProps(target, theArg);\n    });\n    return target;\n}\nfunction deepExtend(target, obj1, obj2, obj3, obj4, obj5, obj6) {\n    return _doExtend(objDeepCopy(target) || {}, ArrSlice[CALL](arguments));\n}\nfunction objExtend(target, obj1, obj2, obj3, obj4, obj5, obj6) {\n    return _doExtend(target || {}, ArrSlice[CALL](arguments));\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyStrSymSplit(value, splitter, limit) {\n    var splitFn = splitter ? splitter[getKnownSymbol(9 )] : UNDEF_VALUE;\n    return splitFn ? splitFn(value, limit) : [value];\n}\n\nvar strSplit = ( /*#__PURE__*/_unwrapFunction(\"split\", StrProto));\nvar strSymSplit = ( /*#__PURE__*/_unwrapFunctionWithPoly(\"split\", StrProto, polyStrSymSplit));\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction getValueByKey(target, path, defValue) {\n    if (!path || !target) {\n        return defValue;\n    }\n    var parts = strSplit(path, \".\");\n    var cnt = parts.length;\n    for (var lp = 0; lp < cnt && !isNullOrUndefined(target); lp++) {\n        target = target[parts[lp]];\n    }\n    return (!isNullOrUndefined(target) ? target : defValue);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction getValueByIter(target, iter, defValue) {\n    if (!iter || !target) {\n        return defValue;\n    }\n    iterForOf(iter, function (value) {\n        if (isNullOrUndefined(target)) {\n            return -1;\n        }\n        target = target[value];\n    });\n    return (!isNullOrUndefined(target) ? target : defValue);\n}\nfunction setValueByKey(target, path, value) {\n    if (target && path) {\n        var parts = strSplit(path, \".\");\n        var lastKey = parts.pop();\n        arrForEach(parts, function (key) {\n            if (isNullOrUndefined(target[key])) {\n                target[key] = {};\n            }\n            target = target[key];\n        });\n        target[lastKey] = value;\n    }\n}\nfunction setValueByIter(target, iter, value) {\n    if (target && iter) {\n        var lastKey_1;\n        iterForOf(iter, function (key) {\n            if (lastKey_1) {\n                if (isNullOrUndefined(target[lastKey_1])) {\n                    target[lastKey_1] = {};\n                }\n                target = target[lastKey_1];\n            }\n            lastKey_1 = key;\n        });\n        target[lastKey_1] = value;\n    }\n}\n\nvar getLength = ( /*#__PURE__*/_unwrapProp(LENGTH));\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction getIntValue(value, defValue) {\n    try {\n        var theValue = value;\n        if (!isNumber(value)) {\n            theValue = parseInt(asString(value), 10);\n        }\n        return (isNullOrUndefined(value) || isNaN(theValue)) ? defValue : theValue;\n    }\n    catch (e) {\n    }\n    return defValue;\n}\nvar isInteger = ( /* #__PURE__*/_pureAssign(( /* #__PURE__*/_pureRef(NumberCls, \"isInteger\")), _polyNumberIsInteger));\nfunction _polyNumberIsInteger(value) {\n    return isNumber(value) && !isNaN(value) &&\n        isFinite(value) &&\n        mathFloor(value) === value;\n}\nfunction isFiniteNumber(value) {\n    return isNumber(value) && !isNaN(value) && isFinite(value);\n}\n\nvar _perf;\n/*#__NO_SIDE_EFFECTS__*/\nfunction hasPerformance() {\n    return !!getPerformance();\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction getPerformance() {\n    !_globalLazyTestHooks && _initTestHooks();\n    if (!_perf || _globalLazyTestHooks.lzy) {\n        _perf = createCachedValue(safe((getInst), [\"performance\"]).v);\n    }\n    return _perf.v;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction perfNow() {\n    var perf = getPerformance();\n    if (perf && perf.now) {\n        return perf.now();\n    }\n    return utcNow();\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction elapsedTime(startTime) {\n    return perfNow() - startTime;\n}\n\nvar MATCH_ANY = \"(.*)\";\nvar MATCH_SINGLE = \"(.)\";\nfunction _createRegExp(value, escapeRgx, replaceFn, ignoreCase, fullMatch) {\n    // eslint-disable-next-line security/detect-non-literal-regexp\n    return new RegExp((fullMatch ? \"^\" : EMPTY) + replaceFn(value.replace(escapeRgx, \"\\\\$1\")) + (fullMatch ? \"$\" : EMPTY), ignoreCase ? \"i\" : \"\");\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction createWildcardRegex(value, ignoreCase, fullMatch) {\n    return _createRegExp(asString(value), /([-+|^$#\\.\\?{}()\\[\\]\\\\\\/\\\"\\'])/g, function (value) {\n        return value.replace(/\\*/g, MATCH_ANY);\n    }, !!ignoreCase, fullMatch);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction createFilenameRegex(value, ignoreCase, fullMatch) {\n    return _createRegExp(asString(value), /([-+|^$#\\.{}()\\\\\\/\\[\\]\\\"\\'])/g, function (value) {\n        return value.replace(/(\\\\\\\\|\\\\\\/|\\*|\\?)/g, function (_all, g1) {\n            if (g1 == \"\\\\/\" || g1 == \"\\\\\\\\\") {\n                return \"[\\\\\\\\\\\\/]{1}\";\n            }\n            return g1 == \"*\" ? MATCH_ANY : MATCH_SINGLE;\n        });\n    }, !!ignoreCase, fullMatch);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction makeGlobRegex(value, ignoreCase, fullMatch) {\n    return _createRegExp(asString(value), /([-+|^$#\\.{}()\\\\\\/\\[\\]\\\"\\'])/g, function (value) {\n        return value.replace(/(\\*\\*\\\\[\\\\\\/]|\\\\\\\\|\\\\\\/|\\*\\*|\\*|\\?)/g, function (_all, g1) {\n            if (g1 == \"**\\\\/\" || g1 == \"**\\\\\\\\\") {\n                return \"(.*[\\\\\\\\\\\\/])*\";\n            }\n            if (g1 === \"\\\\/\" || g1 == \"\\\\\\\\\") {\n                return \"[\\\\\\\\\\\\/]{1}\";\n            }\n            if (g1 === \"**\") {\n                return MATCH_ANY;\n            }\n            return g1 === \"*\" ? \"([^\\\\\\\\\\\\/]*)\" : \"([^\\\\\\\\\\\\/]{1})\";\n        });\n    }, !!ignoreCase, fullMatch);\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction safeGetLazy(cb, defValue, argArray) {\n    return getLazy(function () {\n        var result = safe(cb, argArray);\n        return result.e ? defValue : result.v;\n    });\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction safeGetWritableLazy(cb, defValue, argArray) {\n    return getWritableLazy(function () {\n        var result = safe(cb, argArray);\n        return result.e ? defValue : result.v;\n    });\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction safeGetDeferred(cb, defValue, argArray) {\n    return getDeferred(function () {\n        var result = safe(cb, argArray);\n        return result.e ? defValue : result.v;\n    });\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction safeGetWritableDeferred(cb, defValue, argArray) {\n    return getWritableDeferred(function () {\n        var result = safe(cb, argArray);\n        return result.e ? defValue : result.v;\n    });\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction _checkLength(value, props) {\n    var result;\n    arrForEach(props, function (prop) {\n        if (prop in value) {\n            var propValue = value[prop];\n            result = (isFunction(propValue) ? propValue() : propValue) > 0;\n            return -1;\n        }\n    });\n    return result;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction _hasValue(value, depth) {\n    var result = value === false || value === 0;\n    if (!result && !isNullOrUndefined(value)) {\n        if (isArray(value)) {\n            result = value[LENGTH] > 0;\n        }\n        else if (isDate(value)) {\n            result = !isNaN(value.getTime());\n        }\n        else if (isBoolean(value)) {\n            return true;\n        }\n        else if (isObject(value)) {\n            try {\n                var chkValue = _checkLength(value, [LENGTH, \"byteLength\", \"size\", \"count\"]);\n                if (isBoolean(chkValue)) {\n                    return chkValue;\n                }\n                if (isFunction(value.valueOf) && depth < 5) {\n                    return _hasValue(value.valueOf(), ++depth);\n                }\n            }\n            catch (e) {\n            }\n            return !!objKeys(value)[LENGTH];\n        }\n        else {\n            result = isTruthy(value);\n        }\n    }\n    return result;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction hasValue(value) {\n    return _hasValue(value, 0);\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction createIterable(ctx) {\n    return makeIterable({}, ctx);\n}\nfunction makeIterable(target, ctx) {\n    var itSymbol = getKnownSymbol(3 );\n    function _createIterator() {\n        return createIterator(ctx);\n    }\n    target[itSymbol] = _createIterator;\n    return target;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction createIterator(ctx) {\n    var isDone = false;\n    function _value() {\n        return ctx.v;\n    }\n    function _next() {\n        if (!isDone) {\n            isDone = (ctx.n ? ctx.n(arguments) : true);\n        }\n        var result = {\n            done: isDone\n        };\n        if (!isDone) {\n            objDefine(result, \"value\", { g: _value });\n        }\n        return result;\n    }\n    function _return(value) {\n        isDone = true;\n        return {\n            done: true,\n            value: ctx.r && ctx.r(value)\n        };\n    }\n    function _throw(e) {\n        isDone = true;\n        return {\n            done: true,\n            value: ctx.t && ctx.t(e)\n        };\n    }\n    var theIterator = {\n        next: _next\n    };\n    if (ctx.r) {\n        theIterator.return = _return;\n    }\n    if (ctx.t) {\n        theIterator.throw = _throw;\n    }\n    return theIterator;\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction createArrayIterator(values) {\n    var idx = -1;\n    var theValues = values ? values.slice() : [];\n    var len = theValues[LENGTH];\n    function _value() {\n        if (idx >= 0 && idx < len) {\n            return theValues[idx];\n        }\n    }\n    function _getNext() {\n        idx++;\n        return idx >= len;\n    }\n    var ctx = {\n        n: _getNext\n    };\n    objDefine(ctx, \"v\", { g: _value });\n    return createIterator(ctx);\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction createRangeIterator(start, end, step) {\n    var nextValue = start;\n    var theValue = UNDEF_VALUE;\n    if (isNullOrUndefined(end)) {\n        end = start;\n    }\n    var theStep = step;\n    if (!theStep) {\n        theStep = (start <= end) ? 1 : -1;\n    }\n    function _value() {\n        return theValue;\n    }\n    function _getNext() {\n        var isDone = (theStep > 0) ? (nextValue > end) : (nextValue < end);\n        if (!isDone) {\n            theValue = nextValue;\n            nextValue += theStep;\n        }\n        return isDone;\n    }\n    return createIterator(objDefine({\n        n: _getNext\n    }, \"v\", { g: _value }));\n}\n\nvar mathAbs = ( /*#__PURE__*/_pureRef(MathCls, \"abs\"));\n\nvar mathExp = ( /*#__PURE__*/_pureRef(MathCls, \"exp\"));\nvar mathLog = ( /*#__PURE__*/_pureRef(MathCls, \"log\"));\n\nvar mathAsin = ( /*#__PURE__*/_pureRef(MathCls, \"asin\"));\nvar mathAcos = ( /*#__PURE__*/_pureRef(MathCls, \"acos\"));\nvar mathAtan = ( /*#__PURE__*/_pureRef(MathCls, \"atan\"));\nvar mathAtan2 = ( /*#__PURE__*/_pureRef(MathCls, \"atan2\"));\n\nvar mathPow = ( /*#__PURE__*/_pureRef(MathCls, \"pow\"));\nvar mathSqrt = ( /*#__PURE__*/_pureRef(MathCls, \"sqrt\"));\n\nvar mathRound = ( /*#__PURE__*/_pureRef(MathCls, \"round\"));\n\nvar mathSin = ( /*#__PURE__*/_pureRef(MathCls, \"sin\"));\nvar mathCos = ( /*#__PURE__*/_pureRef(MathCls, \"cos\"));\nvar mathTan = ( /*#__PURE__*/_pureRef(MathCls, \"tan\"));\n\nvar _recursionCheckOwnDescriptors;\nvar _recursionCheckOwnSymbols;\nvar _objGetOwnPropertyNames = ( /* #__PURE__ */_pureAssign(( /* #__PURE__ */_pureRef(ObjClass, GET_OWN_PROPERTY_NAMES)), _returnEmptyArray));\nvar _objGetOwnPropertyDescriptor = ( /* #__PURE__ */_pureAssign(( /* #__PURE__ */_pureRef(ObjClass, GET_OWN_PROPERTY_DESCRIPTOR)), _returnNothing));\nfunction polyObjGetOwnPropertyDescriptors(obj) {\n    var result = {};\n    _throwIfNullOrUndefined(obj);\n    if (!_recursionCheckOwnDescriptors) {\n        try {\n            _recursionCheckOwnDescriptors = true;\n            arrForEach(_objGetOwnPropertyNames(obj), function (propName) {\n                var descriptor = _objGetOwnPropertyDescriptor(obj, propName);\n                if (descriptor !== undefined) {\n                    result[propName] = descriptor;\n                }\n            });\n            arrForEach(_polyObjGetOwnPropertySymbols(obj), function (sym) {\n                var descriptor = _objGetOwnPropertyDescriptor(obj, sym);\n                if (descriptor !== undefined) {\n                    result[sym] = descriptor;\n                }\n            });\n        }\n        finally {\n            _recursionCheckOwnDescriptors = false;\n        }\n    }\n    return result;\n}\nfunction _polyObjGetOwnPropertySymbols(obj) {\n    var result = [];\n    var objHasOwn = ObjClass.hasOwn || polyObjHasOwn;\n    if (!_recursionCheckOwnSymbols) {\n        try {\n            _recursionCheckOwnSymbols = true;\n            var symEnum = 0 ;\n            while (symEnum <= 12 ) {\n                var sym = getKnownSymbol(symEnum);\n                if (sym && objHasOwn(obj, sym)) {\n                    result.push(sym);\n                }\n                symEnum++;\n            }\n        }\n        finally {\n            _recursionCheckOwnSymbols = false;\n        }\n    }\n    return result;\n}\n\nvar objGetOwnPropertyDescriptor = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, GET_OWN_PROPERTY_DESCRIPTOR)), _returnNothing));\nvar objGetOwnPropertyDescriptors = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, \"getOwnPropertyDescriptors\")), polyObjGetOwnPropertyDescriptors));\nvar objGetOwnPropertyNames = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, GET_OWN_PROPERTY_NAMES)), _returnEmptyArray));\nvar objGetOwnPropertySymbols = ( /* #__PURE__*/_pureAssign(( /* #__PURE__ */_pureRef(ObjClass, GET_OWN_PROPERTY_SYMBOLS)), _returnEmptyArray));\n\nfunction polyObjFromEntries(entries) {\n    var result = {};\n    function addEntry(entry) {\n        if (isArray(entry) && entry.length >= 2) {\n            result[entry[0]] = entry[1];\n        }\n    }\n    if (isArray(entries)) {\n        arrForEach(entries, addEntry);\n    }\n    else if (isIterable(entries)) {\n        iterForOf(entries, addEntry);\n    }\n    return result;\n}\n\nvar objFromEntries = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, \"fromEntries\")), polyObjFromEntries));\n\nvar objPreventExtensions = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, \"preventExtensions\")), _doNothing));\nvar objIsExtensible = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, \"isExtensible\")), _returnFalse));\n\nvar strEndsWith = ( /*#__PURE__*/_unwrapFunctionWithPoly(\"endsWith\", StrProto, polyStrEndsWith));\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyStrEndsWith(value, searchString, length) {\n    _throwIfNotString(value);\n    var searchValue = isString(searchString) ? searchString : asString(searchString);\n    var end = (!isUndefined(length) && length < value[LENGTH]) ? length : value[LENGTH];\n    return strSubstring(value, end - searchValue[LENGTH], end) === searchValue;\n}\n\nvar strIndexOf = ( /*#__PURE__*/_unwrapFunction(\"indexOf\", StrProto));\nvar strLastIndexOf = ( /*#__PURE__*/_unwrapFunction(\"lastIndexOf\", StrProto));\n\nvar strIncludes = ( /*#__PURE__*/_unwrapFunctionWithPoly(\"includes\", StrProto, polyStrIncludes));\nvar strContains = ( /*#__PURE__*/_pureAssign(strIncludes));\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyStrIncludes(value, searchString, position) {\n    if (isRegExp(searchString)) {\n        throwTypeError(\"'searchString' must not be a regular expression\" + dumpObj(searchString));\n    }\n    return strIndexOf(value, asString(searchString), position) !== -1;\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction strIsNullOrWhiteSpace(value) {\n    if (isString(value)) {\n        return value.replace(/[\\s\\t\\r\\n\\f]+/g, EMPTY) === EMPTY;\n    }\n    return isNullOrUndefined(value);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction strIsNullOrEmpty(value) {\n    if (isString(value)) {\n        return value === EMPTY;\n    }\n    return isNullOrUndefined(value);\n}\n\nvar strStartsWith = ( /*#__PURE__*/_unwrapFunctionWithPoly(\"startsWith\", StrProto, polyStrStartsWith));\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyStrStartsWith(value, searchString, position) {\n    _throwIfNotString(value);\n    var searchValue = isString(searchString) ? searchString : asString(searchString);\n    var pos = position > 0 ? position : 0;\n    return strSubstring(value, pos, pos + searchValue[LENGTH]) === searchValue;\n}\n\nvar REF = \"ref\";\nvar UNREF = \"unref\";\nvar HAS_REF = \"hasRef\";\nvar ENABLED = \"enabled\";\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createTimerHandler(startTimer, refreshFn, cancelFn) {\n    var ref = true;\n    var timerId = startTimer ? refreshFn(NULL_VALUE) : NULL_VALUE;\n    var theTimerHandler;\n    function _unref() {\n        ref = false;\n        timerId && timerId[UNREF] && timerId[UNREF]();\n        return theTimerHandler;\n    }\n    function _cancel() {\n        timerId && cancelFn(timerId);\n        timerId = NULL_VALUE;\n    }\n    function _refresh() {\n        timerId = refreshFn(timerId);\n        if (!ref) {\n            _unref();\n        }\n        return theTimerHandler;\n    }\n    function _setEnabled(value) {\n        !value && timerId && _cancel();\n        value && !timerId && _refresh();\n    }\n    theTimerHandler = {\n        cancel: _cancel,\n        refresh: _refresh\n    };\n    theTimerHandler[HAS_REF] = function () {\n        if (timerId && timerId[HAS_REF]) {\n            return timerId[HAS_REF]();\n        }\n        return ref;\n    };\n    theTimerHandler[REF] = function () {\n        ref = true;\n        timerId && timerId[REF] && timerId[REF]();\n        return theTimerHandler;\n    };\n    theTimerHandler[UNREF] = _unref;\n    theTimerHandler = objDefineProp(theTimerHandler, ENABLED, {\n        get: function () { return !!timerId; },\n        set: _setEnabled\n    });\n    return {\n        h: theTimerHandler,\n        dn: function () {\n            timerId = NULL_VALUE;\n        }\n    };\n}\n\nvar _setTimeoutFn;\nvar _clearTimeoutFn;\nfunction _resolveTimeoutFn(timeoutFn) {\n    var result = isFunction(timeoutFn) ? timeoutFn : _setTimeoutFn;\n    if (!result) {\n        var globalOverrides = _getGlobalConfig().tmOut || [];\n        if (isArray(globalOverrides) && globalOverrides.length > 0 && isFunction(globalOverrides[0])) {\n            result = globalOverrides[0];\n        }\n    }\n    return result || setTimeout;\n}\nfunction _resolveClearTimeoutFn(timeoutFn) {\n    var result = isFunction(timeoutFn) ? timeoutFn : _clearTimeoutFn;\n    if (!result) {\n        var globalOverrides = _getGlobalConfig().tmOut || [];\n        if (isArray(globalOverrides) && globalOverrides.length > 1 && isFunction(globalOverrides[1])) {\n            result = globalOverrides[1];\n        }\n    }\n    return result || clearTimeout;\n}\nfunction _createTimeoutWith(startTimer, overrideFn, theArgs) {\n    var isArr = isArray(overrideFn);\n    var len = isArr ? overrideFn.length : 0;\n    var setFn = _resolveTimeoutFn(len > 0 ? overrideFn[0] : (!isArr ? overrideFn : UNDEF_VALUE));\n    var clearFn = _resolveClearTimeoutFn(len > 1 ? overrideFn[1] : UNDEF_VALUE);\n    var timerFn = theArgs[0];\n    theArgs[0] = function () {\n        handler.dn();\n        fnApply(timerFn, UNDEF_VALUE, ArrSlice[CALL](arguments));\n    };\n    var handler = _createTimerHandler(startTimer, function (timerId) {\n        if (timerId) {\n            if (timerId.refresh) {\n                timerId.refresh();\n                return timerId;\n            }\n            fnApply(clearFn, UNDEF_VALUE, [timerId]);\n        }\n        return fnApply(setFn, UNDEF_VALUE, theArgs);\n    }, function (timerId) {\n        fnApply(clearFn, UNDEF_VALUE, [timerId]);\n    });\n    return handler.h;\n}\nfunction setTimeoutOverrides(overrideFn) {\n    var isArr = isArray(overrideFn);\n    var len = isArr ? overrideFn.length : 0;\n    _setTimeoutFn = (len > 0 ? overrideFn[0] : (!isArr ? overrideFn : UNDEF_VALUE));\n    _clearTimeoutFn = (len > 1 ? overrideFn[1] : UNDEF_VALUE);\n}\nfunction setGlobalTimeoutOverrides(overrideFn) {\n    var isArr = isArray(overrideFn);\n    var len = isArr ? overrideFn.length : 0;\n    var globalCfg = _getGlobalConfig();\n    if (!overrideFn) {\n        globalCfg.tmOut = undefined;\n    }\n    else {\n        globalCfg.tmOut = [\n            (len > 0 ? overrideFn[0] : (!isArr ? overrideFn : null)),\n            (len > 1 ? overrideFn[1] : null)\n        ];\n    }\n}\nfunction scheduleTimeout(callback, timeout) {\n    return _createTimeoutWith(true, UNDEF_VALUE, ArrSlice[CALL](arguments));\n}\nfunction scheduleTimeoutWith(overrideFn, callback, timeout) {\n    return _createTimeoutWith(true, overrideFn, ArrSlice[CALL](arguments, 1));\n}\nfunction createTimeout(callback, timeout) {\n    return _createTimeoutWith(false, UNDEF_VALUE, ArrSlice[CALL](arguments));\n}\nfunction createTimeoutWith(overrideFn, callback, timeout) {\n    return _createTimeoutWith(false, overrideFn, ArrSlice[CALL](arguments, 1));\n}\n\nvar _defaultIdleTimeout = 100;\nvar _maxExecutionTime = 50;\n/*#__NO_SIDE_EFFECTS__*/\nfunction hasIdleCallback() {\n    return !!( /*#__PURE__*/getIdleCallback());\n}\nvar getIdleCallback = ( /*#__PURE__*/_getGlobalInstFn(getInst, [\"requestIdleCallback\"]));\nvar getCancelIdleCallback = ( /*#__PURE__*/_getGlobalInstFn(getInst, [\"cancelIdleCallback\"]));\nfunction setDefaultIdleTimeout(timeout) {\n    _defaultIdleTimeout = timeout;\n}\nfunction setDefaultMaxExecutionTime(maxTime) {\n    _maxExecutionTime = maxTime;\n}\nfunction scheduleIdleCallback(callback, options) {\n    function _createDeadline(timedOut) {\n        var startTime = perfNow();\n        return {\n            didTimeout: timedOut,\n            timeRemaining: function () {\n                return _maxExecutionTime - elapsedTime(startTime);\n            }\n        };\n    }\n    if (hasIdleCallback()) {\n        var handler_1 = _createTimerHandler(true, function (idleId) {\n            idleId && getCancelIdleCallback()(idleId);\n            return getIdleCallback()(function (deadline) {\n                handler_1.dn();\n                callback(deadline || _createDeadline(false));\n            }, options);\n        }, function (idleId) {\n            getCancelIdleCallback()(idleId);\n        });\n        return handler_1.h;\n    }\n    var timeout = (options || {}).timeout;\n    if (isUndefined(timeout)) {\n        timeout = _defaultIdleTimeout;\n    }\n    return scheduleTimeout(function () {\n        callback(_createDeadline(true));\n    }, timeout);\n}\n\nfunction scheduleInterval(callback, timeout) {\n    var theArguments = ArrSlice[CALL](arguments);\n    var handler = _createTimerHandler(true, function (intervalId) {\n        intervalId && clearInterval(intervalId);\n        return fnApply(setInterval, UNDEF_VALUE, theArguments);\n    }, function (intervalId) {\n        fnApply(clearInterval, UNDEF_VALUE, [intervalId]);\n    });\n    return handler.h;\n}\n\n\n//# sourceMappingURL=ts-utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5ldndhcmUyMS90cy11dGlscy9kaXN0L2VzNS9tb2QvdHMtdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGlDQUFpQztBQUM5RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLElBQUk7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxXQUFXO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxnQkFBZ0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFdBQVc7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUJBQXFCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxLQUFLO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx5Q0FBeUM7QUFDL0Usc0NBQXNDLG1CQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLEtBQUssU0FBUyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxlQUFlO0FBQzFEO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtEQUFrRDtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDBDQUEwQyxVQUFVO0FBQ25HLENBQUM7QUFDRDtBQUNBLCtDQUErQyxtREFBbUQ7QUFDbEcsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakUsNEZBQTRGLDBCQUEwQjtBQUN0SDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw0QkFBNEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBEQUEwRCxJQUFJO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsTUFBTTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGtFQUFrRSx5Q0FBeUMsSUFBSTtBQUMvRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3Q0FBd0M7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSxrQ0FBa0MsRUFBRTtBQUNwQztBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxFQUFFO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELEVBQUU7QUFDakUsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFdBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxTQUFTLFdBQVc7QUFDekI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtQkFBbUI7QUFDOUM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRXNrSDtBQUN0a0giLCJzb3VyY2VzIjpbIkM6XFxzbWFydC1haS1hdmF0YXItYWdlbnRcXG5vZGVfbW9kdWxlc1xcQG5ldndhcmUyMVxcdHMtdXRpbHNcXGRpc3RcXGVzNVxcbW9kXFx0cy11dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgaHR0cHM6Ly9naXRodWIuY29tL25ldndhcmUyMS90cy11dGlscyB2MC4xMi41ICovXG4vKlxuICogQ29weXJpZ2h0IChjKSBOZXZXYXJlMjEgU29sdXRpb25zIExMQyBhbmQgY29udHJpYnV0b3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIF9wdXJlQXNzaWduKGZ1bmMxLCBmdW5jMikge1xuICAgIHJldHVybiBmdW5jMSB8fCBmdW5jMjtcbn1cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gX3B1cmVSZWYodmFsdWUsIG5hbWUpIHtcbiAgICByZXR1cm4gdmFsdWVbbmFtZV07XG59XG5cbnZhciBVTkRFRl9WQUxVRSA9IHVuZGVmaW5lZDtcbnZhciBOVUxMX1ZBTFVFID0gbnVsbDtcbnZhciBFTVBUWSA9IFwiXCI7XG52YXIgRlVOQ1RJT04gPSBcImZ1bmN0aW9uXCI7XG52YXIgT0JKRUNUID0gXCJvYmplY3RcIjtcbnZhciBQUk9UT1RZUEUgPSBcInByb3RvdHlwZVwiO1xudmFyIF9fUFJPVE9fXyA9IFwiX19wcm90b19fXCI7XG52YXIgVU5ERUZJTkVEID0gXCJ1bmRlZmluZWRcIjtcbnZhciBDT05TVFJVQ1RPUiA9IFwiY29uc3RydWN0b3JcIjtcbnZhciBTWU1CT0wgPSBcIlN5bWJvbFwiO1xudmFyIExFTkdUSCA9IFwibGVuZ3RoXCI7XG52YXIgTkFNRSA9IFwibmFtZVwiO1xudmFyIENBTEwgPSBcImNhbGxcIjtcbnZhciBUT19TVFJJTkcgPSBcInRvU3RyaW5nXCI7XG52YXIgR0VUX09XTl9QUk9QRVJUWV9ERVNDUklQVE9SID0gXCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JcIjtcbnZhciBHRVRfT1dOX1BST1BFUlRZX05BTUVTID0gXCJnZXRPd25Qcm9wZXJ0eU5hbWVzXCI7XG52YXIgR0VUX09XTl9QUk9QRVJUWV9TWU1CT0xTID0gXCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcIjtcbnZhciBPYmpDbGFzcyA9ICggLyojX19QVVJFX18qL19wdXJlQXNzaWduKE9iamVjdCkpO1xudmFyIE9ialByb3RvID0gKCAvKiNfX1BVUkVfXyovX3B1cmVSZWYoT2JqQ2xhc3MsIFBST1RPVFlQRSkpO1xudmFyIFN0ckNscyA9ICggLyojX19QVVJFX18qL19wdXJlQXNzaWduKFN0cmluZykpO1xudmFyIFN0clByb3RvID0gKCAvKiNfX1BVUkVfXyovX3B1cmVSZWYoU3RyQ2xzLCBQUk9UT1RZUEUpKTtcbnZhciBNYXRoQ2xzID0gKCAvKiNfX1BVUkVfXyovX3B1cmVBc3NpZ24oTWF0aCkpO1xudmFyIEFyckNscyA9ICggLyojX19QVVJFX18qL19wdXJlQXNzaWduKEFycmF5KSk7XG52YXIgQXJyUHJvdG8gPSAoIC8qI19fUFVSRV9fKi9fcHVyZVJlZihBcnJDbHMsIFBST1RPVFlQRSkpO1xudmFyIEFyclNsaWNlID0gKCAvKiNfX1BVUkVfXyovX3B1cmVSZWYoQXJyUHJvdG8sIFwic2xpY2VcIikpO1xudmFyIE51bWJlckNscyA9ICggLyojX19QVVJFX18qL19wdXJlQXNzaWduKE51bWJlcikpO1xuXG52YXIgUE9MWUZJTExfVEFHID0gXCJfcG9seWZpbGxcIjtcbnZhciBQT0xZRklMTF9UWVBFX05BTUUgPSBcIl9fbncyMSRwb2x5dHlwZV9fXCI7XG5mdW5jdGlvbiBfaXNQb2x5ZmlsbChvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9ialtQT0xZRklMTF9UQUddKTtcbn1cbmZ1bmN0aW9uIF9pc1BvbHlmaWxsVHlwZShvYmosIHBvbHlmaWxsVHlwZU5hbWUpIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9ialtQT0xZRklMTF9UWVBFX05BTUVdID09PSBwb2x5ZmlsbFR5cGVOYW1lKTtcbn1cblxuZnVuY3Rpb24gc2FmZShmdW5jLCBhcmdBcnJheSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2OiBmdW5jLmFwcGx5KHRoaXMsIGFyZ0FycmF5KVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4geyBlOiBlIH07XG4gICAgfVxufVxuXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIHNhZmVHZXQoY2IsIGRlZlZhbHVlLCBhcmdBcnJheSkge1xuICAgIHZhciByZXN1bHQgPSBzYWZlKGNiLCBhcmdBcnJheSk7XG4gICAgcmV0dXJuIHJlc3VsdC5lID8gZGVmVmFsdWUgOiByZXN1bHQudjtcbn1cblxudmFyIF9wcmltaXRpdmVUeXBlcztcbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gX2NyZWF0ZUlzKHRoZVR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IHRoZVR5cGU7XG4gICAgfTtcbn1cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gX2NyZWF0ZUlzV2l0aFBvbHkodGhlVHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gdGhlVHlwZSB8fCBfaXNQb2x5ZmlsbFR5cGUodmFsdWUsIHRoZVR5cGUpO1xuICAgIH07XG59XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIF9jcmVhdGVPYmpJcyh0aGVOYW1lKSB7XG4gICAgdmFyIHRoZVR5cGUgPSBcIltvYmplY3QgXCIgKyB0aGVOYW1lICsgXCJdXCI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgb2JqVG9TdHJpbmcodmFsdWUpID09PSB0aGVUeXBlKTtcbiAgICB9O1xufVxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBvYmpUb1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiBPYmpQcm90b1tUT19TVFJJTkddLmNhbGwodmFsdWUpO1xufVxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBpc1R5cGVvZih2YWx1ZSwgdGhlVHlwZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IHRoZVR5cGU7XG59XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gVU5ERUZJTkVEIHx8IHZhbHVlID09PSBVTkRFRklORUQ7XG59XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIGlzU3RyaWN0VW5kZWZpbmVkKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IFVOREVGX1ZBTFVFO1xufVxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gTlVMTF9WQUxVRSB8fCBpc1VuZGVmaW5lZCh2YWx1ZSk7XG59XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIGlzU3RyaWN0TnVsbE9yVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBOVUxMX1ZBTFVFIHx8IHZhbHVlID09PSBVTkRFRl9WQUxVRTtcbn1cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gaXNEZWZpbmVkKGFyZykge1xuICAgIHJldHVybiAhIWFyZyB8fCBhcmcgIT09IFVOREVGX1ZBTFVFO1xufVxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gTlVMTF9WQUxVRSB8fCBpc1ByaW1pdGl2ZVR5cGUodHlwZW9mIHZhbHVlKTtcbn1cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gaXNQcmltaXRpdmVUeXBlKHRoZVR5cGUpIHtcbiAgICAhX3ByaW1pdGl2ZVR5cGVzICYmIChfcHJpbWl0aXZlVHlwZXMgPSBbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJib29sZWFuXCIsIFVOREVGSU5FRCwgXCJzeW1ib2xcIiwgXCJiaWdpbnRcIl0pO1xuICAgIHJldHVybiAhISh0aGVUeXBlICE9PSBPQkpFQ1QgJiYgX3ByaW1pdGl2ZVR5cGVzLmluZGV4T2YodGhlVHlwZSkgIT09IC0xKTtcbn1cbnZhciBpc1N0cmluZyA9ICggLyojX19QVVJFX18qL19jcmVhdGVJcyhcInN0cmluZ1wiKSk7XG52YXIgaXNGdW5jdGlvbiA9ICggLyojX19QVVJFX18qL19jcmVhdGVJcyhGVU5DVElPTikpO1xudmFyIGlzQXN5bmNGdW5jdGlvbiA9ICggLyojX19QVVJFX18qL19jcmVhdGVPYmpJcyhcIkFzeW5jRnVuY3Rpb25cIikpO1xudmFyIGlzR2VuZXJhdG9yID0gKCAvKiNfX1BVUkVfXyovX2NyZWF0ZU9iaklzKFwiR2VuZXJhdG9yRnVuY3Rpb25cIikpO1xudmFyIGlzQXN5bmNHZW5lcmF0b3IgPSAoIC8qI19fUFVSRV9fKi9fY3JlYXRlT2JqSXMoXCJBc3luY0dlbmVyYXRvckZ1bmN0aW9uXCIpKTtcbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlICYmIGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gT0JKRUNUO1xufVxudmFyIGlzQXJyYXkgPSAoIC8qICNfX1BVUkVfXyovX3B1cmVSZWYoQXJyQ2xzLCBcImlzQXJyYXlcIikpO1xudmFyIGlzRGF0ZSA9ICggLyojX19QVVJFX18qL19jcmVhdGVPYmpJcyhcIkRhdGVcIikpO1xudmFyIGlzTnVtYmVyID0gKCAvKiNfX1BVUkVfXyovX2NyZWF0ZUlzKFwibnVtYmVyXCIpKTtcbnZhciBpc0Jvb2xlYW4gPSAoIC8qI19fUFVSRV9fKi9fY3JlYXRlSXMoXCJib29sZWFuXCIpKTtcbnZhciBpc1JlZ0V4cCA9ICggLyojX19QVVJFX18qL19jcmVhdGVPYmpJcyhcIlJlZ0V4cFwiKSk7XG52YXIgaXNGaWxlID0gKCAvKiNfX1BVUkVfXyovX2NyZWF0ZU9iaklzKFwiRmlsZVwiKSk7XG52YXIgaXNGb3JtRGF0YSA9ICggLyojX19QVVJFX18qL19jcmVhdGVPYmpJcyhcIkZvcm1EYXRhXCIpKTtcbnZhciBpc0Jsb2IgPSAoIC8qI19fUFVSRV9fKi9fY3JlYXRlT2JqSXMoXCJCbG9iXCIpKTtcbnZhciBpc0FycmF5QnVmZmVyID0gKCAvKiNfX1BVUkVfXyovX2NyZWF0ZU9iaklzKFwiQXJyYXlCdWZmZXJcIikpO1xudmFyIGlzRXJyb3IgPSAoIC8qI19fUFVSRV9fKi9fY3JlYXRlT2JqSXMoXCJFcnJvclwiKSk7XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIGlzUHJvbWlzZUxpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUudGhlbiAmJiBpc0Z1bmN0aW9uKHZhbHVlLnRoZW4pKTtcbn1cbnZhciBpc1RoZW5hYmxlID0gaXNQcm9taXNlTGlrZTtcbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gaXNQcm9taXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLnRoZW4gJiYgdmFsdWUuY2F0Y2ggJiYgaXNGdW5jdGlvbih2YWx1ZS50aGVuKSAmJiBpc0Z1bmN0aW9uKHZhbHVlLmNhdGNoKSk7XG59XG52YXIgaXNNYXAgPSAoIC8qI19fUFVSRV9fKi9fY3JlYXRlT2JqSXMoXCJNYXBcIikpO1xudmFyIGlzV2Vha01hcCA9ICggLyojX19QVVJFX18qL19jcmVhdGVPYmpJcyhcIldlYWtNYXBcIikpO1xudmFyIGlzU2V0ID0gKCAvKiNfX1BVUkVfXyovX2NyZWF0ZU9iaklzKFwiU2V0XCIpKTtcbnZhciBpc1dlYWtTZXQgPSAoIC8qI19fUFVSRV9fKi9fY3JlYXRlT2JqSXMoXCJXZWFrU2V0XCIpKTtcbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gaXNNYXBMaWtlKHZhbHVlKSB7XG4gICAgcmV0dXJuICEhKHZhbHVlICYmXG4gICAgICAgIGlzRnVuY3Rpb24odmFsdWUuZ2V0KSAmJlxuICAgICAgICBpc0Z1bmN0aW9uKHZhbHVlLnNldCkgJiZcbiAgICAgICAgaXNGdW5jdGlvbih2YWx1ZS5oYXMpICYmXG4gICAgICAgIGlzRnVuY3Rpb24odmFsdWUuZGVsZXRlKSAmJlxuICAgICAgICBpc051bWJlcih2YWx1ZS5zaXplKSk7XG59XG5mdW5jdGlvbiBpc1NldExpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gISEodmFsdWUgJiZcbiAgICAgICAgaXNGdW5jdGlvbih2YWx1ZS5hZGQpICYmXG4gICAgICAgIGlzRnVuY3Rpb24odmFsdWUuaGFzKSAmJlxuICAgICAgICBpc0Z1bmN0aW9uKHZhbHVlLmRlbGV0ZSkgJiZcbiAgICAgICAgaXNOdW1iZXIodmFsdWUuc2l6ZSkpO1xufVxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBpc05vdFRydXRoeSh2YWx1ZSkge1xuICAgIHJldHVybiAhdmFsdWUgfHwgIWlzVHJ1dGh5KHZhbHVlKTtcbn1cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gaXNUcnV0aHkodmFsdWUpIHtcbiAgICByZXR1cm4gISghdmFsdWUgfHwgc2FmZUdldChmdW5jdGlvbiAoKSB7IHJldHVybiAhKHZhbHVlICYmICgwICsgdmFsdWUpKTsgfSwgIXZhbHVlKSk7XG59XG52YXIgaXNCaWdJbnQgPSAoIC8qI19fUFVSRV9fKi9fY3JlYXRlSXNXaXRoUG9seShcImJpZ2ludFwiKSk7XG5cbmZ1bmN0aW9uIF9yZXR1cm5Ob3RoaW5nKCkge1xuICAgIHJldHVybjtcbn1cbmZ1bmN0aW9uIF9yZXR1cm5FbXB0eUFycmF5KCkge1xuICAgIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIF9yZXR1cm5GYWxzZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBhc1N0cmluZyA9ICggLyojX19QVVJFX18qL19wdXJlQXNzaWduKFN0ckNscykpO1xuXG52YXIgRVJST1JfVFlQRSA9IFwiW29iamVjdCBFcnJvcl1cIjtcbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gZHVtcE9iaihvYmplY3QsIGZvcm1hdCkge1xuICAgIHZhciBwcm9wZXJ0eVZhbHVlRHVtcCA9IEVNUFRZO1xuICAgIHZhciBvYmpUeXBlID0gT2JqUHJvdG9bVE9fU1RSSU5HXVtDQUxMXShvYmplY3QpO1xuICAgIGlmIChvYmpUeXBlID09PSBFUlJPUl9UWVBFKSB7XG4gICAgICAgIG9iamVjdCA9IHsgc3RhY2s6IGFzU3RyaW5nKG9iamVjdC5zdGFjayksIG1lc3NhZ2U6IGFzU3RyaW5nKG9iamVjdC5tZXNzYWdlKSwgbmFtZTogYXNTdHJpbmcob2JqZWN0Lm5hbWUpIH07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHByb3BlcnR5VmFsdWVEdW1wID0gSlNPTi5zdHJpbmdpZnkob2JqZWN0LCBOVUxMX1ZBTFVFLCBmb3JtYXQgPyAoKHR5cGVvZiBmb3JtYXQgPT09IFwibnVtYmVyXCIpID8gZm9ybWF0IDogNCkgOiBVTkRFRl9WQUxVRSk7XG4gICAgICAgIHByb3BlcnR5VmFsdWVEdW1wID0gKHByb3BlcnR5VmFsdWVEdW1wID8gcHJvcGVydHlWYWx1ZUR1bXAucmVwbGFjZSgvXCIoXFx3KylcIlxccyo6XFxzezAsMX0vZywgXCIkMTogXCIpIDogTlVMTF9WQUxVRSkgfHwgYXNTdHJpbmcob2JqZWN0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcHJvcGVydHlWYWx1ZUR1bXAgPSBcIiAtIFwiICsgZHVtcE9iaihlLCBmb3JtYXQpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqVHlwZSArIFwiOiBcIiArIHByb3BlcnR5VmFsdWVEdW1wO1xufVxuXG5mdW5jdGlvbiB0aHJvd0Vycm9yKG1lc3NhZ2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5mdW5jdGlvbiB0aHJvd1R5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihtZXNzYWdlKTtcbn1cbmZ1bmN0aW9uIHRocm93UmFuZ2VFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IobWVzc2FnZSk7XG59XG5cbmZ1bmN0aW9uIF90aHJvd0lmTnVsbE9yVW5kZWZpbmVkKG9iaikge1xuICAgIGlmIChpc1N0cmljdE51bGxPclVuZGVmaW5lZChvYmopKSB7XG4gICAgICAgIHRocm93VHlwZUVycm9yKFwiQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0XCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF90aHJvd0lmTm90U3RyaW5nKHZhbHVlKSB7XG4gICAgaWYgKCFpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3dUeXBlRXJyb3IoXCInXCIgKyBkdW1wT2JqKHZhbHVlKSArIFwiJyBpcyBub3QgYSBzdHJpbmdcIik7XG4gICAgfVxufVxuXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIG9iakhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICAgIHJldHVybiAhIW9iaiAmJiBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eVtDQUxMXShvYmosIHByb3ApO1xufVxuXG52YXIgX29iakdldE93blByb3BlcnR5RGVzY3JpcHRvciQyID0gKCAvKiNfX1BVUkVfXyovX3B1cmVBc3NpZ24oKCAvKiNfX1BVUkVfXyovX3B1cmVSZWYoT2JqQ2xhc3MsIEdFVF9PV05fUFJPUEVSVFlfREVTQ1JJUFRPUikpLCBfcmV0dXJuTm90aGluZykpO1xudmFyIG9iakhhc093biA9ICggLyojX19QVVJFX18qL19wdXJlQXNzaWduKCggLyojX19QVVJFX18qL19wdXJlUmVmKE9iakNsYXNzLCBcImhhc093blwiKSksIHBvbHlPYmpIYXNPd24pKTtcbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gcG9seU9iakhhc093bihvYmosIHByb3ApIHtcbiAgICBfdGhyb3dJZk51bGxPclVuZGVmaW5lZChvYmopO1xuICAgIHJldHVybiBvYmpIYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHx8ICEhX29iakdldE93blByb3BlcnR5RGVzY3JpcHRvciQyKG9iaiwgcHJvcCk7XG59XG5cbmZ1bmN0aW9uIG9iakZvckVhY2hLZXkodGhlT2JqZWN0LCBjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgaWYgKHRoZU9iamVjdCAmJiAoaXNPYmplY3QodGhlT2JqZWN0KSB8fCBpc0Z1bmN0aW9uKHRoZU9iamVjdCkpKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gdGhlT2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqSGFzT3duKHRoZU9iamVjdCwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tmbltDQUxMXSh0aGlzQXJnIHx8IHRoZU9iamVjdCwgcHJvcCwgdGhlT2JqZWN0W3Byb3BdKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhcnJGb3JFYWNoKHRoZUFycmF5LCBjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgaWYgKHRoZUFycmF5KSB7XG4gICAgICAgIHZhciBsZW4gPSB0aGVBcnJheVtMRU5HVEhdID4+PiAwO1xuICAgICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsZW47IGlkeCsrKSB7XG4gICAgICAgICAgICBpZiAoaWR4IGluIHRoZUFycmF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrZm5bQ0FMTF0odGhpc0FyZyB8fCB0aGVBcnJheSwgdGhlQXJyYXlbaWR4XSwgaWR4LCB0aGVBcnJheSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIF91bndyYXBGdW5jdGlvbiA9ICggX3Vud3JhcEZ1bmN0aW9uV2l0aFBvbHkpO1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBfdW53cmFwRnVuY3Rpb25XaXRoUG9seShmdW5jTmFtZSwgY2xzUHJvdG8sIHBvbHlGdW5jKSB7XG4gICAgdmFyIGNsc0ZuID0gY2xzUHJvdG8gPyBjbHNQcm90b1tmdW5jTmFtZV0gOiBOVUxMX1ZBTFVFO1xuICAgIHJldHVybiBmdW5jdGlvbiAodGhpc0FyZykge1xuICAgICAgICB2YXIgdGhlRnVuYyA9ICh0aGlzQXJnID8gdGhpc0FyZ1tmdW5jTmFtZV0gOiBOVUxMX1ZBTFVFKSB8fCBjbHNGbjtcbiAgICAgICAgaWYgKHRoZUZ1bmMgfHwgcG9seUZ1bmMpIHtcbiAgICAgICAgICAgIHZhciB0aGVBcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgcmV0dXJuICh0aGVGdW5jIHx8IHBvbHlGdW5jKS5hcHBseSh0aGlzQXJnLCB0aGVGdW5jID8gQXJyU2xpY2VbQ0FMTF0odGhlQXJncywgMSkgOiB0aGVBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvd1R5cGVFcnJvcihcIlxcXCJcIiArIGFzU3RyaW5nKGZ1bmNOYW1lKSArIFwiXFxcIiBub3QgZGVmaW5lZCBmb3IgXCIgKyBkdW1wT2JqKHRoaXNBcmcpKTtcbiAgICB9O1xufVxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBfdW53cmFwUHJvcChwcm9wTmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGhpc0FyZykge1xuICAgICAgICByZXR1cm4gdGhpc0FyZ1twcm9wTmFtZV07XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gX29ialByb3BlcnR5SXNFbnVtKG9iaiwgcHJvcEtleSkge1xuICAgIHZhciBkZXNjO1xuICAgIHZhciBmbiA9IE9iakNsYXNzLmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICBpZiAoIWlzU3RyaWN0TnVsbE9yVW5kZWZpbmVkKG9iaikgJiYgZm4pIHtcbiAgICAgICAgZGVzYyA9IHNhZmUoZm4sIFtvYmosIHByb3BLZXldKS52IHx8IE5VTExfVkFMVUU7XG4gICAgfVxuICAgIGlmICghZGVzYykge1xuICAgICAgICBkZXNjID0gc2FmZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gcHJvcEtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBlbnVtZXJhYmxlOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KS52O1xuICAgIH1cbiAgICByZXR1cm4gKGRlc2MgJiYgZGVzYy5lbnVtZXJhYmxlKSB8fCBmYWxzZTtcbn1cbnZhciBvYmpQcm9wZXJ0eUlzRW51bWVyYWJsZSA9ICggLyojX19QVVJFX18qL191bndyYXBGdW5jdGlvbldpdGhQb2x5KFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgTlVMTF9WQUxVRSwgX29ialByb3BlcnR5SXNFbnVtKSk7XG5cbnZhciBfb2JqR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgPSAoIC8qI19fUFVSRV9fKi9fcHVyZUFzc2lnbigoIC8qI19fUFVSRV9fKi9fcHVyZVJlZihPYmpDbGFzcywgR0VUX09XTl9QUk9QRVJUWV9ERVNDUklQVE9SKSksIF9yZXR1cm5Ob3RoaW5nKSk7XG52YXIgX29iakdldE93blByb3BlcnR5U3ltYm9scyA9ICggLyojX19QVVJFX18qL19wdXJlQXNzaWduKCggLyojX19QVVJFX18qL19wdXJlUmVmKE9iakNsYXNzLCBHRVRfT1dOX1BST1BFUlRZX1NZTUJPTFMpKSwgX3JldHVybkVtcHR5QXJyYXkpKTtcbnZhciBwcm9wTWFwID0ge1xuICAgIGU6IFwiZW51bWVyYWJsZVwiLFxuICAgIGM6IFwiY29uZmlndXJhYmxlXCIsXG4gICAgdjogXCJ2YWx1ZVwiLFxuICAgIHc6IFwid3JpdGFibGVcIixcbiAgICBnOiBcImdldFwiLFxuICAgIHM6IFwic2V0XCJcbn07XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIF9jcmVhdGVQcm9wKHZhbHVlKSB7XG4gICAgdmFyIHByb3AgPSB7fTtcbiAgICBwcm9wW3Byb3BNYXBbXCJjXCJdXSA9IHRydWU7XG4gICAgcHJvcFtwcm9wTWFwW1wiZVwiXV0gPSB0cnVlO1xuICAgIGlmICh2YWx1ZS5sKSB7XG4gICAgICAgIHByb3AuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWUubC52OyB9O1xuICAgICAgICB2YXIgZGVzYyA9IF9vYmpHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSh2YWx1ZS5sLCBcInZcIik7XG4gICAgICAgIGlmIChkZXNjICYmIGRlc2Muc2V0KSB7XG4gICAgICAgICAgICBwcm9wLnNldCA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlLmwudiA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvYmpGb3JFYWNoS2V5KHZhbHVlLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBwcm9wW3Byb3BNYXBba2V5XV0gPSBpc1N0cmljdFVuZGVmaW5lZCh2YWx1ZSkgPyBwcm9wW3Byb3BNYXBba2V5XV0gOiB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvcDtcbn1cbnZhciBvYmpEZWZpbmVQcm9wID0gKCAvKiNfX1BVUkVfXyovX3B1cmVSZWYoT2JqQ2xhc3MsIFwiZGVmaW5lUHJvcGVydHlcIikpO1xudmFyIG9iakRlZmluZVByb3BlcnRpZXMgPSAoIC8qI19fUFVSRV9fKi9fcHVyZVJlZihPYmpDbGFzcywgXCJkZWZpbmVQcm9wZXJ0aWVzXCIpKTtcbmZ1bmN0aW9uIG9iakRlZmluZUdldCh0YXJnZXQsIGtleSwgdmFsdWUsIGNvbmZpZ3VyYWJsZSwgZW51bWVyYWJsZSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gb2JqRGVmaW5lUHJvcCh0YXJnZXQsIGtleSwgX2NyZWF0ZVByb3AoKF9hID0ge1xuICAgICAgICAgICAgZTogZW51bWVyYWJsZSxcbiAgICAgICAgICAgIGM6IGNvbmZpZ3VyYWJsZVxuICAgICAgICB9LFxuICAgICAgICBfYVtpc0Z1bmN0aW9uKHZhbHVlKSA/IFwiZ1wiIDogXCJ2XCJdID0gdmFsdWUsXG4gICAgICAgIF9hKSkpO1xufVxuZnVuY3Rpb24gb2JqRGVmaW5lQWNjZXNzb3JzKHRhcmdldCwgcHJvcCwgZ2V0UHJvcCwgc2V0UHJvcCwgY29uZmlndXJhYmxlLCBlbnVtZXJhYmxlKSB7XG4gICAgdmFyIGRlc2MgPSB7XG4gICAgICAgIGU6IGVudW1lcmFibGUsXG4gICAgICAgIGM6IGNvbmZpZ3VyYWJsZVxuICAgIH07XG4gICAgaWYgKGdldFByb3ApIHtcbiAgICAgICAgZGVzYy5nID0gZ2V0UHJvcDtcbiAgICB9XG4gICAgaWYgKHNldFByb3ApIHtcbiAgICAgICAgZGVzYy5zID0gc2V0UHJvcDtcbiAgICB9XG4gICAgcmV0dXJuIG9iakRlZmluZVByb3AodGFyZ2V0LCBwcm9wLCBfY3JlYXRlUHJvcChkZXNjKSk7XG59XG5mdW5jdGlvbiBvYmpEZWZpbmUodGFyZ2V0LCBrZXksIHByb3BEZXNjKSB7XG4gICAgcmV0dXJuIG9iakRlZmluZVByb3AodGFyZ2V0LCBrZXksIF9jcmVhdGVQcm9wKHByb3BEZXNjKSk7XG59XG5mdW5jdGlvbiBvYmpEZWZpbmVQcm9wcyh0YXJnZXQsIHByb3BEZXNjTWFwKSB7XG4gICAgdmFyIHByb3BzID0ge307XG4gICAgb2JqRm9yRWFjaEtleShwcm9wRGVzY01hcCwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgcHJvcHNba2V5XSA9IF9jcmVhdGVQcm9wKHZhbHVlKTtcbiAgICB9KTtcbiAgICBhcnJGb3JFYWNoKF9vYmpHZXRPd25Qcm9wZXJ0eVN5bWJvbHMocHJvcERlc2NNYXApLCBmdW5jdGlvbiAoc3ltKSB7XG4gICAgICAgIGlmIChvYmpQcm9wZXJ0eUlzRW51bWVyYWJsZShwcm9wRGVzY01hcCwgc3ltKSkge1xuICAgICAgICAgICAgcHJvcHNbc3ltXSA9IF9jcmVhdGVQcm9wKHByb3BEZXNjTWFwW3N5bV0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iakRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcyk7XG59XG5cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gX2NyZWF0ZUtleVZhbHVlTWFwKHZhbHVlcywga2V5VHlwZSwgdmFsdWVUeXBlLCBjb21wbGV0ZUZuLCB3cml0YWJsZSkge1xuICAgIHZhciB0aGVNYXAgPSB7fTtcbiAgICBvYmpGb3JFYWNoS2V5KHZhbHVlcywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgX2Fzc2lnbk1hcFZhbHVlKHRoZU1hcCwga2V5LCBrZXlUeXBlID8gdmFsdWUgOiBrZXkpO1xuICAgICAgICBfYXNzaWduTWFwVmFsdWUodGhlTWFwLCB2YWx1ZSwgdmFsdWVUeXBlID8gdmFsdWUgOiBrZXkpO1xuICAgIH0pO1xuICAgIHJldHVybiBjb21wbGV0ZUZuID8gY29tcGxldGVGbih0aGVNYXApIDogdGhlTWFwO1xufVxuZnVuY3Rpb24gX2Fzc2lnbk1hcFZhbHVlKHRoZU1hcCwga2V5LCB2YWx1ZSwgd3JpdGFibGUpIHtcbiAgICBvYmpEZWZpbmVQcm9wKHRoZU1hcCwga2V5LCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIF9vYmpJdGVyYXRlRW50cmllcyhvYmosIG1hcHBlcikge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBvYmpGb3JFYWNoS2V5KG9iaiwgZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1hcHBlcihrZXksIHZhbCkpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIHBvbHlPYmpLZXlzKG9iaikge1xuICAgIF90aHJvd0lmTnVsbE9yVW5kZWZpbmVkKG9iaik7XG4gICAgaWYgKCFpc09iamVjdChvYmopKSB7XG4gICAgICAgIHRocm93VHlwZUVycm9yKFwibm9uLW9iamVjdCBcIiArIGR1bXBPYmoob2JqKSk7XG4gICAgfVxuICAgIHJldHVybiBfb2JqSXRlcmF0ZUVudHJpZXMob2JqLCBmdW5jdGlvbiAoaywgXykgeyByZXR1cm4gazsgfSk7XG59XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIHBvbHlPYmpFbnRyaWVzKHZhbHVlKSB7XG4gICAgcmV0dXJuIF9vYmpJdGVyYXRlRW50cmllcyh2YWx1ZSwgZnVuY3Rpb24gKGssIHYpIHsgcmV0dXJuIFtrLCB2XTsgfSk7XG59XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIHBvbHlPYmpWYWx1ZXModmFsdWUpIHtcbiAgICByZXR1cm4gX29iakl0ZXJhdGVFbnRyaWVzKHZhbHVlLCBmdW5jdGlvbiAoXywgdikgeyByZXR1cm4gdjsgfSk7XG59XG5cbmZ1bmN0aW9uIHBvbHlPYmpJcyh2YWx1ZTEsIHZhbHVlMikge1xuICAgIGlmICh2YWx1ZTEgIT09IHZhbHVlMSkge1xuICAgICAgICByZXR1cm4gdmFsdWUyICE9PSB2YWx1ZTI7XG4gICAgfVxuICAgIGlmICh2YWx1ZTEgPT09IDAgJiYgdmFsdWUyID09PSAwKSB7XG4gICAgICAgIHJldHVybiAxIC8gdmFsdWUxID09PSAxIC8gdmFsdWUyO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUxID09PSB2YWx1ZTI7XG59XG5cbnZhciBvYmpJc0Zyb3plbiA9ICggLyojX19QVVJFX18qL19wdXJlQXNzaWduKCggLyojX19QVVJFX18qL19wdXJlUmVmKE9iakNsYXNzLCBcImlzRnJvemVuXCIpKSwgX3JldHVybkZhbHNlKSk7XG52YXIgb2JqSXNTZWFsZWQgPSAoIC8qI19fUFVSRV9fKi9fcHVyZUFzc2lnbigoIC8qI19fUFVSRV9fKi9fcHVyZVJlZihPYmpDbGFzcywgXCJpc1NlYWxlZFwiKSksIF9yZXR1cm5GYWxzZSkpO1xuXG52YXIgX29iakZyZWV6ZSA9ICggLyojX19QVVJFX18qL19wdXJlUmVmKE9iakNsYXNzLCBcImZyZWV6ZVwiKSk7XG5mdW5jdGlvbiBfZG9Ob3RoaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBfZ2V0UHJvdG8odmFsdWUpIHtcbiAgICBfdGhyb3dJZk51bGxPclVuZGVmaW5lZCh2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlW19fUFJPVE9fX10gfHwgTlVMTF9WQUxVRTtcbn1cbnZhciBvYmpBc3NpZ24gPSAoIC8qI19fUFVSRV9fKi9fcHVyZVJlZihPYmpDbGFzcywgXCJhc3NpZ25cIikpO1xudmFyIG9iaktleXMgPSAoIC8qI19fUFVSRV9fKi9fcHVyZVJlZihPYmpDbGFzcywgXCJrZXlzXCIpKTtcbmZ1bmN0aW9uIF9kZWVwRnJlZXplKHZhbCwgdmlzaXRlZCkge1xuICAgIGlmICgoaXNBcnJheSh2YWwpIHx8IGlzT2JqZWN0KHZhbCkgfHwgaXNGdW5jdGlvbih2YWwpKSAmJiAhb2JqSXNGcm96ZW4odmFsKSkge1xuICAgICAgICBmb3IgKHZhciBscCA9IDA7IGxwIDwgdmlzaXRlZC5sZW5ndGg7IGxwKyspIHtcbiAgICAgICAgICAgIGlmICh2aXNpdGVkW2xwXSA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2aXNpdGVkLnB1c2godmFsKTtcbiAgICAgICAgb2JqRm9yRWFjaEtleSh2YWwsIGZ1bmN0aW9uIChfa2V5LCBwcm9wVmFsdWUpIHtcbiAgICAgICAgICAgIF9kZWVwRnJlZXplKHByb3BWYWx1ZSwgdmlzaXRlZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBvYmpGcmVlemUodmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn1cbmZ1bmN0aW9uIG9iakRlZXBGcmVlemUodmFsdWUpIHtcbiAgICByZXR1cm4gX29iakZyZWV6ZSA/IF9kZWVwRnJlZXplKHZhbHVlLCBbXSkgOiB2YWx1ZTtcbn1cbnZhciBvYmpGcmVlemUgPSAoIC8qI19fUFVSRV9fKi9fcHVyZUFzc2lnbihfb2JqRnJlZXplLCBfZG9Ob3RoaW5nKSk7XG52YXIgb2JqU2VhbCA9ICggLyojX19QVVJFX18qL19wdXJlQXNzaWduKCggLyojX19QVVJFX18qL19wdXJlUmVmKE9iakNsYXNzLCBcInNlYWxcIikpLCBfZG9Ob3RoaW5nKSk7XG52YXIgb2JqR2V0UHJvdG90eXBlT2YgPSAoIC8qI19fUFVSRV9fKi9fcHVyZUFzc2lnbigoIC8qI19fUFVSRV9fKi9fcHVyZVJlZihPYmpDbGFzcywgXCJnZXRQcm90b3R5cGVPZlwiKSksIF9nZXRQcm90bykpO1xudmFyIG9iakVudHJpZXMgPSAoIC8qI19fUFVSRV9fKi9fcHVyZUFzc2lnbigoIC8qI19fUFVSRV9fKi9fcHVyZVJlZihPYmpDbGFzcywgXCJlbnRyaWVzXCIpKSwgcG9seU9iakVudHJpZXMpKTtcbnZhciBvYmpWYWx1ZXMgPSAoIC8qI19fUFVSRV9fKi9fcHVyZUFzc2lnbigoIC8qI19fUFVSRV9fKi9fcHVyZVJlZihPYmpDbGFzcywgXCJ2YWx1ZXNcIikpLCBwb2x5T2JqVmFsdWVzKSk7XG52YXIgb2JqSXMgPSAoIC8qI19fUFVSRV9fKi9fcHVyZUFzc2lnbigoIC8qI19fUFVSRV9fKi9fcHVyZVJlZihPYmpDbGFzcywgXCJpc1wiKSksIHBvbHlPYmpJcykpO1xuXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIGNyZWF0ZUVudW0odmFsdWVzKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVLZXlWYWx1ZU1hcCh2YWx1ZXMsIDEgLCAwICwgb2JqRnJlZXplKTtcbn1cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gY3JlYXRlRW51bUtleU1hcCh2YWx1ZXMpIHtcbiAgICByZXR1cm4gX2NyZWF0ZUtleVZhbHVlTWFwKHZhbHVlcywgMCAsIDAgLCBvYmpGcmVlemUpO1xufVxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBjcmVhdGVFbnVtVmFsdWVNYXAodmFsdWVzKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVLZXlWYWx1ZU1hcCh2YWx1ZXMsIDEgLCAxICwgb2JqRnJlZXplKTtcbn1cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gY3JlYXRlU2ltcGxlTWFwKHZhbHVlcykge1xuICAgIHZhciBtYXBDbGFzcyA9IHt9O1xuICAgIG9iakZvckVhY2hLZXkodmFsdWVzLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBfYXNzaWduTWFwVmFsdWUobWFwQ2xhc3MsIGtleSwgdmFsdWVbMV0pO1xuICAgICAgICBfYXNzaWduTWFwVmFsdWUobWFwQ2xhc3MsIHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iakZyZWV6ZShtYXBDbGFzcyk7XG59XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIGNyZWF0ZVR5cGVNYXAodmFsdWVzKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVNpbXBsZU1hcCh2YWx1ZXMpO1xufVxuXG52YXIgX3dlbGxLbm93blN5bWJvbE1hcCA9ICggLyojX19QVVJFX18qL2NyZWF0ZUVudW1LZXlNYXAoe1xuICAgIGFzeW5jSXRlcmF0b3I6IDAgLFxuICAgIGhhc0luc3RhbmNlOiAxICxcbiAgICBpc0NvbmNhdFNwcmVhZGFibGU6IDIgLFxuICAgIGl0ZXJhdG9yOiAzICxcbiAgICBtYXRjaDogNCAsXG4gICAgbWF0Y2hBbGw6IDUgLFxuICAgIHJlcGxhY2U6IDYgLFxuICAgIHNlYXJjaDogNyAsXG4gICAgc3BlY2llczogOCAsXG4gICAgc3BsaXQ6IDkgLFxuICAgIHRvUHJpbWl0aXZlOiAxMCAsXG4gICAgdG9TdHJpbmdUYWc6IDExICxcbiAgICB1bnNjb3BhYmxlczogMTJcbn0pKTtcblxudmFyIEdMT0JBTF9DT05GSUdfS0VZID0gXCJfX3RzVXRpbHMkZ2JsQ2ZnXCI7XG52YXIgX2dsb2JhbENmZztcbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gX2dldEdsb2JhbFZhbHVlKCkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBVTkRFRklORUQpIHtcbiAgICAgICAgcmVzdWx0ID0gZ2xvYmFsVGhpcztcbiAgICB9XG4gICAgaWYgKCFyZXN1bHQgJiYgdHlwZW9mIHNlbGYgIT09IFVOREVGSU5FRCkge1xuICAgICAgICByZXN1bHQgPSBzZWxmO1xuICAgIH1cbiAgICBpZiAoIXJlc3VsdCAmJiB0eXBlb2Ygd2luZG93ICE9PSBVTkRFRklORUQpIHtcbiAgICAgICAgcmVzdWx0ID0gd2luZG93O1xuICAgIH1cbiAgICBpZiAoIXJlc3VsdCAmJiB0eXBlb2YgZ2xvYmFsICE9PSBVTkRFRklORUQpIHtcbiAgICAgICAgcmVzdWx0ID0gZ2xvYmFsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBfZ2V0R2xvYmFsQ29uZmlnKCkge1xuICAgIGlmICghX2dsb2JhbENmZykge1xuICAgICAgICB2YXIgZ2JsID0gc2FmZShfZ2V0R2xvYmFsVmFsdWUpLnYgfHwge307XG4gICAgICAgIF9nbG9iYWxDZmcgPSBnYmxbR0xPQkFMX0NPTkZJR19LRVldID0gZ2JsW0dMT0JBTF9DT05GSUdfS0VZXSB8fCB7fTtcbiAgICB9XG4gICAgcmV0dXJuIF9nbG9iYWxDZmc7XG59XG5cbnZhciBtYXRoTWluID0gKCAvKiNfX1BVUkVfXyovX3B1cmVSZWYoTWF0aENscywgXCJtaW5cIikpO1xudmFyIG1hdGhNYXggPSAoIC8qI19fUFVSRV9fKi9fcHVyZVJlZihNYXRoQ2xzLCBcIm1heFwiKSk7XG5cbnZhciBzdHJTbGljZSA9ICggLyojX19QVVJFX18qL191bndyYXBGdW5jdGlvbihcInNsaWNlXCIsIFN0clByb3RvKSk7XG5cbnZhciBzdHJTdWJzdHJpbmcgPSAoIC8qI19fUFVSRV9fKi9fdW53cmFwRnVuY3Rpb24oXCJzdWJzdHJpbmdcIiwgU3RyUHJvdG8pKTtcbnZhciBzdHJTdWJzdHIgPSAoIC8qI19fUFVSRV9fKi9fdW53cmFwRnVuY3Rpb25XaXRoUG9seShcInN1YnN0clwiLCBTdHJQcm90bywgcG9seVN0clN1YnN0cikpO1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBwb2x5U3RyU3Vic3RyKHZhbHVlLCBzdGFydCwgbGVuZ3RoKSB7XG4gICAgX3Rocm93SWZOdWxsT3JVbmRlZmluZWQodmFsdWUpO1xuICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgIHJldHVybiBFTVBUWTtcbiAgICB9XG4gICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSBtYXRoTWF4KHN0YXJ0ICsgdmFsdWVbTEVOR1RIXSwgMCk7XG4gICAgfVxuICAgIGlmIChpc1VuZGVmaW5lZChsZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBzdHJTbGljZSh2YWx1ZSwgc3RhcnQpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyU2xpY2UodmFsdWUsIHN0YXJ0LCBzdGFydCArIGxlbmd0aCk7XG59XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIHN0ckxlZnQodmFsdWUsIGNvdW50KSB7XG4gICAgcmV0dXJuIHN0clN1YnN0cmluZyh2YWx1ZSwgMCwgY291bnQpO1xufVxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBzdHJSaWdodCh2YWx1ZSwgY291bnQpIHtcbiAgICByZXR1cm4gY291bnQgPD0gMCA/IEVNUFRZIDogKHZhbHVlW0xFTkdUSF0gPiBjb3VudCA/IHN0clNsaWNlKHZhbHVlLCAtY291bnQpIDogdmFsdWUpO1xufVxuXG5mdW5jdGlvbiBfdGFnQXNQb2x5ZmlsbCh0YXJnZXQsIHBvbHlmaWxsVHlwZU5hbWUpIHtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIHNhZmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGFyZ2V0W1BPTFlGSUxMX1RBR10gPSB0cnVlO1xuICAgICAgICAgICAgdGFyZ2V0W1BPTFlGSUxMX1RZUEVfTkFNRV0gPSBwb2x5ZmlsbFR5cGVOYW1lO1xuICAgICAgICB9KTtcbiAgICAgICAgc2FmZShvYmpEZWZpbmUsIFt0YXJnZXQsIFBPTFlGSUxMX1RBRywge1xuICAgICAgICAgICAgICAgIHY6IHRydWUsXG4gICAgICAgICAgICAgICAgdzogZmFsc2UsXG4gICAgICAgICAgICAgICAgZTogZmFsc2VcbiAgICAgICAgICAgIH1dKTtcbiAgICAgICAgc2FmZShvYmpEZWZpbmUsIFt0YXJnZXQsIFBPTFlGSUxMX1RZUEVfTkFNRSwge1xuICAgICAgICAgICAgICAgIHY6IHBvbHlmaWxsVHlwZU5hbWUsXG4gICAgICAgICAgICAgICAgdzogZmFsc2UsXG4gICAgICAgICAgICAgICAgZTogZmFsc2VcbiAgICAgICAgICAgIH1dKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxudmFyIG9iakNyZWF0ZSA9ICggLyogI19fUFVSRV9fKi9fcHVyZUFzc2lnbigoIC8qICNfX1BVUkVfXyovX3B1cmVSZWYoT2JqQ2xhc3MsIFwiY3JlYXRlXCIpKSwgcG9seU9iakNyZWF0ZSkpO1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBwb2x5T2JqQ3JlYXRlKG9iaiwgcHJvcGVydGllcykge1xuICAgIHZhciBuZXdPYmogPSBudWxsO1xuICAgIGZ1bmN0aW9uIHRlbXBGdW5jKCkgeyB9XG4gICAgaWYgKCFpc1N0cmljdE51bGxPclVuZGVmaW5lZChvYmopKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICAgICAgaWYgKHR5cGUgIT09IE9CSkVDVCAmJiB0eXBlICE9PSBGVU5DVElPTikge1xuICAgICAgICAgICAgdGhyb3dUeXBlRXJyb3IoXCJQcm90b3R5cGUgbXVzdCBiZSBhbiBPYmplY3Qgb3IgZnVuY3Rpb246IFwiICsgZHVtcE9iaihvYmopKTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wRnVuY1tQUk9UT1RZUEVdID0gb2JqO1xuICAgICAgICBzYWZlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRlbXBGdW5jW19fUFJPVE9fX10gPSBvYmo7XG4gICAgICAgIH0pO1xuICAgICAgICBuZXdPYmogPSBuZXcgdGVtcEZ1bmMoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5ld09iaiA9IHt9O1xuICAgIH1cbiAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICBzYWZlKG9iakRlZmluZVByb3BlcnRpZXMsIFtuZXdPYmosIHByb3BlcnRpZXNdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld09iajtcbn1cblxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiB1dGNOb3coKSB7XG4gICAgcmV0dXJuIChEYXRlLm5vdyB8fCBwb2x5VXRjTm93KSgpO1xufVxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBwb2x5VXRjTm93KCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbn1cblxuZnVuY3Rpb24gZm5BcHBseShmbiwgdGhpc0FyZywgYXJnQXJyYXkpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJnQXJyYXkpO1xufVxuZnVuY3Rpb24gZm5DYWxsKGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIEFyclNsaWNlW0NBTExdKGFyZ3VtZW50cywgMikpO1xufVxuZnVuY3Rpb24gZm5CaW5kKGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGZuLmJpbmQuYXBwbHkoZm4sIEFyclNsaWNlW0NBTExdKGFyZ3VtZW50cywgMSkpO1xufVxuXG52YXIgX2dsb2JhbExhenlUZXN0SG9va3M7XG5mdW5jdGlvbiBfaW5pdFRlc3RIb29rcygpIHtcbiAgICBfZ2xvYmFsTGF6eVRlc3RIb29rcyA9IF9nZXRHbG9iYWxDb25maWcoKTtcbn1cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gZ2V0TGF6eShjYiwgYXJnQXJyYXkpIHtcbiAgICB2YXIgbGF6eVZhbHVlID0ge307XG4gICAgIV9nbG9iYWxMYXp5VGVzdEhvb2tzICYmIF9pbml0VGVzdEhvb2tzKCk7XG4gICAgbGF6eVZhbHVlLmIgPSBfZ2xvYmFsTGF6eVRlc3RIb29rcy5senk7XG4gICAgb2JqRGVmaW5lUHJvcChsYXp5VmFsdWUsIFwidlwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZm5BcHBseShjYiwgbnVsbCwgYXJnQXJyYXkpO1xuICAgICAgICAgICAgaWYgKCFfZ2xvYmFsTGF6eVRlc3RIb29rcy5senkpIHtcbiAgICAgICAgICAgICAgICBvYmpEZWZpbmVQcm9wKGxhenlWYWx1ZSwgXCJ2XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGF6eVZhbHVlLmIgPSBfZ2xvYmFsTGF6eVRlc3RIb29rcy5senk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGxhenlWYWx1ZTtcbn1cbmZ1bmN0aW9uIHNldEJ5cGFzc0xhenlDYWNoZShuZXdWYWx1ZSkge1xuICAgICFfZ2xvYmFsTGF6eVRlc3RIb29rcyAmJiBfaW5pdFRlc3RIb29rcygpO1xuICAgIF9nbG9iYWxMYXp5VGVzdEhvb2tzLmx6eSA9IG5ld1ZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0V3JpdGFibGVMYXp5KGNiLCBhcmdBcnJheSkge1xuICAgIHZhciBsYXp5VmFsdWUgPSB7fTtcbiAgICAhX2dsb2JhbExhenlUZXN0SG9va3MgJiYgX2luaXRUZXN0SG9va3MoKTtcbiAgICBsYXp5VmFsdWUuYiA9IF9nbG9iYWxMYXp5VGVzdEhvb2tzLmx6eTtcbiAgICB2YXIgX3NldFZhbHVlID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgIG9iakRlZmluZVByb3AobGF6eVZhbHVlLCBcInZcIiwge1xuICAgICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChsYXp5VmFsdWUuYikge1xuICAgICAgICAgICAgZGVsZXRlIGxhenlWYWx1ZS5iO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBvYmpEZWZpbmVQcm9wKGxhenlWYWx1ZSwgXCJ2XCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBmbkFwcGx5KGNiLCBudWxsLCBhcmdBcnJheSk7XG4gICAgICAgICAgICBpZiAoIV9nbG9iYWxMYXp5VGVzdEhvb2tzLmx6eSkge1xuICAgICAgICAgICAgICAgIF9zZXRWYWx1ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9nbG9iYWxMYXp5VGVzdEhvb2tzLmx6eSAmJiBsYXp5VmFsdWUuYiAhPT0gX2dsb2JhbExhenlUZXN0SG9va3MubHp5KSB7XG4gICAgICAgICAgICAgICAgbGF6eVZhbHVlLmIgPSBfZ2xvYmFsTGF6eVRlc3RIb29rcy5senk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IF9zZXRWYWx1ZVxuICAgIH0pO1xuICAgIHJldHVybiBsYXp5VmFsdWU7XG59XG5cbnZhciBtYXRoUmFuZG9tID0gKCAvKiNfX1BVUkVfXyovX3B1cmVSZWYoTWF0aENscywgXCJyYW5kb21cIikpO1xuXG52YXIgX3VuaXF1ZUluc3RhbmNlSWQgPSAoIC8qI19fUFVSRV9fKi9nZXRMYXp5KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSAodXRjTm93KCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpKTtcbiAgICB3aGlsZSAodmFsdWUubGVuZ3RoIDwgMTYpIHtcbiAgICAgICAgdmFsdWUgKz0gbWF0aFJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbiAgICB9XG4gICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgMTYpO1xuICAgIHJldHVybiB2YWx1ZTtcbn0pKTtcblxudmFyIFVOSVFVRV9SRUdJU1RSWV9JRCA9IFwiX3VyaWRcIjtcbnZhciBQT0xZX1NZTSA9IFwiJG53MjFzeW1cIjtcbnZhciBfcG9seVN5bWJvbHM7XG52YXIgX3BvbHlJZCA9IDA7XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIF9nbG9iYWxTeW1ib2xSZWdpc3RyeSgpIHtcbiAgICBpZiAoIV9wb2x5U3ltYm9scykge1xuICAgICAgICB2YXIgZ2JsQ2ZnID0gX2dldEdsb2JhbENvbmZpZygpO1xuICAgICAgICBfcG9seVN5bWJvbHMgPSBnYmxDZmcuZ2JsU3ltID0gZ2JsQ2ZnLmdibFN5bSB8fCB7IGs6IHt9LCBzOiB7fSB9O1xuICAgIH1cbiAgICByZXR1cm4gX3BvbHlTeW1ib2xzO1xufVxudmFyIF93ZWxsS25vd25TeW1ib2xDYWNoZTtcbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gcG9seU5ld1N5bWJvbChkZXNjcmlwdGlvbikge1xuICAgIHZhciB1bmlxdWVJZCA9IFwiX1wiICsgX3BvbHlJZCsrICsgXCJfXCIgKyBfdW5pcXVlSW5zdGFuY2VJZC52O1xuICAgIHZhciBzeW1TdHJpbmcgPSBTWU1CT0wgKyBcIihcIiArIGRlc2NyaXB0aW9uICsgXCIpXCI7XG4gICAgZnVuY3Rpb24gX3NldFByb3AobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgb2JqRGVmaW5lKHRoZVN5bWJvbCwgbmFtZSwge1xuICAgICAgICAgICAgdjogdmFsdWUsXG4gICAgICAgICAgICBlOiBmYWxzZSxcbiAgICAgICAgICAgIHc6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgdGhlU3ltYm9sID0gb2JqQ3JlYXRlKG51bGwpO1xuICAgIF9zZXRQcm9wKFwiZGVzY3JpcHRpb25cIiwgYXNTdHJpbmcoZGVzY3JpcHRpb24pKTtcbiAgICBfc2V0UHJvcChUT19TVFJJTkcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN5bVN0cmluZyArIFBPTFlfU1lNICsgdW5pcXVlSWQ7IH0pO1xuICAgIF9zZXRQcm9wKFwidmFsdWVPZlwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGVTeW1ib2w7IH0pO1xuICAgIF9zZXRQcm9wKFwidlwiLCBzeW1TdHJpbmcpO1xuICAgIF9zZXRQcm9wKFwiX3VpZFwiLCB1bmlxdWVJZCk7XG4gICAgcmV0dXJuIF90YWdBc1BvbHlmaWxsKHRoZVN5bWJvbCwgXCJzeW1ib2xcIik7XG59XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIHBvbHlTeW1ib2xGb3Ioa2V5KSB7XG4gICAgdmFyIHJlZ2lzdHJ5ID0gX2dsb2JhbFN5bWJvbFJlZ2lzdHJ5KCk7XG4gICAgaWYgKCFvYmpIYXNPd24ocmVnaXN0cnkuaywga2V5KSkge1xuICAgICAgICB2YXIgbmV3U3ltYm9sXzEgPSBwb2x5TmV3U3ltYm9sKGtleSk7XG4gICAgICAgIHZhciByZWdJZF8xID0gb2JqS2V5cyhyZWdpc3RyeS5zKS5sZW5ndGg7XG4gICAgICAgIG5ld1N5bWJvbF8xW1VOSVFVRV9SRUdJU1RSWV9JRF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZWdJZF8xICsgXCJfXCIgKyBuZXdTeW1ib2xfMVtUT19TVFJJTkddKCk7IH07XG4gICAgICAgIHJlZ2lzdHJ5Lmtba2V5XSA9IG5ld1N5bWJvbF8xO1xuICAgICAgICByZWdpc3RyeS5zW25ld1N5bWJvbF8xW1VOSVFVRV9SRUdJU1RSWV9JRF0oKV0gPSBhc1N0cmluZyhrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVnaXN0cnkua1trZXldO1xufVxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBwb2x5U3ltYm9sS2V5Rm9yKHN5bSkge1xuICAgIGlmICghc3ltIHx8ICFzeW1bVE9fU1RSSU5HXSB8fCBzdHJTdWJzdHJpbmcoc3ltW1RPX1NUUklOR10oKSwgMCwgNikgIT0gU1lNQk9MKSB7XG4gICAgICAgIHRocm93VHlwZUVycm9yKHN5bSArIFwiIGlzIG5vdCBhIHN5bWJvbFwiKTtcbiAgICB9XG4gICAgdmFyIHJlZ0lkID0gX2lzUG9seWZpbGwoc3ltKSAmJiBzeW1bVU5JUVVFX1JFR0lTVFJZX0lEXSAmJiBzeW1bVU5JUVVFX1JFR0lTVFJZX0lEXSgpO1xuICAgIHJldHVybiByZWdJZCA/IF9nbG9iYWxTeW1ib2xSZWdpc3RyeSgpLnNbcmVnSWRdIDogdW5kZWZpbmVkO1xufVxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBwb2x5R2V0S25vd25TeW1ib2wobmFtZSkge1xuICAgICFfd2VsbEtub3duU3ltYm9sQ2FjaGUgJiYgKF93ZWxsS25vd25TeW1ib2xDYWNoZSA9IHt9KTtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHZhciBrbm93bk5hbWUgPSBfd2VsbEtub3duU3ltYm9sTWFwW25hbWVdO1xuICAgIGlmIChrbm93bk5hbWUpIHtcbiAgICAgICAgcmVzdWx0ID0gX3dlbGxLbm93blN5bWJvbENhY2hlW2tub3duTmFtZV0gPSBfd2VsbEtub3duU3ltYm9sQ2FjaGVba25vd25OYW1lXSB8fCBwb2x5TmV3U3ltYm9sKFNZTUJPTCArIFwiLlwiICsga25vd25OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZWRWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiBvYmpEZWZpbmVQcm9wKHtcbiAgICAgICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWx1ZTsgfVxuICAgIH0sIFwidlwiLCB7IHZhbHVlOiB2YWx1ZSB9KTtcbn1cbnZhciBjcmVhdGVEZWZlcnJlZENhY2hlZFZhbHVlID0gZ2V0RGVmZXJyZWQ7XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIGdldERlZmVycmVkKGNiLCBhcmdBcnJheSkge1xuICAgIHZhciB0aGVWYWx1ZSA9IHtcbiAgICAgICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGVWYWx1ZS52OyB9XG4gICAgfTtcbiAgICByZXR1cm4gb2JqRGVmaW5lUHJvcCh0aGVWYWx1ZSwgXCJ2XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZm5BcHBseShjYiwgbnVsbCwgYXJnQXJyYXkpO1xuICAgICAgICAgICAgY2IgPSBOVUxMX1ZBTFVFO1xuICAgICAgICAgICAgb2JqRGVmaW5lUHJvcCh0aGVWYWx1ZSwgXCJ2XCIsIHsgdmFsdWU6IHJlc3VsdCB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xufVxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBnZXRXcml0YWJsZURlZmVycmVkKGNiLCBhcmdBcnJheSkge1xuICAgIHZhciB0aGVWYWx1ZSA9IHtcbiAgICAgICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGVWYWx1ZS52OyB9XG4gICAgfTtcbiAgICB2YXIgX3NldFZhbHVlID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgIG9iakRlZmluZVByb3AodGhlVmFsdWUsIFwidlwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBvYmpEZWZpbmVQcm9wKHRoZVZhbHVlLCBcInZcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBmbkFwcGx5KGNiLCBudWxsLCBhcmdBcnJheSk7XG4gICAgICAgICAgICBfc2V0VmFsdWUocmVzdWx0KTtcbiAgICAgICAgICAgIGNiID0gTlVMTF9WQUxVRTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogX3NldFZhbHVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbn1cblxudmFyIFdJTkRPVyA9IFwid2luZG93XCI7XG52YXIgX2NhY2hlZEdsb2JhbDtcbmZ1bmN0aW9uIF9nZXRHbG9iYWxJbnN0Rm4oZ2V0Rm4sIHRoZUFyZ3MpIHtcbiAgICB2YXIgY2FjaGVkVmFsdWU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgIV9nbG9iYWxMYXp5VGVzdEhvb2tzICYmIF9pbml0VGVzdEhvb2tzKCk7XG4gICAgICAgIGlmICghY2FjaGVkVmFsdWUgfHwgX2dsb2JhbExhenlUZXN0SG9va3MubHp5KSB7XG4gICAgICAgICAgICBjYWNoZWRWYWx1ZSA9IGNyZWF0ZUNhY2hlZFZhbHVlKHNhZmUoZ2V0Rm4sIHRoZUFyZ3MpLnYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWNoZWRWYWx1ZS52O1xuICAgIH07XG59XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIGxhenlTYWZlR2V0SW5zdChuYW1lKSB7XG4gICAgcmV0dXJuIGdldExhenkoZnVuY3Rpb24gKCkgeyByZXR1cm4gc2FmZSgoZ2V0SW5zdCksIFtuYW1lXSkudiB8fCBVTkRFRl9WQUxVRTsgfSk7XG59XG5mdW5jdGlvbiBnZXRHbG9iYWwodXNlQ2FjaGVkKSB7XG4gICAgIV9nbG9iYWxMYXp5VGVzdEhvb2tzICYmIF9pbml0VGVzdEhvb2tzKCk7XG4gICAgaWYgKCFfY2FjaGVkR2xvYmFsIHx8IHVzZUNhY2hlZCA9PT0gZmFsc2UgfHwgX2dsb2JhbExhenlUZXN0SG9va3MubHp5KSB7XG4gICAgICAgIF9jYWNoZWRHbG9iYWwgPSBjcmVhdGVDYWNoZWRWYWx1ZShzYWZlKF9nZXRHbG9iYWxWYWx1ZSkudiB8fCBOVUxMX1ZBTFVFKTtcbiAgICB9XG4gICAgcmV0dXJuIF9jYWNoZWRHbG9iYWwudjtcbn1cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gZ2V0SW5zdChuYW1lLCB1c2VDYWNoZWQpIHtcbiAgICB2YXIgZ2JsO1xuICAgIGlmICghX2NhY2hlZEdsb2JhbCB8fCB1c2VDYWNoZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIGdibCA9IGdldEdsb2JhbCh1c2VDYWNoZWQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2JsID0gX2NhY2hlZEdsb2JhbC52O1xuICAgIH1cbiAgICBpZiAoZ2JsICYmIGdibFtuYW1lXSkge1xuICAgICAgICByZXR1cm4gZ2JsW25hbWVdO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gV0lORE9XKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG59XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIGhhc0RvY3VtZW50KCkge1xuICAgIHJldHVybiAhISggLyojX19QVVJFX18qL2dldERvY3VtZW50KCkpO1xufVxudmFyIGdldERvY3VtZW50ID0gKCAvKiNfX1BVUkVfXyovX2dldEdsb2JhbEluc3RGbihnZXRJbnN0LCBbXCJkb2N1bWVudFwiXSkpO1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBoYXNXaW5kb3coKSB7XG4gICAgcmV0dXJuICEhKCAvKiNfX1BVUkVfXyovZ2V0V2luZG93KCkpO1xufVxudmFyIGdldFdpbmRvdyA9ICggLyojX19QVVJFX18qL19nZXRHbG9iYWxJbnN0Rm4oZ2V0SW5zdCwgW1dJTkRPV10pKTtcbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gaGFzTmF2aWdhdG9yKCkge1xuICAgIHJldHVybiAhISggLyojX19QVVJFX18qL2dldE5hdmlnYXRvcigpKTtcbn1cbnZhciBnZXROYXZpZ2F0b3IgPSAoIC8qI19fUFVSRV9fKi9fZ2V0R2xvYmFsSW5zdEZuKGdldEluc3QsIFtcIm5hdmlnYXRvclwiXSkpO1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBoYXNIaXN0b3J5KCkge1xuICAgIHJldHVybiAhISggLyojX19QVVJFX18qL2dldEhpc3RvcnkoKSk7XG59XG52YXIgZ2V0SGlzdG9yeSA9ICggLyojX19QVVJFX18qL19nZXRHbG9iYWxJbnN0Rm4oZ2V0SW5zdCwgW1wiaGlzdG9yeVwiXSkpO1xudmFyIGlzTm9kZSA9ICggLyojX19QVVJFX18qL19nZXRHbG9iYWxJbnN0Rm4oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhISggLyojX19QVVJFX18qL3NhZmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gKHByb2Nlc3MgJiYgKHByb2Nlc3MudmVyc2lvbnMgfHwge30pLm5vZGUpOyB9KS52KTtcbn0pKTtcbnZhciBpc1dlYldvcmtlciA9ICggLyojX19QVVJFX18qL19nZXRHbG9iYWxJbnN0Rm4oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhISggLyojX19QVVJFX18qL3NhZmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZiAmJiBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGU7IH0pLnYpO1xufSkpO1xuXG52YXIgX3N5bWJvbDtcbnZhciBfc3ltYm9sRm9yO1xudmFyIF9zeW1ib2xLZXlGb3I7XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIF9pbml0U3ltYm9sKCkge1xuICAgIF9zeW1ib2wgPSAoIC8qI19fUFVSRV9fKi9jcmVhdGVDYWNoZWRWYWx1ZShzYWZlKChnZXRJbnN0KSwgW1NZTUJPTF0pLnYpKTtcbiAgICByZXR1cm4gX3N5bWJvbDtcbn1cbmZ1bmN0aW9uIF9nZXRTeW1ib2xLZXkoa2V5KSB7XG4gICAgdmFyIGdibFN5bSA9ICgoIV9nbG9iYWxMYXp5VGVzdEhvb2tzLmx6eSA/IF9zeW1ib2wgOiAwKSB8fCBfaW5pdFN5bWJvbCgpKTtcbiAgICByZXR1cm4gKGdibFN5bS52ID8gZ2JsU3ltLnZba2V5XSA6IFVOREVGX1ZBTFVFKTtcbn1cbnZhciBpc1N5bWJvbCA9ICggLyojX19QVVJFX18qL19jcmVhdGVJc1dpdGhQb2x5KFwic3ltYm9sXCIpKTtcbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gaGFzU3ltYm9sKCkge1xuICAgIHJldHVybiAhISggLyojX19QVVJFX18qL2dldFN5bWJvbCgpKTtcbn1cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gZ2V0U3ltYm9sKCkge1xuICAgICFfZ2xvYmFsTGF6eVRlc3RIb29rcyAmJiBfaW5pdFRlc3RIb29rcygpO1xuICAgIHJldHVybiAoKCFfZ2xvYmFsTGF6eVRlc3RIb29rcy5senkgPyBfc3ltYm9sIDogMCkgfHwgX2luaXRTeW1ib2woKSkudjtcbn1cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gZ2V0S25vd25TeW1ib2wobmFtZSwgbm9Qb2x5KSB7XG4gICAgdmFyIGtub3duTmFtZSA9IF93ZWxsS25vd25TeW1ib2xNYXBbbmFtZV07XG4gICAgIV9nbG9iYWxMYXp5VGVzdEhvb2tzICYmIF9pbml0VGVzdEhvb2tzKCk7XG4gICAgdmFyIHN5bSA9ICgoIV9nbG9iYWxMYXp5VGVzdEhvb2tzLmx6eSA/IF9zeW1ib2wgOiAwKSB8fCBfaW5pdFN5bWJvbCgpKTtcbiAgICByZXR1cm4gc3ltLnYgPyBzeW0udltrbm93bk5hbWUgfHwgbmFtZV0gOiAoIW5vUG9seSA/IHBvbHlHZXRLbm93blN5bWJvbChuYW1lKSA6IFVOREVGX1ZBTFVFKTtcbn1cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gbmV3U3ltYm9sKGRlc2NyaXB0aW9uLCBub1BvbHkpIHtcbiAgICAhX2dsb2JhbExhenlUZXN0SG9va3MgJiYgX2luaXRUZXN0SG9va3MoKTtcbiAgICB2YXIgc3ltID0gKCghX2dsb2JhbExhenlUZXN0SG9va3MubHp5ID8gX3N5bWJvbCA6IDApIHx8IF9pbml0U3ltYm9sKCkpO1xuICAgIHJldHVybiBzeW0udiA/IHN5bS52KGRlc2NyaXB0aW9uKSA6ICghbm9Qb2x5ID8gcG9seU5ld1N5bWJvbChkZXNjcmlwdGlvbikgOiBOVUxMX1ZBTFVFKTtcbn1cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gc3ltYm9sRm9yKGtleSkge1xuICAgICFfZ2xvYmFsTGF6eVRlc3RIb29rcyAmJiBfaW5pdFRlc3RIb29rcygpO1xuICAgIF9zeW1ib2xGb3IgPSAoKCFfZ2xvYmFsTGF6eVRlc3RIb29rcy5senkgPyBfc3ltYm9sRm9yIDogMCkgfHwgKCAvKiNfX1BVUkVfXyovY3JlYXRlQ2FjaGVkVmFsdWUoc2FmZSgoX2dldFN5bWJvbEtleSksIFtcImZvclwiXSkudikpKTtcbiAgICByZXR1cm4gKF9zeW1ib2xGb3IudiB8fCBwb2x5U3ltYm9sRm9yKShrZXkpO1xufVxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBzeW1ib2xLZXlGb3Ioc3ltKSB7XG4gICAgIV9nbG9iYWxMYXp5VGVzdEhvb2tzICYmIF9pbml0VGVzdEhvb2tzKCk7XG4gICAgX3N5bWJvbEtleUZvciA9ICgoIV9nbG9iYWxMYXp5VGVzdEhvb2tzLmx6eSA/IF9zeW1ib2xLZXlGb3IgOiAwKSB8fCAoIC8qI19fUFVSRV9fKi9jcmVhdGVDYWNoZWRWYWx1ZShzYWZlKChfZ2V0U3ltYm9sS2V5KSwgW1wia2V5Rm9yXCJdKS52KSkpO1xuICAgIHJldHVybiAoX3N5bWJvbEtleUZvci52IHx8IHBvbHlTeW1ib2xLZXlGb3IpKHN5bSk7XG59XG5cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gaXNJdGVyYXRvcih2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmIGlzRnVuY3Rpb24odmFsdWUubmV4dCk7XG59XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIGlzSXRlcmFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gIWlzU3RyaWN0TnVsbE9yVW5kZWZpbmVkKHZhbHVlKSAmJiBpc0Z1bmN0aW9uKHZhbHVlW2dldEtub3duU3ltYm9sKDMgKV0pO1xufVxuXG52YXIgX2l0ZXJTeW1ib2wkMTtcbmZ1bmN0aW9uIGl0ZXJGb3JPZihpdGVyLCBjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgaWYgKGl0ZXIpIHtcbiAgICAgICAgaWYgKCFpc0l0ZXJhdG9yKGl0ZXIpKSB7XG4gICAgICAgICAgICAhX2l0ZXJTeW1ib2wkMSAmJiAoX2l0ZXJTeW1ib2wkMSA9IGNyZWF0ZUNhY2hlZFZhbHVlKGdldEtub3duU3ltYm9sKDMgKSkpO1xuICAgICAgICAgICAgaXRlciA9IGl0ZXJbX2l0ZXJTeW1ib2wkMS52XSA/IGl0ZXJbX2l0ZXJTeW1ib2wkMS52XSgpIDogTlVMTF9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNJdGVyYXRvcihpdGVyKSkge1xuICAgICAgICAgICAgdmFyIGVyciA9IFVOREVGX1ZBTFVFO1xuICAgICAgICAgICAgdmFyIGl0ZXJSZXN1bHQgPSBVTkRFRl9WQUxVRTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIShpdGVyUmVzdWx0ID0gaXRlci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrZm5bQ0FMTF0odGhpc0FyZyB8fCBpdGVyLCBpdGVyUmVzdWx0LnZhbHVlLCBjb3VudCwgaXRlcikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChmYWlsZWQpIHtcbiAgICAgICAgICAgICAgICBlcnIgPSB7IGU6IGZhaWxlZCB9O1xuICAgICAgICAgICAgICAgIGlmIChpdGVyLnRocm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJSZXN1bHQgPSBOVUxMX1ZBTFVFO1xuICAgICAgICAgICAgICAgICAgICBpdGVyLnRocm93KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZXJSZXN1bHQgJiYgIWl0ZXJSZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlci5yZXR1cm4gJiYgaXRlci5yZXR1cm4oaXRlclJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnNhZmUtZmluYWxseVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyLmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFyckFwcGVuZCh0YXJnZXQsIGVsbXMpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKGVsbXMpICYmIHRhcmdldCkge1xuICAgICAgICBpZiAoaXNBcnJheShlbG1zKSkge1xuICAgICAgICAgICAgZm5BcHBseSh0YXJnZXQucHVzaCwgdGFyZ2V0LCBlbG1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0l0ZXJhdG9yKGVsbXMpIHx8IGlzSXRlcmFibGUoZWxtcykpIHtcbiAgICAgICAgICAgIGl0ZXJGb3JPZihlbG1zLCBmdW5jdGlvbiAoZWxtKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goZWxtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2goZWxtcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxudmFyIGFyckV2ZXJ5ID0gLyojX19QVVJFX18qLyBfdW53cmFwRnVuY3Rpb24oXCJldmVyeVwiLCBBcnJQcm90byk7XG52YXIgYXJyRmlsdGVyID0gLyojX19QVVJFX18qLyBfdW53cmFwRnVuY3Rpb24oXCJmaWx0ZXJcIiwgQXJyUHJvdG8pO1xuXG52YXIgYXJySW5kZXhPZiA9ICggLyojX19QVVJFX18qL191bndyYXBGdW5jdGlvbihcImluZGV4T2ZcIiwgQXJyUHJvdG8pKTtcbnZhciBhcnJMYXN0SW5kZXhPZiA9ICggLyojX19QVVJFX18qL191bndyYXBGdW5jdGlvbihcImxhc3RJbmRleE9mXCIsIEFyclByb3RvKSk7XG5cbnZhciBhcnJNYXAgPSAoIC8qI19fUFVSRV9fKi9fdW53cmFwRnVuY3Rpb24oXCJtYXBcIiwgQXJyUHJvdG8pKTtcblxuZnVuY3Rpb24gYXJyU2xpY2UodGhlQXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKCh0aGVBcnJheSA/IHRoZUFycmF5W1wic2xpY2VcIl0gOiBOVUxMX1ZBTFVFKSB8fCBBcnJTbGljZSkuYXBwbHkodGhlQXJyYXksIEFyclNsaWNlW0NBTExdKGFyZ3VtZW50cywgMSkpO1xufVxuXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIHBvbHlJc0FycmF5KHZhbHVlKSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvYmpUb1N0cmluZyh2YWx1ZSkgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbn1cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gcG9seUFyckluY2x1ZGVzKHRoZUFycmF5LCBzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpIHtcbiAgICByZXR1cm4gYXJySW5kZXhPZih0aGVBcnJheSwgc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSAhPT0gLTE7XG59XG5mdW5jdGlvbiBwb2x5QXJyRmluZCh0aGVBcnJheSwgY2FsbGJhY2tGbiwgdGhpc0FyZykge1xuICAgIHZhciByZXN1bHQ7XG4gICAgdmFyIGlkeCA9IHBvbHlBcnJGaW5kSW5kZXgodGhlQXJyYXksIGNhbGxiYWNrRm4sIHRoaXNBcmcpO1xuICAgIHJldHVybiBpZHggIT09IC0xID8gdGhlQXJyYXlbaWR4XSA6IHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBvbHlBcnJGaW5kSW5kZXgodGhlQXJyYXksIGNhbGxiYWNrRm4sIHRoaXNBcmcpIHtcbiAgICB2YXIgcmVzdWx0ID0gLTE7XG4gICAgYXJyRm9yRWFjaCh0aGVBcnJheSwgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICBpZiAoY2FsbGJhY2tGbltDQUxMXSh0aGlzQXJnIHwgdGhlQXJyYXksIHZhbHVlLCBpbmRleCwgdGhlQXJyYXkpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpbmRleDtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwb2x5QXJyRmluZExhc3QodGhlQXJyYXksIGNhbGxiYWNrRm4sIHRoaXNBcmcpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHZhciBpZHggPSBwb2x5QXJyRmluZExhc3RJbmRleCh0aGVBcnJheSwgY2FsbGJhY2tGbiwgdGhpc0FyZyk7XG4gICAgcmV0dXJuIGlkeCAhPT0gLTEgPyB0aGVBcnJheVtpZHhdIDogcmVzdWx0O1xufVxuZnVuY3Rpb24gcG9seUFyckZpbmRMYXN0SW5kZXgodGhlQXJyYXksIGNhbGxiYWNrRm4sIHRoaXNBcmcpIHtcbiAgICB2YXIgcmVzdWx0ID0gLTE7XG4gICAgdmFyIGxlbiA9IHRoZUFycmF5W0xFTkdUSF0gPj4+IDA7XG4gICAgZm9yICh2YXIgaWR4ID0gbGVuIC0gMTsgaWR4ID49IDA7IGlkeC0tKSB7XG4gICAgICAgIGlmIChpZHggaW4gdGhlQXJyYXkgJiYgY2FsbGJhY2tGbltDQUxMXSh0aGlzQXJnIHwgdGhlQXJyYXksIHRoZUFycmF5W2lkeF0sIGlkeCwgdGhlQXJyYXkpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpZHg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcG9seUFyckZyb20odGhlVmFsdWUsIG1hcEZuLCB0aGlzQXJnKSB7XG4gICAgaWYgKGlzQXJyYXkodGhlVmFsdWUpKSB7XG4gICAgICAgIHZhciByZXN1bHRfMSA9IGFyclNsaWNlKHRoZVZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1hcEZuID8gYXJyTWFwKHJlc3VsdF8xLCBtYXBGbiwgdGhpc0FyZykgOiByZXN1bHRfMTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGl0ZXJGb3JPZih0aGVWYWx1ZSwgZnVuY3Rpb24gKHZhbHVlLCBjbnQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5wdXNoKG1hcEZuID8gbWFwRm5bQ0FMTF0odGhpc0FyZywgdmFsdWUsIGNudCkgOiB2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIGFyckZpbmQgPSAvKiNfX1BVUkVfXyovIF91bndyYXBGdW5jdGlvbldpdGhQb2x5KFwiZmluZFwiLCBBcnJQcm90bywgcG9seUFyckZpbmQpO1xudmFyIGFyckZpbmRJbmRleCA9IC8qI19fUFVSRV9fKi8gX3Vud3JhcEZ1bmN0aW9uV2l0aFBvbHkoXCJmaW5kSW5kZXhcIiwgQXJyUHJvdG8sIHBvbHlBcnJGaW5kSW5kZXgpO1xudmFyIGFyckZpbmRMYXN0ID0gLyojX19QVVJFX18qLyBfdW53cmFwRnVuY3Rpb25XaXRoUG9seShcImZpbmRMYXN0XCIsIEFyclByb3RvLCBwb2x5QXJyRmluZExhc3QpO1xudmFyIGFyckZpbmRMYXN0SW5kZXggPSAvKiNfX1BVUkVfXyovIF91bndyYXBGdW5jdGlvbldpdGhQb2x5KFwiZmluZExhc3RJbmRleFwiLCBBcnJQcm90bywgcG9seUFyckZpbmRMYXN0SW5kZXgpO1xuXG52YXIgYXJyRnJvbSA9ICggLyogI19fUFVSRV9fKi9fcHVyZUFzc2lnbigoIC8qICNfX1BVUkVfXyovX3B1cmVSZWYoQXJyQ2xzLCBcImZyb21cIikpLCBwb2x5QXJyRnJvbSkpO1xuXG52YXIgYXJySW5jbHVkZXMgPSAoIC8qI19fUFVSRV9fKi9fdW53cmFwRnVuY3Rpb25XaXRoUG9seShcImluY2x1ZGVzXCIsIEFyclByb3RvLCBwb2x5QXJySW5jbHVkZXMpKTtcbnZhciBhcnJDb250YWlucyA9IGFyckluY2x1ZGVzO1xuXG52YXIgYXJyUmVkdWNlID0gKCAvKiNfX1BVUkVfXyovX3Vud3JhcEZ1bmN0aW9uKFwicmVkdWNlXCIsIEFyclByb3RvKSk7XG5cbnZhciBhcnJTb21lID0gKCAvKiNfX1BVUkVfXyovX3Vud3JhcEZ1bmN0aW9uKFwic29tZVwiLCBBcnJQcm90bykpO1xuXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIGNyZWF0ZUZuRGVmZXJyZWRQcm94eShob3N0Rm4sIGZ1bmNOYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRoZUFyZ3MgPSBBcnJTbGljZVtDQUxMXShhcmd1bWVudHMpO1xuICAgICAgICB2YXIgdGhlSG9zdCA9IGhvc3RGbigpO1xuICAgICAgICByZXR1cm4gZm5BcHBseSh0aGVIb3N0W2Z1bmNOYW1lXSwgdGhlSG9zdCwgdGhlQXJncyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb3h5RnVuY3ModGFyZ2V0LCBob3N0LCBmdW5jRGVmcykge1xuICAgIGlmICh0YXJnZXQgJiYgaG9zdCAmJiBpc0FycmF5KGZ1bmNEZWZzKSkge1xuICAgICAgICB2YXIgaXNEZWZlcnJlZF8xID0gaXNGdW5jdGlvbihob3N0KTtcbiAgICAgICAgYXJyRm9yRWFjaChmdW5jRGVmcywgZnVuY3Rpb24gKGZ1bmNEZWYpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXROYW1lID0gKGZ1bmNEZWYuYXMgfHwgZnVuY0RlZi5uKTtcbiAgICAgICAgICAgIGlmIChmdW5jRGVmLnJwID09PSBmYWxzZSAmJiB0YXJnZXRbdGFyZ2V0TmFtZV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXRbdGFyZ2V0TmFtZV0gPSBpc0RlZmVycmVkXzEgP1xuICAgICAgICAgICAgICAgIGNyZWF0ZUZuRGVmZXJyZWRQcm94eShob3N0LCBmdW5jRGVmLm4pIDpcbiAgICAgICAgICAgICAgICBmbkJpbmQoaG9zdFtmdW5jRGVmLm5dLCBob3N0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBfaXRlclN5bWJvbDtcbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gcmVhZEFyZ3ModGhlQXJncywgc3RhcnQsIGVuZCkge1xuICAgIGlmICghb2JqSGFzT3duKHRoZUFyZ3MsIExFTkdUSCkpIHtcbiAgICAgICAgIV9pdGVyU3ltYm9sICYmIChfaXRlclN5bWJvbCA9IGNyZWF0ZUNhY2hlZFZhbHVlKGhhc1N5bWJvbCgpICYmIGdldEtub3duU3ltYm9sKDMgKSkpO1xuICAgICAgICB2YXIgaXRlckZuID0gdm9pZCAwO1xuICAgICAgICBpZiAoX2l0ZXJTeW1ib2wudikge1xuICAgICAgICAgICAgaXRlckZuID0gdGhlQXJnc1tfaXRlclN5bWJvbC52XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlckZuKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzXzEgPSBbXTtcbiAgICAgICAgICAgIHZhciBmcm9tXzEgPSAoc3RhcnQgPT09IFVOREVGX1ZBTFVFIHx8IHN0YXJ0IDwgMCkgPyAwIDogc3RhcnQ7XG4gICAgICAgICAgICB2YXIgdG9fMSA9IGVuZCA8IDAgfHwgc3RhcnQgPCAwID8gVU5ERUZfVkFMVUUgOiBlbmQ7XG4gICAgICAgICAgICBpdGVyRm9yT2YoaXRlckZuW0NBTExdKHRoZUFyZ3MpLCBmdW5jdGlvbiAodmFsdWUsIGNudCkge1xuICAgICAgICAgICAgICAgIGlmICh0b18xICE9PSBVTkRFRl9WQUxVRSAmJiBjbnQgPj0gdG9fMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjbnQgPj0gZnJvbV8xKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc18xLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKChzdGFydCA9PT0gVU5ERUZfVkFMVUUgfHwgc3RhcnQgPj0gMCkgJiYgKGVuZCA9PT0gVU5ERUZfVkFMVUUgfHwgZW5kID49IDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlc18xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhlQXJncyA9IHZhbHVlc18xO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJTbGljZSh0aGVBcmdzLCBzdGFydCwgZW5kKTtcbn1cblxudmFyIF9pc1Byb3RvQXJyYXk7XG52YXIgb2JqU2V0UHJvdG90eXBlT2YgPSAoIC8qI19fUFVSRV9fKi9fcHVyZUFzc2lnbigoIC8qI19fUFVSRV9fKi9fcHVyZVJlZihPYmpDbGFzcywgXCJzZXRQcm90b3R5cGVPZlwiKSksIF9wb2x5T2JqU2V0UHJvdG90eXBlT2YpKTtcbmZ1bmN0aW9uIF9wb2x5T2JqU2V0UHJvdG90eXBlT2Yob2JqLCBwcm90bykge1xuICAgIHZhciBfYTtcbiAgICAhX2lzUHJvdG9BcnJheSAmJiAoX2lzUHJvdG9BcnJheSA9IGNyZWF0ZUNhY2hlZFZhbHVlKChfYSA9IHt9LCBfYVtfX1BST1RPX19dID0gW10sIF9hKSBpbnN0YW5jZW9mIEFycmF5KSk7XG4gICAgX2lzUHJvdG9BcnJheS52ID8gb2JqW19fUFJPVE9fX10gPSBwcm90byA6IG9iakZvckVhY2hLZXkocHJvdG8sIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7IHJldHVybiBvYmpba2V5XSA9IHZhbHVlOyB9KTtcbiAgICByZXR1cm4gb2JqO1xufVxuXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIF9jcmVhdGVDdXN0b21FcnJvcihuYW1lLCBkLCBiKSB7XG4gICAgc2FmZShvYmpEZWZpbmUsIFtkLCBOQU1FLCB7IHY6IG5hbWUsIGM6IHRydWUsIGU6IGZhbHNlIH1dKTtcbiAgICBkID0gb2JqU2V0UHJvdG90eXBlT2YoZCwgYik7XG4gICAgZnVuY3Rpb24gX18oKSB7XG4gICAgICAgIHRoaXNbQ09OU1RSVUNUT1JdID0gZDtcbiAgICAgICAgc2FmZShvYmpEZWZpbmUsIFt0aGlzLCBOQU1FLCB7IHY6IG5hbWUsIGM6IHRydWUsIGU6IGZhbHNlIH1dKTtcbiAgICB9XG4gICAgZFtQUk9UT1RZUEVdID0gYiA9PT0gTlVMTF9WQUxVRSA/IG9iakNyZWF0ZShiKSA6IChfX1tQUk9UT1RZUEVdID0gYltQUk9UT1RZUEVdLCBuZXcgX18oKSk7XG4gICAgcmV0dXJuIGQ7XG59XG5mdW5jdGlvbiBfc2V0TmFtZShiYXNlQ2xhc3MsIG5hbWUpIHtcbiAgICBuYW1lICYmIChiYXNlQ2xhc3NbTkFNRV0gPSBuYW1lKTtcbn1cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gY3JlYXRlQ3VzdG9tRXJyb3IobmFtZSwgY29uc3RydWN0Q2IsIGVycm9yQmFzZSkge1xuICAgIHZhciB0aGVCYXNlQ2xhc3MgPSBlcnJvckJhc2UgfHwgRXJyb3I7XG4gICAgdmFyIG9yZ05hbWUgPSB0aGVCYXNlQ2xhc3NbUFJPVE9UWVBFXVtOQU1FXTtcbiAgICB2YXIgY2FwdHVyZUZuID0gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2U7XG4gICAgcmV0dXJuIF9jcmVhdGVDdXN0b21FcnJvcihuYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0aGVBcmdzID0gYXJndW1lbnRzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2FmZShfc2V0TmFtZSwgW3RoZUJhc2VDbGFzcywgbmFtZV0pO1xuICAgICAgICAgICAgdmFyIF9zZWxmID0gZm5BcHBseSh0aGVCYXNlQ2xhc3MsIF90aGlzLCBBcnJTbGljZVtDQUxMXSh0aGVBcmdzKSkgfHwgX3RoaXM7XG4gICAgICAgICAgICBpZiAoX3NlbGYgIT09IF90aGlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9yZ1Byb3RvID0gb2JqR2V0UHJvdG90eXBlT2YoX3RoaXMpO1xuICAgICAgICAgICAgICAgIGlmIChvcmdQcm90byAhPT0gb2JqR2V0UHJvdG90eXBlT2YoX3NlbGYpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialNldFByb3RvdHlwZU9mKF9zZWxmLCBvcmdQcm90byk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FwdHVyZUZuICYmIGNhcHR1cmVGbihfc2VsZiwgX3RoaXNbQ09OU1RSVUNUT1JdKTtcbiAgICAgICAgICAgIGNvbnN0cnVjdENiICYmIGNvbnN0cnVjdENiKF9zZWxmLCB0aGVBcmdzKTtcbiAgICAgICAgICAgIHJldHVybiBfc2VsZjtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNhZmUoX3NldE5hbWUsIFt0aGVCYXNlQ2xhc3MsIG9yZ05hbWVdKTtcbiAgICAgICAgfVxuICAgIH0sIHRoZUJhc2VDbGFzcyk7XG59XG52YXIgX3Vuc3VwcG9ydGVkRXJyb3I7XG5mdW5jdGlvbiB0aHJvd1Vuc3VwcG9ydGVkKG1lc3NhZ2UpIHtcbiAgICBpZiAoIV91bnN1cHBvcnRlZEVycm9yKSB7XG4gICAgICAgIF91bnN1cHBvcnRlZEVycm9yID0gY3JlYXRlQ3VzdG9tRXJyb3IoXCJVbnN1cHBvcnRlZEVycm9yXCIpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgX3Vuc3VwcG9ydGVkRXJyb3IobWVzc2FnZSk7XG59XG5cbmZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmIHZhbHVlLm5vZGVUeXBlID09PSAxICYmXG4gICAgICAgICEhdmFsdWUubm9kZU5hbWUgJiZcbiAgICAgICAgISEodHlwZW9mIEVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdmFsdWUgaW5zdGFuY2VvZiBFbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudExpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gISF2YWx1ZSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMSAmJiAhIXZhbHVlLm5vZGVOYW1lO1xufVxuXG5mdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGlzU3RyaWN0TnVsbE9yVW5kZWZpbmVkKHZhbHVlKTtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICBpZiAoaXNTdHJpbmcodmFsdWUpIHx8IGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAodmFsdWUubGVuZ3RoID09PSAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc01hcExpa2UodmFsdWUpIHx8IGlzU2V0TGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9ICh2YWx1ZS5zaXplID09PSAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG9iaktleXModmFsdWUpLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIF9jcmVhdGVUcmltRm4oZXhwKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9kb1RyaW0odmFsdWUpIHtcbiAgICAgICAgX3Rocm93SWZOdWxsT3JVbmRlZmluZWQodmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUucmVwbGFjZSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKGV4cCwgRU1QVFkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufVxudmFyIHBvbHlTdHJUcmltID0gKCAvKiNfX1BVUkVfXyovX2NyZWF0ZVRyaW1GbigvXlxccyt8KD89XFxzKVxccyskL2cpKTtcbnZhciBwb2x5U3RyVHJpbVN0YXJ0ID0gKCAvKiNfX1BVUkVfXyovX2NyZWF0ZVRyaW1GbigvXlxccysvZykpO1xudmFyIHBvbHlTdHJUcmltRW5kID0gKCAvKiNfX1BVUkVfXyovX2NyZWF0ZVRyaW1GbigvKD89XFxzKVxccyskL2cpKTtcblxudmFyIHN0clRyaW0gPSAoIC8qI19fUFVSRV9fKi9fdW53cmFwRnVuY3Rpb25XaXRoUG9seShcInRyaW1cIiwgU3RyUHJvdG8sIHBvbHlTdHJUcmltKSk7XG52YXIgc3RyVHJpbVN0YXJ0ID0gKCAvKiNfX1BVUkVfXyovX3Vud3JhcEZ1bmN0aW9uV2l0aFBvbHkoXCJ0cmltU3RhcnRcIiwgU3RyUHJvdG8sIHBvbHlTdHJUcmltU3RhcnQpKTtcbnZhciBzdHJUcmltTGVmdCA9ICggLyojX19QVVJFX18qL19wdXJlQXNzaWduKHN0clRyaW1TdGFydCkpO1xudmFyIHN0clRyaW1FbmQgPSAoIC8qI19fUFVSRV9fKi9fdW53cmFwRnVuY3Rpb25XaXRoUG9seShcInRyaW1FbmRcIiwgU3RyUHJvdG8sIHBvbHlTdHJUcmltRW5kKSk7XG52YXIgc3RyVHJpbVJpZ2h0ID0gKCAvKiNfX1BVUkVfXyovX3B1cmVBc3NpZ24oc3RyVHJpbUVuZCkpO1xuXG52YXIgc3RyVXBwZXIgPSAoIC8qI19fUFVSRV9fKi9fdW53cmFwRnVuY3Rpb24oXCJ0b1VwcGVyQ2FzZVwiLCBTdHJQcm90bykpO1xudmFyIHN0ckxvd2VyID0gKCAvKiNfX1BVUkVfXyovX3Vud3JhcEZ1bmN0aW9uKFwidG9Mb3dlckNhc2VcIiwgU3RyUHJvdG8pKTtcblxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBfY29udmVydENhc2UodmFsdWUsIG5ld1ByZWZpeCwgdXBwZXJXb3JkKSB7XG4gICAgcmV0dXJuIHN0clRyaW0oYXNTdHJpbmcodmFsdWUpKS5yZXBsYWNlKC8oKF98XFxXKSsoXFx3KXswLDF9fChbYS16XSkoW0EtWl0pKS9nLCBmdW5jdGlvbiAoX21hdGNoLCBfZzEsIF9nMiwgd29yZFN0YXJ0LCB1cHBlclByZWZpeCwgdXBwZXJMZXR0ZXIpIHtcbiAgICAgICAgdmFyIGNvbnZlcnRNYXRjaCA9IHdvcmRTdGFydCB8fCB1cHBlckxldHRlciB8fCBFTVBUWTtcbiAgICAgICAgaWYgKHVwcGVyV29yZCkge1xuICAgICAgICAgICAgY29udmVydE1hdGNoID0gc3RyVXBwZXIoY29udmVydE1hdGNoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHVwcGVyUHJlZml4IHx8IEVNUFRZKSArIG5ld1ByZWZpeCArIGNvbnZlcnRNYXRjaDtcbiAgICB9KTtcbn1cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gc3RyTGV0dGVyQ2FzZSh2YWx1ZSkge1xuICAgIHJldHVybiBhc1N0cmluZyh2YWx1ZSkucmVwbGFjZSgvKF98XFxiKVxcdy9nLCBzdHJVcHBlcik7XG59XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIHN0ckNhbWVsQ2FzZSh2YWx1ZSwgdXBwZXJGaXJzdCkge1xuICAgIHZhciByZXN1bHQgPSBfY29udmVydENhc2UodmFsdWUsIFwiXCIsIHRydWUpO1xuICAgIHJldHVybiByZXN1bHQucmVwbGFjZSgvXlxcdy8sIHVwcGVyRmlyc3QgPyBzdHJVcHBlciA6IHN0ckxvd2VyKTtcbn1cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gc3RyS2ViYWJDYXNlKHZhbHVlLCBzY3JlYW0pIHtcbiAgICB2YXIgcmVzdWx0ID0gX2NvbnZlcnRDYXNlKHZhbHVlLCBcIi1cIik7XG4gICAgcmV0dXJuIChzY3JlYW0gPyBzdHJVcHBlciA6IHN0ckxvd2VyKShyZXN1bHQpO1xufVxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBzdHJTbmFrZUNhc2UodmFsdWUsIHNjcmVhbSkge1xuICAgIHZhciByZXN1bHQgPSBfY29udmVydENhc2UodmFsdWUsIFwiX1wiKTtcbiAgICByZXR1cm4gKHNjcmVhbSA/IHN0clVwcGVyIDogc3RyTG93ZXIpKHJlc3VsdCk7XG59XG5cbnZhciBtYXRoRmxvb3IgPSAoIC8qI19fUFVSRV9fKi9fcHVyZVJlZihNYXRoQ2xzLCBcImZsb29yXCIpKTtcbnZhciBtYXRoQ2VpbCA9ICggLyojX19QVVJFX18qL19wdXJlUmVmKE1hdGhDbHMsIFwiY2VpbFwiKSk7XG5cbnZhciBtYXRoVHJ1bmMgPSAoIC8qICNfX1BVUkVfXyovX3B1cmVBc3NpZ24oKCAvKiAjX19QVVJFX18qL19wdXJlUmVmKE1hdGhDbHMsIFwidHJ1bmNcIikpLCBwb2x5TWF0aFRydW5jKSk7XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIHBvbHlNYXRoVHJ1bmModmFsdWUpIHtcbiAgICB2YXIgdGhlVmFsdWUgPSArdmFsdWU7XG4gICAgcmV0dXJuICh0aGVWYWx1ZSA+IDAgPyBtYXRoRmxvb3IgOiBtYXRoQ2VpbCkodGhlVmFsdWUpO1xufVxuXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIG1hdGhUb0ludCh2YWx1ZSwgdGhyb3dJbmZpbml0eSkge1xuICAgIHZhciByZXN1bHQgPSArdmFsdWU7XG4gICAgaWYgKHRocm93SW5maW5pdHkgJiYgKHJlc3VsdCA9PT0gSW5maW5pdHkgfHwgcmVzdWx0ID09IEluZmluaXR5KSkge1xuICAgICAgICB0aHJvd1JhbmdlRXJyb3IoXCJpbnZhbGlkIHZhbHVlIFtcIiArIGR1bXBPYmoodmFsdWUpICsgXCJdXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0ICE9PSByZXN1bHQgfHwgcmVzdWx0ID09PSAwID8gMCA6IG1hdGhUcnVuYyhyZXN1bHQpO1xufVxuXG52YXIgc3RyUmVwZWF0ID0gKCAvKiNfX1BVUkVfXyovX3Vud3JhcEZ1bmN0aW9uV2l0aFBvbHkoXCJyZXBlYXRcIiwgU3RyUHJvdG8sIHBvbHlTdHJSZXBlYXQpKTtcbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gcG9seVN0clJlcGVhdCh2YWx1ZSwgY291bnQpIHtcbiAgICBfdGhyb3dJZk51bGxPclVuZGVmaW5lZCh2YWx1ZSk7XG4gICAgY291bnQgPSBtYXRoVG9JbnQoY291bnQsIHRydWUpO1xuICAgIGlmIChjb3VudCA8IDApIHtcbiAgICAgICAgdGhyb3dSYW5nZUVycm9yKFwiaW52YWxpZCBjb3VudCBtdXN0IGJlID49IDAgJiYgPCBJbmZpbml0eVwiKTtcbiAgICB9XG4gICAgdmFyIHBhZCA9IGlzU3RyaW5nKHZhbHVlKSA/IHZhbHVlIDogYXNTdHJpbmcodmFsdWUpO1xuICAgIHZhciByZXN1bHQgPSBFTVBUWTtcbiAgICBmb3IgKDsgY291bnQgPiAwOyAoY291bnQgPj4+PSAxKSAmJiAocGFkICs9IHBhZCkpIHtcbiAgICAgICAgaWYgKGNvdW50ICYgMSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHBhZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIF9wYWRWYWx1ZSh2YWx1ZSwgdGFyZ2V0TGVuZ3RoLCBwYWRTdHJpbmcpIHtcbiAgICB2YXIgcmVzdWx0ID0gRU1QVFk7XG4gICAgdGFyZ2V0TGVuZ3RoID0gbWF0aFRvSW50KHRhcmdldExlbmd0aCwgdHJ1ZSk7XG4gICAgdGFyZ2V0TGVuZ3RoID4+PSAwO1xuICAgIHZhciBsZW4gPSB2YWx1ZVtMRU5HVEhdO1xuICAgIGlmIChsZW4gPCB0YXJnZXRMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0ID0gaXNOdWxsT3JVbmRlZmluZWQocGFkU3RyaW5nKSA/IFwiIFwiIDogYXNTdHJpbmcocGFkU3RyaW5nKTtcbiAgICAgICAgdGFyZ2V0TGVuZ3RoID0gdGFyZ2V0TGVuZ3RoIC0gbGVuO1xuICAgICAgICBpZiAodGFyZ2V0TGVuZ3RoID4gcmVzdWx0W0xFTkdUSF0pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHN0clJlcGVhdChyZXN1bHQsIG1hdGhDZWlsKHRhcmdldExlbmd0aCAvIHJlc3VsdFtMRU5HVEhdKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdFtMRU5HVEhdID4gdGFyZ2V0TGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzdHJTdWJzdHJpbmcocmVzdWx0LCAwLCB0YXJnZXRMZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG52YXIgc3RyUGFkU3RhcnQgPSAoIC8qI19fUFVSRV9fKi9fdW53cmFwRnVuY3Rpb25XaXRoUG9seShcInBhZFN0YXJ0XCIsIFN0clByb3RvLCBwb2x5U3RyUGFkU3RhcnQpKTtcbnZhciBzdHJQYWRFbmQgPSAoIC8qI19fUFVSRV9fKi9fdW53cmFwRnVuY3Rpb25XaXRoUG9seShcInBhZEVuZFwiLCBTdHJQcm90bywgcG9seVN0clBhZEVuZCkpO1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBwb2x5U3RyUGFkU3RhcnQodmFsdWUsIHRhcmdldExlbmd0aCwgcGFkU3RyaW5nKSB7XG4gICAgcmV0dXJuIF9wYWRWYWx1ZSh2YWx1ZSwgdGFyZ2V0TGVuZ3RoLCBwYWRTdHJpbmcpICsgdmFsdWU7XG59XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIHBvbHlTdHJQYWRFbmQodmFsdWUsIHRhcmdldExlbmd0aCwgcGFkU3RyaW5nKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgX3BhZFZhbHVlKHZhbHVlLCB0YXJnZXRMZW5ndGgsIHBhZFN0cmluZyk7XG59XG5cbnZhciBEQkxfUVVPVEUgPSBcIlxcXCJcIjtcbnZhciBJTlZBTElEX0pTX05BTUUgPSAvKFteXFx3XFxkXyRdKS9nO1xudmFyIF9odG1sRW50aXR5Q2FjaGU7XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUpzTmFtZShqc05hbWUsIGNhbWVsQ2FzZSkge1xuICAgIHZhciByZXN1bHQgPSBhc1N0cmluZyhqc05hbWUpLnJlcGxhY2UoSU5WQUxJRF9KU19OQU1FLCBcIl9cIik7XG4gICAgcmV0dXJuICFpc1VuZGVmaW5lZChjYW1lbENhc2UpID8gc3RyQ2FtZWxDYXNlKHJlc3VsdCwgIWNhbWVsQ2FzZSkgOiByZXN1bHQ7XG59XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIGVuY29kZUFzSnNvbih2YWx1ZSwgZm9ybWF0KSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdCA9IERCTF9RVU9URSArIHZhbHVlLnJlcGxhY2UoL1teXFx3IC4sXFwtIUAjJCVcXF4mKlxcKFxcKV8rPXt9XFxbXFxdOjt8PD4/XS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCA9PT0gREJMX1FVT1RFIHx8IG1hdGNoID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlxcXFxcIiArIG1hdGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhleCA9IG1hdGNoLmNoYXJDb2RlQXQoMClbVE9fU1RSSU5HXSgxNik7XG4gICAgICAgICAgICByZXR1cm4gXCJcXFxcdVwiICsgc3RyUGFkU3RhcnQoc3RyVXBwZXIoaGV4KSwgNCwgXCIwXCIpO1xuICAgICAgICB9KSArIERCTF9RVU9URTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgTlVMTF9WQUxVRSwgZm9ybWF0ID8gKGlzTnVtYmVyKGZvcm1hdCkgPyBmb3JtYXQgOiA0KSA6IFVOREVGX1ZBTFVFKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gREJMX1FVT1RFICsgZHVtcE9iaihlKSArIERCTF9RVU9URTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBlbmNvZGVBc0h0bWwodmFsdWUpIHtcbiAgICAhX2h0bWxFbnRpdHlDYWNoZSAmJiAoX2h0bWxFbnRpdHlDYWNoZSA9IHtcbiAgICAgICAgXCImXCI6IFwiYW1wXCIsXG4gICAgICAgIFwiPFwiOiBcImx0XCIsXG4gICAgICAgIFwiPlwiOiBcImd0XCIsXG4gICAgICAgIFwiXFxcIlwiOiBcInF1b3RcIixcbiAgICAgICAgXCInXCI6IFwiIzM5XCJcbiAgICB9KTtcbiAgICByZXR1cm4gYXNTdHJpbmcodmFsdWUpLnJlcGxhY2UoL1smPD5cIiddL2csIGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gXCImXCIgKyBfaHRtbEVudGl0eUNhY2hlW21hdGNoXSArIFwiO1wiOyB9KTtcbn1cblxudmFyIF9mblRvU3RyaW5nO1xudmFyIF9vYmpDdHJGblN0cmluZztcbnZhciBfZ2JsV2luZG93O1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09IE9CSkVDVCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghX2dibFdpbmRvdykge1xuICAgICAgICBfZ2JsV2luZG93ID0gaGFzV2luZG93KCkgPyBnZXRXaW5kb3coKSA6IHRydWU7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICBpZiAodmFsdWUgIT09IF9nYmxXaW5kb3cpIHtcbiAgICAgICAgaWYgKCFfb2JqQ3RyRm5TdHJpbmcpIHtcbiAgICAgICAgICAgIF9mblRvU3RyaW5nID0gRnVuY3Rpb25bUFJPVE9UWVBFXVtUT19TVFJJTkddO1xuICAgICAgICAgICAgX29iakN0ckZuU3RyaW5nID0gX2ZuVG9TdHJpbmdbQ0FMTF0oT2JqQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcHJvdG8gPSBvYmpHZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gICAgICAgICAgICByZXN1bHQgPSAhcHJvdG87XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChvYmpIYXNPd25Qcm9wZXJ0eShwcm90bywgQ09OU1RSVUNUT1IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3RvID0gcHJvdG9bQ09OU1RSVUNUT1JdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSAhIShwcm90byAmJiB0eXBlb2YgcHJvdG8gPT09IEZVTkNUSU9OICYmIF9mblRvU3RyaW5nW0NBTExdKHByb3RvKSA9PT0gX29iakN0ckZuU3RyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIF9kZWZhdWx0RGVlcENvcHlIYW5kbGVyKGRldGFpbHMpIHtcbiAgICBkZXRhaWxzLnZhbHVlICYmIHBsYWluT2JqRGVlcENvcHlIYW5kbGVyKGRldGFpbHMpO1xuICAgIHJldHVybiB0cnVlO1xufVxudmFyIGRlZmF1bHREZWVwQ29weUhhbmRsZXJzID0gW1xuICAgIGFycmF5RGVlcENvcHlIYW5kbGVyLFxuICAgIHBsYWluT2JqRGVlcENvcHlIYW5kbGVyLFxuICAgIGZ1bmN0aW9uRGVlcENvcHlIYW5kbGVyLFxuICAgIGRhdGVEZWVwQ29weUhhbmRsZXJcbl07XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIF9nZXRTZXRWaXNpdGVkKHZpc2l0TWFwLCBzb3VyY2UsIG5ld1BhdGgsIGNiKSB7XG4gICAgdmFyIHRoZUVudHJ5O1xuICAgIGFyckZvckVhY2godmlzaXRNYXAsIGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICBpZiAoZW50cnkuayA9PT0gc291cmNlKSB7XG4gICAgICAgICAgICB0aGVFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCF0aGVFbnRyeSkge1xuICAgICAgICB0aGVFbnRyeSA9IHsgazogc291cmNlLCB2OiBzb3VyY2UgfTtcbiAgICAgICAgdmlzaXRNYXAucHVzaCh0aGVFbnRyeSk7XG4gICAgICAgIGNiKHRoZUVudHJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoZUVudHJ5LnY7XG59XG5mdW5jdGlvbiBfZGVlcENvcHkodmlzaXRNYXAsIHZhbHVlLCBjdHgsIGtleSkge1xuICAgIHZhciB1c2VySGFuZGxlciA9IGN0eC5oYW5kbGVyO1xuICAgIHZhciBuZXdQYXRoID0gY3R4LnBhdGggPyAoa2V5ID8gY3R4LnBhdGguY29uY2F0KGtleSkgOiBjdHgucGF0aCkgOiBbXTtcbiAgICB2YXIgbmV3Q3R4ID0ge1xuICAgICAgICBoYW5kbGVyOiBjdHguaGFuZGxlcixcbiAgICAgICAgc3JjOiBjdHguc3JjLFxuICAgICAgICBwYXRoOiBuZXdQYXRoXG4gICAgfTtcbiAgICB2YXIgdGhlVHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICB2YXIgaXNQbGFpbiA9IGZhbHNlO1xuICAgIHZhciBpc1ByaW0gPSB2YWx1ZSA9PT0gTlVMTF9WQUxVRTtcbiAgICBpZiAoIWlzUHJpbSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgdGhlVHlwZSA9PT0gT0JKRUNUKSB7XG4gICAgICAgICAgICBpc1BsYWluID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpc1ByaW0gPSBpc1ByaW1pdGl2ZVR5cGUodGhlVHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGRldGFpbHMgPSB7XG4gICAgICAgIHR5cGU6IHRoZVR5cGUsXG4gICAgICAgIGlzUHJpbTogaXNQcmltLFxuICAgICAgICBpc1BsYWluOiBpc1BsYWluLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHJlc3VsdDogdmFsdWUsXG4gICAgICAgIHBhdGg6IG5ld1BhdGgsXG4gICAgICAgIG9yaWdpbjogY3R4LnNyYyxcbiAgICAgICAgY29weTogZnVuY3Rpb24gKHNvdXJjZSwgbmV3S2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gX2RlZXBDb3B5KHZpc2l0TWFwLCBzb3VyY2UsIG5ld0tleSA/IG5ld0N0eCA6IGN0eCwgbmV3S2V5KTtcbiAgICAgICAgfSxcbiAgICAgICAgY29weVRvOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfY29weVByb3BzKHZpc2l0TWFwLCB0YXJnZXQsIHNvdXJjZSwgbmV3Q3R4KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaWYgKCFkZXRhaWxzLmlzUHJpbSkge1xuICAgICAgICByZXR1cm4gX2dldFNldFZpc2l0ZWQodmlzaXRNYXAsIHZhbHVlLCBuZXdQYXRoLCBmdW5jdGlvbiAobmV3RW50cnkpIHtcbiAgICAgICAgICAgIG9iakRlZmluZShkZXRhaWxzLCBcInJlc3VsdFwiLCB7XG4gICAgICAgICAgICAgICAgZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3RW50cnkudjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHM6IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdFbnRyeS52ID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gdXNlckhhbmRsZXI7XG4gICAgICAgICAgICB3aGlsZSAoIShoYW5kbGVyIHx8IChpZHggPCBkZWZhdWx0RGVlcENvcHlIYW5kbGVycy5sZW5ndGggPyBkZWZhdWx0RGVlcENvcHlIYW5kbGVyc1tpZHgrK10gOiBfZGVmYXVsdERlZXBDb3B5SGFuZGxlcikpW0NBTExdKGN0eCwgZGV0YWlscykpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gTlVMTF9WQUxVRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh1c2VySGFuZGxlciAmJiB1c2VySGFuZGxlcltDQUxMXShjdHgsIGRldGFpbHMpKSB7XG4gICAgICAgIHJldHVybiBkZXRhaWxzLnJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gX2NvcHlQcm9wcyh2aXNpdE1hcCwgdGFyZ2V0LCBzb3VyY2UsIGN0eCkge1xuICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQoc291cmNlKSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IF9kZWVwQ29weSh2aXNpdE1hcCwgc291cmNlW2tleV0sIGN0eCwga2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gb2JqQ29weVByb3BzKHRhcmdldCwgc291cmNlLCBoYW5kbGVyKSB7XG4gICAgdmFyIGN0eCA9IHtcbiAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgICAgc3JjOiBzb3VyY2UsXG4gICAgICAgIHBhdGg6IFtdXG4gICAgfTtcbiAgICByZXR1cm4gX2NvcHlQcm9wcyhbXSwgdGFyZ2V0LCBzb3VyY2UsIGN0eCk7XG59XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIG9iakRlZXBDb3B5KHNvdXJjZSwgaGFuZGxlcikge1xuICAgIHZhciBjdHggPSB7XG4gICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICAgIHNyYzogc291cmNlXG4gICAgfTtcbiAgICByZXR1cm4gX2RlZXBDb3B5KFtdLCBzb3VyY2UsIGN0eCk7XG59XG5mdW5jdGlvbiBhcnJheURlZXBDb3B5SGFuZGxlcihkZXRhaWxzKSB7XG4gICAgdmFyIHZhbHVlID0gZGV0YWlscy52YWx1ZTtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGRldGFpbHMucmVzdWx0ID0gW107XG4gICAgICAgIHRhcmdldC5sZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIGRldGFpbHMuY29weVRvKHRhcmdldCwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZGF0ZURlZXBDb3B5SGFuZGxlcihkZXRhaWxzKSB7XG4gICAgdmFyIHZhbHVlID0gZGV0YWlscy52YWx1ZTtcbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICBkZXRhaWxzLnJlc3VsdCA9IG5ldyBEYXRlKHZhbHVlLmdldFRpbWUoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkRlZXBDb3B5SGFuZGxlcihkZXRhaWxzKSB7XG4gICAgaWYgKGRldGFpbHMudHlwZSA9PT0gRlVOQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHBsYWluT2JqRGVlcENvcHlIYW5kbGVyKGRldGFpbHMpIHtcbiAgICB2YXIgdmFsdWUgPSBkZXRhaWxzLnZhbHVlO1xuICAgIGlmICh2YWx1ZSAmJiBkZXRhaWxzLmlzUGxhaW4pIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGRldGFpbHMucmVzdWx0ID0ge307XG4gICAgICAgIGRldGFpbHMuY29weVRvKHRhcmdldCwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBfZG9FeHRlbmQodGFyZ2V0LCB0aGVBcmdzKSB7XG4gICAgYXJyRm9yRWFjaCh0aGVBcmdzLCBmdW5jdGlvbiAodGhlQXJnKSB7XG4gICAgICAgIG9iakNvcHlQcm9wcyh0YXJnZXQsIHRoZUFyZyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIGRlZXBFeHRlbmQodGFyZ2V0LCBvYmoxLCBvYmoyLCBvYmozLCBvYmo0LCBvYmo1LCBvYmo2KSB7XG4gICAgcmV0dXJuIF9kb0V4dGVuZChvYmpEZWVwQ29weSh0YXJnZXQpIHx8IHt9LCBBcnJTbGljZVtDQUxMXShhcmd1bWVudHMpKTtcbn1cbmZ1bmN0aW9uIG9iakV4dGVuZCh0YXJnZXQsIG9iajEsIG9iajIsIG9iajMsIG9iajQsIG9iajUsIG9iajYpIHtcbiAgICByZXR1cm4gX2RvRXh0ZW5kKHRhcmdldCB8fCB7fSwgQXJyU2xpY2VbQ0FMTF0oYXJndW1lbnRzKSk7XG59XG5cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gcG9seVN0clN5bVNwbGl0KHZhbHVlLCBzcGxpdHRlciwgbGltaXQpIHtcbiAgICB2YXIgc3BsaXRGbiA9IHNwbGl0dGVyID8gc3BsaXR0ZXJbZ2V0S25vd25TeW1ib2woOSApXSA6IFVOREVGX1ZBTFVFO1xuICAgIHJldHVybiBzcGxpdEZuID8gc3BsaXRGbih2YWx1ZSwgbGltaXQpIDogW3ZhbHVlXTtcbn1cblxudmFyIHN0clNwbGl0ID0gKCAvKiNfX1BVUkVfXyovX3Vud3JhcEZ1bmN0aW9uKFwic3BsaXRcIiwgU3RyUHJvdG8pKTtcbnZhciBzdHJTeW1TcGxpdCA9ICggLyojX19QVVJFX18qL191bndyYXBGdW5jdGlvbldpdGhQb2x5KFwic3BsaXRcIiwgU3RyUHJvdG8sIHBvbHlTdHJTeW1TcGxpdCkpO1xuXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIGdldFZhbHVlQnlLZXkodGFyZ2V0LCBwYXRoLCBkZWZWYWx1ZSkge1xuICAgIGlmICghcGF0aCB8fCAhdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBkZWZWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHBhcnRzID0gc3RyU3BsaXQocGF0aCwgXCIuXCIpO1xuICAgIHZhciBjbnQgPSBwYXJ0cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgbHAgPSAwOyBscCA8IGNudCAmJiAhaXNOdWxsT3JVbmRlZmluZWQodGFyZ2V0KTsgbHArKykge1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXRbcGFydHNbbHBdXTtcbiAgICB9XG4gICAgcmV0dXJuICghaXNOdWxsT3JVbmRlZmluZWQodGFyZ2V0KSA/IHRhcmdldCA6IGRlZlZhbHVlKTtcbn1cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gZ2V0VmFsdWVCeUl0ZXIodGFyZ2V0LCBpdGVyLCBkZWZWYWx1ZSkge1xuICAgIGlmICghaXRlciB8fCAhdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBkZWZWYWx1ZTtcbiAgICB9XG4gICAgaXRlckZvck9mKGl0ZXIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQodGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldCA9IHRhcmdldFt2YWx1ZV07XG4gICAgfSk7XG4gICAgcmV0dXJuICghaXNOdWxsT3JVbmRlZmluZWQodGFyZ2V0KSA/IHRhcmdldCA6IGRlZlZhbHVlKTtcbn1cbmZ1bmN0aW9uIHNldFZhbHVlQnlLZXkodGFyZ2V0LCBwYXRoLCB2YWx1ZSkge1xuICAgIGlmICh0YXJnZXQgJiYgcGF0aCkge1xuICAgICAgICB2YXIgcGFydHMgPSBzdHJTcGxpdChwYXRoLCBcIi5cIik7XG4gICAgICAgIHZhciBsYXN0S2V5ID0gcGFydHMucG9wKCk7XG4gICAgICAgIGFyckZvckVhY2gocGFydHMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZCh0YXJnZXRba2V5XSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0W2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICB0YXJnZXRbbGFzdEtleV0gPSB2YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRWYWx1ZUJ5SXRlcih0YXJnZXQsIGl0ZXIsIHZhbHVlKSB7XG4gICAgaWYgKHRhcmdldCAmJiBpdGVyKSB7XG4gICAgICAgIHZhciBsYXN0S2V5XzE7XG4gICAgICAgIGl0ZXJGb3JPZihpdGVyLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAobGFzdEtleV8xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHRhcmdldFtsYXN0S2V5XzFdKSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbGFzdEtleV8xXSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXRbbGFzdEtleV8xXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RLZXlfMSA9IGtleTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRhcmdldFtsYXN0S2V5XzFdID0gdmFsdWU7XG4gICAgfVxufVxuXG52YXIgZ2V0TGVuZ3RoID0gKCAvKiNfX1BVUkVfXyovX3Vud3JhcFByb3AoTEVOR1RIKSk7XG5cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gZ2V0SW50VmFsdWUodmFsdWUsIGRlZlZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIHRoZVZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmICghaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGVWYWx1ZSA9IHBhcnNlSW50KGFzU3RyaW5nKHZhbHVlKSwgMTApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpIHx8IGlzTmFOKHRoZVZhbHVlKSkgPyBkZWZWYWx1ZSA6IHRoZVZhbHVlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgIH1cbiAgICByZXR1cm4gZGVmVmFsdWU7XG59XG52YXIgaXNJbnRlZ2VyID0gKCAvKiAjX19QVVJFX18qL19wdXJlQXNzaWduKCggLyogI19fUFVSRV9fKi9fcHVyZVJlZihOdW1iZXJDbHMsIFwiaXNJbnRlZ2VyXCIpKSwgX3BvbHlOdW1iZXJJc0ludGVnZXIpKTtcbmZ1bmN0aW9uIF9wb2x5TnVtYmVySXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSAmJiAhaXNOYU4odmFsdWUpICYmXG4gICAgICAgIGlzRmluaXRlKHZhbHVlKSAmJlxuICAgICAgICBtYXRoRmxvb3IodmFsdWUpID09PSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGlzRmluaXRlTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSAmJiAhaXNOYU4odmFsdWUpICYmIGlzRmluaXRlKHZhbHVlKTtcbn1cblxudmFyIF9wZXJmO1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBoYXNQZXJmb3JtYW5jZSgpIHtcbiAgICByZXR1cm4gISFnZXRQZXJmb3JtYW5jZSgpO1xufVxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBnZXRQZXJmb3JtYW5jZSgpIHtcbiAgICAhX2dsb2JhbExhenlUZXN0SG9va3MgJiYgX2luaXRUZXN0SG9va3MoKTtcbiAgICBpZiAoIV9wZXJmIHx8IF9nbG9iYWxMYXp5VGVzdEhvb2tzLmx6eSkge1xuICAgICAgICBfcGVyZiA9IGNyZWF0ZUNhY2hlZFZhbHVlKHNhZmUoKGdldEluc3QpLCBbXCJwZXJmb3JtYW5jZVwiXSkudik7XG4gICAgfVxuICAgIHJldHVybiBfcGVyZi52O1xufVxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBwZXJmTm93KCkge1xuICAgIHZhciBwZXJmID0gZ2V0UGVyZm9ybWFuY2UoKTtcbiAgICBpZiAocGVyZiAmJiBwZXJmLm5vdykge1xuICAgICAgICByZXR1cm4gcGVyZi5ub3coKTtcbiAgICB9XG4gICAgcmV0dXJuIHV0Y05vdygpO1xufVxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBlbGFwc2VkVGltZShzdGFydFRpbWUpIHtcbiAgICByZXR1cm4gcGVyZk5vdygpIC0gc3RhcnRUaW1lO1xufVxuXG52YXIgTUFUQ0hfQU5ZID0gXCIoLiopXCI7XG52YXIgTUFUQ0hfU0lOR0xFID0gXCIoLilcIjtcbmZ1bmN0aW9uIF9jcmVhdGVSZWdFeHAodmFsdWUsIGVzY2FwZVJneCwgcmVwbGFjZUZuLCBpZ25vcmVDYXNlLCBmdWxsTWF0Y2gpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc2VjdXJpdHkvZGV0ZWN0LW5vbi1saXRlcmFsLXJlZ2V4cFxuICAgIHJldHVybiBuZXcgUmVnRXhwKChmdWxsTWF0Y2ggPyBcIl5cIiA6IEVNUFRZKSArIHJlcGxhY2VGbih2YWx1ZS5yZXBsYWNlKGVzY2FwZVJneCwgXCJcXFxcJDFcIikpICsgKGZ1bGxNYXRjaCA/IFwiJFwiIDogRU1QVFkpLCBpZ25vcmVDYXNlID8gXCJpXCIgOiBcIlwiKTtcbn1cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gY3JlYXRlV2lsZGNhcmRSZWdleCh2YWx1ZSwgaWdub3JlQ2FzZSwgZnVsbE1hdGNoKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVSZWdFeHAoYXNTdHJpbmcodmFsdWUpLCAvKFstK3xeJCNcXC5cXD97fSgpXFxbXFxdXFxcXFxcL1xcXCJcXCddKS9nLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1xcKi9nLCBNQVRDSF9BTlkpO1xuICAgIH0sICEhaWdub3JlQ2FzZSwgZnVsbE1hdGNoKTtcbn1cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gY3JlYXRlRmlsZW5hbWVSZWdleCh2YWx1ZSwgaWdub3JlQ2FzZSwgZnVsbE1hdGNoKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVSZWdFeHAoYXNTdHJpbmcodmFsdWUpLCAvKFstK3xeJCNcXC57fSgpXFxcXFxcL1xcW1xcXVxcXCJcXCddKS9nLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoLyhcXFxcXFxcXHxcXFxcXFwvfFxcKnxcXD8pL2csIGZ1bmN0aW9uIChfYWxsLCBnMSkge1xuICAgICAgICAgICAgaWYgKGcxID09IFwiXFxcXC9cIiB8fCBnMSA9PSBcIlxcXFxcXFxcXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJbXFxcXFxcXFxcXFxcL117MX1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnMSA9PSBcIipcIiA/IE1BVENIX0FOWSA6IE1BVENIX1NJTkdMRTtcbiAgICAgICAgfSk7XG4gICAgfSwgISFpZ25vcmVDYXNlLCBmdWxsTWF0Y2gpO1xufVxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBtYWtlR2xvYlJlZ2V4KHZhbHVlLCBpZ25vcmVDYXNlLCBmdWxsTWF0Y2gpIHtcbiAgICByZXR1cm4gX2NyZWF0ZVJlZ0V4cChhc1N0cmluZyh2YWx1ZSksIC8oWy0rfF4kI1xcLnt9KClcXFxcXFwvXFxbXFxdXFxcIlxcJ10pL2csIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvKFxcKlxcKlxcXFxbXFxcXFxcL118XFxcXFxcXFx8XFxcXFxcL3xcXCpcXCp8XFwqfFxcPykvZywgZnVuY3Rpb24gKF9hbGwsIGcxKSB7XG4gICAgICAgICAgICBpZiAoZzEgPT0gXCIqKlxcXFwvXCIgfHwgZzEgPT0gXCIqKlxcXFxcXFxcXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIoLipbXFxcXFxcXFxcXFxcL10pKlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGcxID09PSBcIlxcXFwvXCIgfHwgZzEgPT0gXCJcXFxcXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiW1xcXFxcXFxcXFxcXC9dezF9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZzEgPT09IFwiKipcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBNQVRDSF9BTlk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZzEgPT09IFwiKlwiID8gXCIoW15cXFxcXFxcXFxcXFwvXSopXCIgOiBcIihbXlxcXFxcXFxcXFxcXC9dezF9KVwiO1xuICAgICAgICB9KTtcbiAgICB9LCAhIWlnbm9yZUNhc2UsIGZ1bGxNYXRjaCk7XG59XG5cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gc2FmZUdldExhenkoY2IsIGRlZlZhbHVlLCBhcmdBcnJheSkge1xuICAgIHJldHVybiBnZXRMYXp5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHNhZmUoY2IsIGFyZ0FycmF5KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5lID8gZGVmVmFsdWUgOiByZXN1bHQudjtcbiAgICB9KTtcbn1cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gc2FmZUdldFdyaXRhYmxlTGF6eShjYiwgZGVmVmFsdWUsIGFyZ0FycmF5KSB7XG4gICAgcmV0dXJuIGdldFdyaXRhYmxlTGF6eShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBzYWZlKGNiLCBhcmdBcnJheSk7XG4gICAgICAgIHJldHVybiByZXN1bHQuZSA/IGRlZlZhbHVlIDogcmVzdWx0LnY7XG4gICAgfSk7XG59XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIHNhZmVHZXREZWZlcnJlZChjYiwgZGVmVmFsdWUsIGFyZ0FycmF5KSB7XG4gICAgcmV0dXJuIGdldERlZmVycmVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHNhZmUoY2IsIGFyZ0FycmF5KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5lID8gZGVmVmFsdWUgOiByZXN1bHQudjtcbiAgICB9KTtcbn1cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gc2FmZUdldFdyaXRhYmxlRGVmZXJyZWQoY2IsIGRlZlZhbHVlLCBhcmdBcnJheSkge1xuICAgIHJldHVybiBnZXRXcml0YWJsZURlZmVycmVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHNhZmUoY2IsIGFyZ0FycmF5KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5lID8gZGVmVmFsdWUgOiByZXN1bHQudjtcbiAgICB9KTtcbn1cblxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBfY2hlY2tMZW5ndGgodmFsdWUsIHByb3BzKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBhcnJGb3JFYWNoKHByb3BzLCBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICBpZiAocHJvcCBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHZhbHVlW3Byb3BdO1xuICAgICAgICAgICAgcmVzdWx0ID0gKGlzRnVuY3Rpb24ocHJvcFZhbHVlKSA/IHByb3BWYWx1ZSgpIDogcHJvcFZhbHVlKSA+IDA7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBfaGFzVmFsdWUodmFsdWUsIGRlcHRoKSB7XG4gICAgdmFyIHJlc3VsdCA9IHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gMDtcbiAgICBpZiAoIXJlc3VsdCAmJiAhaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWVbTEVOR1RIXSA+IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gIWlzTmFOKHZhbHVlLmdldFRpbWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNCb29sZWFuKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBjaGtWYWx1ZSA9IF9jaGVja0xlbmd0aCh2YWx1ZSwgW0xFTkdUSCwgXCJieXRlTGVuZ3RoXCIsIFwic2l6ZVwiLCBcImNvdW50XCJdKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNCb29sZWFuKGNoa1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hrVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlLnZhbHVlT2YpICYmIGRlcHRoIDwgNSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2hhc1ZhbHVlKHZhbHVlLnZhbHVlT2YoKSwgKytkZXB0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhIW9iaktleXModmFsdWUpW0xFTkdUSF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpc1RydXRoeSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gaGFzVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gX2hhc1ZhbHVlKHZhbHVlLCAwKTtcbn1cblxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBjcmVhdGVJdGVyYWJsZShjdHgpIHtcbiAgICByZXR1cm4gbWFrZUl0ZXJhYmxlKHt9LCBjdHgpO1xufVxuZnVuY3Rpb24gbWFrZUl0ZXJhYmxlKHRhcmdldCwgY3R4KSB7XG4gICAgdmFyIGl0U3ltYm9sID0gZ2V0S25vd25TeW1ib2woMyApO1xuICAgIGZ1bmN0aW9uIF9jcmVhdGVJdGVyYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUl0ZXJhdG9yKGN0eCk7XG4gICAgfVxuICAgIHRhcmdldFtpdFN5bWJvbF0gPSBfY3JlYXRlSXRlcmF0b3I7XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gY3JlYXRlSXRlcmF0b3IoY3R4KSB7XG4gICAgdmFyIGlzRG9uZSA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIF92YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIGN0eC52O1xuICAgIH1cbiAgICBmdW5jdGlvbiBfbmV4dCgpIHtcbiAgICAgICAgaWYgKCFpc0RvbmUpIHtcbiAgICAgICAgICAgIGlzRG9uZSA9IChjdHgubiA/IGN0eC5uKGFyZ3VtZW50cykgOiB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgZG9uZTogaXNEb25lXG4gICAgICAgIH07XG4gICAgICAgIGlmICghaXNEb25lKSB7XG4gICAgICAgICAgICBvYmpEZWZpbmUocmVzdWx0LCBcInZhbHVlXCIsIHsgZzogX3ZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9yZXR1cm4odmFsdWUpIHtcbiAgICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogY3R4LnIgJiYgY3R4LnIodmFsdWUpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIF90aHJvdyhlKSB7XG4gICAgICAgIGlzRG9uZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGN0eC50ICYmIGN0eC50KGUpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciB0aGVJdGVyYXRvciA9IHtcbiAgICAgICAgbmV4dDogX25leHRcbiAgICB9O1xuICAgIGlmIChjdHgucikge1xuICAgICAgICB0aGVJdGVyYXRvci5yZXR1cm4gPSBfcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY3R4LnQpIHtcbiAgICAgICAgdGhlSXRlcmF0b3IudGhyb3cgPSBfdGhyb3c7XG4gICAgfVxuICAgIHJldHVybiB0aGVJdGVyYXRvcjtcbn1cblxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBjcmVhdGVBcnJheUl0ZXJhdG9yKHZhbHVlcykge1xuICAgIHZhciBpZHggPSAtMTtcbiAgICB2YXIgdGhlVmFsdWVzID0gdmFsdWVzID8gdmFsdWVzLnNsaWNlKCkgOiBbXTtcbiAgICB2YXIgbGVuID0gdGhlVmFsdWVzW0xFTkdUSF07XG4gICAgZnVuY3Rpb24gX3ZhbHVlKCkge1xuICAgICAgICBpZiAoaWR4ID49IDAgJiYgaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhlVmFsdWVzW2lkeF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gX2dldE5leHQoKSB7XG4gICAgICAgIGlkeCsrO1xuICAgICAgICByZXR1cm4gaWR4ID49IGxlbjtcbiAgICB9XG4gICAgdmFyIGN0eCA9IHtcbiAgICAgICAgbjogX2dldE5leHRcbiAgICB9O1xuICAgIG9iakRlZmluZShjdHgsIFwidlwiLCB7IGc6IF92YWx1ZSB9KTtcbiAgICByZXR1cm4gY3JlYXRlSXRlcmF0b3IoY3R4KTtcbn1cblxuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBjcmVhdGVSYW5nZUl0ZXJhdG9yKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICB2YXIgbmV4dFZhbHVlID0gc3RhcnQ7XG4gICAgdmFyIHRoZVZhbHVlID0gVU5ERUZfVkFMVUU7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKGVuZCkpIHtcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgfVxuICAgIHZhciB0aGVTdGVwID0gc3RlcDtcbiAgICBpZiAoIXRoZVN0ZXApIHtcbiAgICAgICAgdGhlU3RlcCA9IChzdGFydCA8PSBlbmQpID8gMSA6IC0xO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGVWYWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2dldE5leHQoKSB7XG4gICAgICAgIHZhciBpc0RvbmUgPSAodGhlU3RlcCA+IDApID8gKG5leHRWYWx1ZSA+IGVuZCkgOiAobmV4dFZhbHVlIDwgZW5kKTtcbiAgICAgICAgaWYgKCFpc0RvbmUpIHtcbiAgICAgICAgICAgIHRoZVZhbHVlID0gbmV4dFZhbHVlO1xuICAgICAgICAgICAgbmV4dFZhbHVlICs9IHRoZVN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzRG9uZTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUl0ZXJhdG9yKG9iakRlZmluZSh7XG4gICAgICAgIG46IF9nZXROZXh0XG4gICAgfSwgXCJ2XCIsIHsgZzogX3ZhbHVlIH0pKTtcbn1cblxudmFyIG1hdGhBYnMgPSAoIC8qI19fUFVSRV9fKi9fcHVyZVJlZihNYXRoQ2xzLCBcImFic1wiKSk7XG5cbnZhciBtYXRoRXhwID0gKCAvKiNfX1BVUkVfXyovX3B1cmVSZWYoTWF0aENscywgXCJleHBcIikpO1xudmFyIG1hdGhMb2cgPSAoIC8qI19fUFVSRV9fKi9fcHVyZVJlZihNYXRoQ2xzLCBcImxvZ1wiKSk7XG5cbnZhciBtYXRoQXNpbiA9ICggLyojX19QVVJFX18qL19wdXJlUmVmKE1hdGhDbHMsIFwiYXNpblwiKSk7XG52YXIgbWF0aEFjb3MgPSAoIC8qI19fUFVSRV9fKi9fcHVyZVJlZihNYXRoQ2xzLCBcImFjb3NcIikpO1xudmFyIG1hdGhBdGFuID0gKCAvKiNfX1BVUkVfXyovX3B1cmVSZWYoTWF0aENscywgXCJhdGFuXCIpKTtcbnZhciBtYXRoQXRhbjIgPSAoIC8qI19fUFVSRV9fKi9fcHVyZVJlZihNYXRoQ2xzLCBcImF0YW4yXCIpKTtcblxudmFyIG1hdGhQb3cgPSAoIC8qI19fUFVSRV9fKi9fcHVyZVJlZihNYXRoQ2xzLCBcInBvd1wiKSk7XG52YXIgbWF0aFNxcnQgPSAoIC8qI19fUFVSRV9fKi9fcHVyZVJlZihNYXRoQ2xzLCBcInNxcnRcIikpO1xuXG52YXIgbWF0aFJvdW5kID0gKCAvKiNfX1BVUkVfXyovX3B1cmVSZWYoTWF0aENscywgXCJyb3VuZFwiKSk7XG5cbnZhciBtYXRoU2luID0gKCAvKiNfX1BVUkVfXyovX3B1cmVSZWYoTWF0aENscywgXCJzaW5cIikpO1xudmFyIG1hdGhDb3MgPSAoIC8qI19fUFVSRV9fKi9fcHVyZVJlZihNYXRoQ2xzLCBcImNvc1wiKSk7XG52YXIgbWF0aFRhbiA9ICggLyojX19QVVJFX18qL19wdXJlUmVmKE1hdGhDbHMsIFwidGFuXCIpKTtcblxudmFyIF9yZWN1cnNpb25DaGVja093bkRlc2NyaXB0b3JzO1xudmFyIF9yZWN1cnNpb25DaGVja093blN5bWJvbHM7XG52YXIgX29iakdldE93blByb3BlcnR5TmFtZXMgPSAoIC8qICNfX1BVUkVfXyAqL19wdXJlQXNzaWduKCggLyogI19fUFVSRV9fICovX3B1cmVSZWYoT2JqQ2xhc3MsIEdFVF9PV05fUFJPUEVSVFlfTkFNRVMpKSwgX3JldHVybkVtcHR5QXJyYXkpKTtcbnZhciBfb2JqR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gKCAvKiAjX19QVVJFX18gKi9fcHVyZUFzc2lnbigoIC8qICNfX1BVUkVfXyAqL19wdXJlUmVmKE9iakNsYXNzLCBHRVRfT1dOX1BST1BFUlRZX0RFU0NSSVBUT1IpKSwgX3JldHVybk5vdGhpbmcpKTtcbmZ1bmN0aW9uIHBvbHlPYmpHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBfdGhyb3dJZk51bGxPclVuZGVmaW5lZChvYmopO1xuICAgIGlmICghX3JlY3Vyc2lvbkNoZWNrT3duRGVzY3JpcHRvcnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIF9yZWN1cnNpb25DaGVja093bkRlc2NyaXB0b3JzID0gdHJ1ZTtcbiAgICAgICAgICAgIGFyckZvckVhY2goX29iakdldE93blByb3BlcnR5TmFtZXMob2JqKSwgZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBfb2JqR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BOYW1lXSA9IGRlc2NyaXB0b3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhcnJGb3JFYWNoKF9wb2x5T2JqR2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaiksIGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IF9vYmpHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBzeW0pO1xuICAgICAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3N5bV0gPSBkZXNjcmlwdG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgX3JlY3Vyc2lvbkNoZWNrT3duRGVzY3JpcHRvcnMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX3BvbHlPYmpHZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBvYmpIYXNPd24gPSBPYmpDbGFzcy5oYXNPd24gfHwgcG9seU9iakhhc093bjtcbiAgICBpZiAoIV9yZWN1cnNpb25DaGVja093blN5bWJvbHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIF9yZWN1cnNpb25DaGVja093blN5bWJvbHMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHN5bUVudW0gPSAwIDtcbiAgICAgICAgICAgIHdoaWxlIChzeW1FbnVtIDw9IDEyICkge1xuICAgICAgICAgICAgICAgIHZhciBzeW0gPSBnZXRLbm93blN5bWJvbChzeW1FbnVtKTtcbiAgICAgICAgICAgICAgICBpZiAoc3ltICYmIG9iakhhc093bihvYmosIHN5bSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3ltKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3ltRW51bSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgX3JlY3Vyc2lvbkNoZWNrT3duU3ltYm9scyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBvYmpHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSAoIC8qI19fUFVSRV9fKi9fcHVyZUFzc2lnbigoIC8qI19fUFVSRV9fKi9fcHVyZVJlZihPYmpDbGFzcywgR0VUX09XTl9QUk9QRVJUWV9ERVNDUklQVE9SKSksIF9yZXR1cm5Ob3RoaW5nKSk7XG52YXIgb2JqR2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA9ICggLyojX19QVVJFX18qL19wdXJlQXNzaWduKCggLyojX19QVVJFX18qL19wdXJlUmVmKE9iakNsYXNzLCBcImdldE93blByb3BlcnR5RGVzY3JpcHRvcnNcIikpLCBwb2x5T2JqR2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykpO1xudmFyIG9iakdldE93blByb3BlcnR5TmFtZXMgPSAoIC8qI19fUFVSRV9fKi9fcHVyZUFzc2lnbigoIC8qI19fUFVSRV9fKi9fcHVyZVJlZihPYmpDbGFzcywgR0VUX09XTl9QUk9QRVJUWV9OQU1FUykpLCBfcmV0dXJuRW1wdHlBcnJheSkpO1xudmFyIG9iakdldE93blByb3BlcnR5U3ltYm9scyA9ICggLyogI19fUFVSRV9fKi9fcHVyZUFzc2lnbigoIC8qICNfX1BVUkVfXyAqL19wdXJlUmVmKE9iakNsYXNzLCBHRVRfT1dOX1BST1BFUlRZX1NZTUJPTFMpKSwgX3JldHVybkVtcHR5QXJyYXkpKTtcblxuZnVuY3Rpb24gcG9seU9iakZyb21FbnRyaWVzKGVudHJpZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZnVuY3Rpb24gYWRkRW50cnkoZW50cnkpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkoZW50cnkpICYmIGVudHJ5Lmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICByZXN1bHRbZW50cnlbMF1dID0gZW50cnlbMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzQXJyYXkoZW50cmllcykpIHtcbiAgICAgICAgYXJyRm9yRWFjaChlbnRyaWVzLCBhZGRFbnRyeSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzSXRlcmFibGUoZW50cmllcykpIHtcbiAgICAgICAgaXRlckZvck9mKGVudHJpZXMsIGFkZEVudHJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIG9iakZyb21FbnRyaWVzID0gKCAvKiNfX1BVUkVfXyovX3B1cmVBc3NpZ24oKCAvKiNfX1BVUkVfXyovX3B1cmVSZWYoT2JqQ2xhc3MsIFwiZnJvbUVudHJpZXNcIikpLCBwb2x5T2JqRnJvbUVudHJpZXMpKTtcblxudmFyIG9ialByZXZlbnRFeHRlbnNpb25zID0gKCAvKiNfX1BVUkVfXyovX3B1cmVBc3NpZ24oKCAvKiNfX1BVUkVfXyovX3B1cmVSZWYoT2JqQ2xhc3MsIFwicHJldmVudEV4dGVuc2lvbnNcIikpLCBfZG9Ob3RoaW5nKSk7XG52YXIgb2JqSXNFeHRlbnNpYmxlID0gKCAvKiNfX1BVUkVfXyovX3B1cmVBc3NpZ24oKCAvKiNfX1BVUkVfXyovX3B1cmVSZWYoT2JqQ2xhc3MsIFwiaXNFeHRlbnNpYmxlXCIpKSwgX3JldHVybkZhbHNlKSk7XG5cbnZhciBzdHJFbmRzV2l0aCA9ICggLyojX19QVVJFX18qL191bndyYXBGdW5jdGlvbldpdGhQb2x5KFwiZW5kc1dpdGhcIiwgU3RyUHJvdG8sIHBvbHlTdHJFbmRzV2l0aCkpO1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBwb2x5U3RyRW5kc1dpdGgodmFsdWUsIHNlYXJjaFN0cmluZywgbGVuZ3RoKSB7XG4gICAgX3Rocm93SWZOb3RTdHJpbmcodmFsdWUpO1xuICAgIHZhciBzZWFyY2hWYWx1ZSA9IGlzU3RyaW5nKHNlYXJjaFN0cmluZykgPyBzZWFyY2hTdHJpbmcgOiBhc1N0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgIHZhciBlbmQgPSAoIWlzVW5kZWZpbmVkKGxlbmd0aCkgJiYgbGVuZ3RoIDwgdmFsdWVbTEVOR1RIXSkgPyBsZW5ndGggOiB2YWx1ZVtMRU5HVEhdO1xuICAgIHJldHVybiBzdHJTdWJzdHJpbmcodmFsdWUsIGVuZCAtIHNlYXJjaFZhbHVlW0xFTkdUSF0sIGVuZCkgPT09IHNlYXJjaFZhbHVlO1xufVxuXG52YXIgc3RySW5kZXhPZiA9ICggLyojX19QVVJFX18qL191bndyYXBGdW5jdGlvbihcImluZGV4T2ZcIiwgU3RyUHJvdG8pKTtcbnZhciBzdHJMYXN0SW5kZXhPZiA9ICggLyojX19QVVJFX18qL191bndyYXBGdW5jdGlvbihcImxhc3RJbmRleE9mXCIsIFN0clByb3RvKSk7XG5cbnZhciBzdHJJbmNsdWRlcyA9ICggLyojX19QVVJFX18qL191bndyYXBGdW5jdGlvbldpdGhQb2x5KFwiaW5jbHVkZXNcIiwgU3RyUHJvdG8sIHBvbHlTdHJJbmNsdWRlcykpO1xudmFyIHN0ckNvbnRhaW5zID0gKCAvKiNfX1BVUkVfXyovX3B1cmVBc3NpZ24oc3RySW5jbHVkZXMpKTtcbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gcG9seVN0ckluY2x1ZGVzKHZhbHVlLCBzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XG4gICAgaWYgKGlzUmVnRXhwKHNlYXJjaFN0cmluZykpIHtcbiAgICAgICAgdGhyb3dUeXBlRXJyb3IoXCInc2VhcmNoU3RyaW5nJyBtdXN0IG5vdCBiZSBhIHJlZ3VsYXIgZXhwcmVzc2lvblwiICsgZHVtcE9iaihzZWFyY2hTdHJpbmcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0ckluZGV4T2YodmFsdWUsIGFzU3RyaW5nKHNlYXJjaFN0cmluZyksIHBvc2l0aW9uKSAhPT0gLTE7XG59XG5cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gc3RySXNOdWxsT3JXaGl0ZVNwYWNlKHZhbHVlKSB7XG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvW1xcc1xcdFxcclxcblxcZl0rL2csIEVNUFRZKSA9PT0gRU1QVFk7XG4gICAgfVxuICAgIHJldHVybiBpc051bGxPclVuZGVmaW5lZCh2YWx1ZSk7XG59XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIHN0cklzTnVsbE9yRW1wdHkodmFsdWUpIHtcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gRU1QVFk7XG4gICAgfVxuICAgIHJldHVybiBpc051bGxPclVuZGVmaW5lZCh2YWx1ZSk7XG59XG5cbnZhciBzdHJTdGFydHNXaXRoID0gKCAvKiNfX1BVUkVfXyovX3Vud3JhcEZ1bmN0aW9uV2l0aFBvbHkoXCJzdGFydHNXaXRoXCIsIFN0clByb3RvLCBwb2x5U3RyU3RhcnRzV2l0aCkpO1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBwb2x5U3RyU3RhcnRzV2l0aCh2YWx1ZSwgc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikge1xuICAgIF90aHJvd0lmTm90U3RyaW5nKHZhbHVlKTtcbiAgICB2YXIgc2VhcmNoVmFsdWUgPSBpc1N0cmluZyhzZWFyY2hTdHJpbmcpID8gc2VhcmNoU3RyaW5nIDogYXNTdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICB2YXIgcG9zID0gcG9zaXRpb24gPiAwID8gcG9zaXRpb24gOiAwO1xuICAgIHJldHVybiBzdHJTdWJzdHJpbmcodmFsdWUsIHBvcywgcG9zICsgc2VhcmNoVmFsdWVbTEVOR1RIXSkgPT09IHNlYXJjaFZhbHVlO1xufVxuXG52YXIgUkVGID0gXCJyZWZcIjtcbnZhciBVTlJFRiA9IFwidW5yZWZcIjtcbnZhciBIQVNfUkVGID0gXCJoYXNSZWZcIjtcbnZhciBFTkFCTEVEID0gXCJlbmFibGVkXCI7XG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIF9jcmVhdGVUaW1lckhhbmRsZXIoc3RhcnRUaW1lciwgcmVmcmVzaEZuLCBjYW5jZWxGbikge1xuICAgIHZhciByZWYgPSB0cnVlO1xuICAgIHZhciB0aW1lcklkID0gc3RhcnRUaW1lciA/IHJlZnJlc2hGbihOVUxMX1ZBTFVFKSA6IE5VTExfVkFMVUU7XG4gICAgdmFyIHRoZVRpbWVySGFuZGxlcjtcbiAgICBmdW5jdGlvbiBfdW5yZWYoKSB7XG4gICAgICAgIHJlZiA9IGZhbHNlO1xuICAgICAgICB0aW1lcklkICYmIHRpbWVySWRbVU5SRUZdICYmIHRpbWVySWRbVU5SRUZdKCk7XG4gICAgICAgIHJldHVybiB0aGVUaW1lckhhbmRsZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9jYW5jZWwoKSB7XG4gICAgICAgIHRpbWVySWQgJiYgY2FuY2VsRm4odGltZXJJZCk7XG4gICAgICAgIHRpbWVySWQgPSBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfcmVmcmVzaCgpIHtcbiAgICAgICAgdGltZXJJZCA9IHJlZnJlc2hGbih0aW1lcklkKTtcbiAgICAgICAgaWYgKCFyZWYpIHtcbiAgICAgICAgICAgIF91bnJlZigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGVUaW1lckhhbmRsZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9zZXRFbmFibGVkKHZhbHVlKSB7XG4gICAgICAgICF2YWx1ZSAmJiB0aW1lcklkICYmIF9jYW5jZWwoKTtcbiAgICAgICAgdmFsdWUgJiYgIXRpbWVySWQgJiYgX3JlZnJlc2goKTtcbiAgICB9XG4gICAgdGhlVGltZXJIYW5kbGVyID0ge1xuICAgICAgICBjYW5jZWw6IF9jYW5jZWwsXG4gICAgICAgIHJlZnJlc2g6IF9yZWZyZXNoXG4gICAgfTtcbiAgICB0aGVUaW1lckhhbmRsZXJbSEFTX1JFRl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aW1lcklkICYmIHRpbWVySWRbSEFTX1JFRl0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aW1lcklkW0hBU19SRUZdKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZjtcbiAgICB9O1xuICAgIHRoZVRpbWVySGFuZGxlcltSRUZdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZWYgPSB0cnVlO1xuICAgICAgICB0aW1lcklkICYmIHRpbWVySWRbUkVGXSAmJiB0aW1lcklkW1JFRl0oKTtcbiAgICAgICAgcmV0dXJuIHRoZVRpbWVySGFuZGxlcjtcbiAgICB9O1xuICAgIHRoZVRpbWVySGFuZGxlcltVTlJFRl0gPSBfdW5yZWY7XG4gICAgdGhlVGltZXJIYW5kbGVyID0gb2JqRGVmaW5lUHJvcCh0aGVUaW1lckhhbmRsZXIsIEVOQUJMRUQsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAhIXRpbWVySWQ7IH0sXG4gICAgICAgIHNldDogX3NldEVuYWJsZWRcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBoOiB0aGVUaW1lckhhbmRsZXIsXG4gICAgICAgIGRuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aW1lcklkID0gTlVMTF9WQUxVRTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbnZhciBfc2V0VGltZW91dEZuO1xudmFyIF9jbGVhclRpbWVvdXRGbjtcbmZ1bmN0aW9uIF9yZXNvbHZlVGltZW91dEZuKHRpbWVvdXRGbikge1xuICAgIHZhciByZXN1bHQgPSBpc0Z1bmN0aW9uKHRpbWVvdXRGbikgPyB0aW1lb3V0Rm4gOiBfc2V0VGltZW91dEZuO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHZhciBnbG9iYWxPdmVycmlkZXMgPSBfZ2V0R2xvYmFsQ29uZmlnKCkudG1PdXQgfHwgW107XG4gICAgICAgIGlmIChpc0FycmF5KGdsb2JhbE92ZXJyaWRlcykgJiYgZ2xvYmFsT3ZlcnJpZGVzLmxlbmd0aCA+IDAgJiYgaXNGdW5jdGlvbihnbG9iYWxPdmVycmlkZXNbMF0pKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBnbG9iYWxPdmVycmlkZXNbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCB8fCBzZXRUaW1lb3V0O1xufVxuZnVuY3Rpb24gX3Jlc29sdmVDbGVhclRpbWVvdXRGbih0aW1lb3V0Rm4pIHtcbiAgICB2YXIgcmVzdWx0ID0gaXNGdW5jdGlvbih0aW1lb3V0Rm4pID8gdGltZW91dEZuIDogX2NsZWFyVGltZW91dEZuO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHZhciBnbG9iYWxPdmVycmlkZXMgPSBfZ2V0R2xvYmFsQ29uZmlnKCkudG1PdXQgfHwgW107XG4gICAgICAgIGlmIChpc0FycmF5KGdsb2JhbE92ZXJyaWRlcykgJiYgZ2xvYmFsT3ZlcnJpZGVzLmxlbmd0aCA+IDEgJiYgaXNGdW5jdGlvbihnbG9iYWxPdmVycmlkZXNbMV0pKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBnbG9iYWxPdmVycmlkZXNbMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCB8fCBjbGVhclRpbWVvdXQ7XG59XG5mdW5jdGlvbiBfY3JlYXRlVGltZW91dFdpdGgoc3RhcnRUaW1lciwgb3ZlcnJpZGVGbiwgdGhlQXJncykge1xuICAgIHZhciBpc0FyciA9IGlzQXJyYXkob3ZlcnJpZGVGbik7XG4gICAgdmFyIGxlbiA9IGlzQXJyID8gb3ZlcnJpZGVGbi5sZW5ndGggOiAwO1xuICAgIHZhciBzZXRGbiA9IF9yZXNvbHZlVGltZW91dEZuKGxlbiA+IDAgPyBvdmVycmlkZUZuWzBdIDogKCFpc0FyciA/IG92ZXJyaWRlRm4gOiBVTkRFRl9WQUxVRSkpO1xuICAgIHZhciBjbGVhckZuID0gX3Jlc29sdmVDbGVhclRpbWVvdXRGbihsZW4gPiAxID8gb3ZlcnJpZGVGblsxXSA6IFVOREVGX1ZBTFVFKTtcbiAgICB2YXIgdGltZXJGbiA9IHRoZUFyZ3NbMF07XG4gICAgdGhlQXJnc1swXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaGFuZGxlci5kbigpO1xuICAgICAgICBmbkFwcGx5KHRpbWVyRm4sIFVOREVGX1ZBTFVFLCBBcnJTbGljZVtDQUxMXShhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIHZhciBoYW5kbGVyID0gX2NyZWF0ZVRpbWVySGFuZGxlcihzdGFydFRpbWVyLCBmdW5jdGlvbiAodGltZXJJZCkge1xuICAgICAgICBpZiAodGltZXJJZCkge1xuICAgICAgICAgICAgaWYgKHRpbWVySWQucmVmcmVzaCkge1xuICAgICAgICAgICAgICAgIHRpbWVySWQucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aW1lcklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm5BcHBseShjbGVhckZuLCBVTkRFRl9WQUxVRSwgW3RpbWVySWRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm5BcHBseShzZXRGbiwgVU5ERUZfVkFMVUUsIHRoZUFyZ3MpO1xuICAgIH0sIGZ1bmN0aW9uICh0aW1lcklkKSB7XG4gICAgICAgIGZuQXBwbHkoY2xlYXJGbiwgVU5ERUZfVkFMVUUsIFt0aW1lcklkXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGhhbmRsZXIuaDtcbn1cbmZ1bmN0aW9uIHNldFRpbWVvdXRPdmVycmlkZXMob3ZlcnJpZGVGbikge1xuICAgIHZhciBpc0FyciA9IGlzQXJyYXkob3ZlcnJpZGVGbik7XG4gICAgdmFyIGxlbiA9IGlzQXJyID8gb3ZlcnJpZGVGbi5sZW5ndGggOiAwO1xuICAgIF9zZXRUaW1lb3V0Rm4gPSAobGVuID4gMCA/IG92ZXJyaWRlRm5bMF0gOiAoIWlzQXJyID8gb3ZlcnJpZGVGbiA6IFVOREVGX1ZBTFVFKSk7XG4gICAgX2NsZWFyVGltZW91dEZuID0gKGxlbiA+IDEgPyBvdmVycmlkZUZuWzFdIDogVU5ERUZfVkFMVUUpO1xufVxuZnVuY3Rpb24gc2V0R2xvYmFsVGltZW91dE92ZXJyaWRlcyhvdmVycmlkZUZuKSB7XG4gICAgdmFyIGlzQXJyID0gaXNBcnJheShvdmVycmlkZUZuKTtcbiAgICB2YXIgbGVuID0gaXNBcnIgPyBvdmVycmlkZUZuLmxlbmd0aCA6IDA7XG4gICAgdmFyIGdsb2JhbENmZyA9IF9nZXRHbG9iYWxDb25maWcoKTtcbiAgICBpZiAoIW92ZXJyaWRlRm4pIHtcbiAgICAgICAgZ2xvYmFsQ2ZnLnRtT3V0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2xvYmFsQ2ZnLnRtT3V0ID0gW1xuICAgICAgICAgICAgKGxlbiA+IDAgPyBvdmVycmlkZUZuWzBdIDogKCFpc0FyciA/IG92ZXJyaWRlRm4gOiBudWxsKSksXG4gICAgICAgICAgICAobGVuID4gMSA/IG92ZXJyaWRlRm5bMV0gOiBudWxsKVxuICAgICAgICBdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNjaGVkdWxlVGltZW91dChjYWxsYmFjaywgdGltZW91dCkge1xuICAgIHJldHVybiBfY3JlYXRlVGltZW91dFdpdGgodHJ1ZSwgVU5ERUZfVkFMVUUsIEFyclNsaWNlW0NBTExdKGFyZ3VtZW50cykpO1xufVxuZnVuY3Rpb24gc2NoZWR1bGVUaW1lb3V0V2l0aChvdmVycmlkZUZuLCBjYWxsYmFjaywgdGltZW91dCkge1xuICAgIHJldHVybiBfY3JlYXRlVGltZW91dFdpdGgodHJ1ZSwgb3ZlcnJpZGVGbiwgQXJyU2xpY2VbQ0FMTF0oYXJndW1lbnRzLCAxKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVUaW1lb3V0KGNhbGxiYWNrLCB0aW1lb3V0KSB7XG4gICAgcmV0dXJuIF9jcmVhdGVUaW1lb3V0V2l0aChmYWxzZSwgVU5ERUZfVkFMVUUsIEFyclNsaWNlW0NBTExdKGFyZ3VtZW50cykpO1xufVxuZnVuY3Rpb24gY3JlYXRlVGltZW91dFdpdGgob3ZlcnJpZGVGbiwgY2FsbGJhY2ssIHRpbWVvdXQpIHtcbiAgICByZXR1cm4gX2NyZWF0ZVRpbWVvdXRXaXRoKGZhbHNlLCBvdmVycmlkZUZuLCBBcnJTbGljZVtDQUxMXShhcmd1bWVudHMsIDEpKTtcbn1cblxudmFyIF9kZWZhdWx0SWRsZVRpbWVvdXQgPSAxMDA7XG52YXIgX21heEV4ZWN1dGlvblRpbWUgPSA1MDtcbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gaGFzSWRsZUNhbGxiYWNrKCkge1xuICAgIHJldHVybiAhISggLyojX19QVVJFX18qL2dldElkbGVDYWxsYmFjaygpKTtcbn1cbnZhciBnZXRJZGxlQ2FsbGJhY2sgPSAoIC8qI19fUFVSRV9fKi9fZ2V0R2xvYmFsSW5zdEZuKGdldEluc3QsIFtcInJlcXVlc3RJZGxlQ2FsbGJhY2tcIl0pKTtcbnZhciBnZXRDYW5jZWxJZGxlQ2FsbGJhY2sgPSAoIC8qI19fUFVSRV9fKi9fZ2V0R2xvYmFsSW5zdEZuKGdldEluc3QsIFtcImNhbmNlbElkbGVDYWxsYmFja1wiXSkpO1xuZnVuY3Rpb24gc2V0RGVmYXVsdElkbGVUaW1lb3V0KHRpbWVvdXQpIHtcbiAgICBfZGVmYXVsdElkbGVUaW1lb3V0ID0gdGltZW91dDtcbn1cbmZ1bmN0aW9uIHNldERlZmF1bHRNYXhFeGVjdXRpb25UaW1lKG1heFRpbWUpIHtcbiAgICBfbWF4RXhlY3V0aW9uVGltZSA9IG1heFRpbWU7XG59XG5mdW5jdGlvbiBzY2hlZHVsZUlkbGVDYWxsYmFjayhjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIF9jcmVhdGVEZWFkbGluZSh0aW1lZE91dCkge1xuICAgICAgICB2YXIgc3RhcnRUaW1lID0gcGVyZk5vdygpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlkVGltZW91dDogdGltZWRPdXQsXG4gICAgICAgICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9tYXhFeGVjdXRpb25UaW1lIC0gZWxhcHNlZFRpbWUoc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGhhc0lkbGVDYWxsYmFjaygpKSB7XG4gICAgICAgIHZhciBoYW5kbGVyXzEgPSBfY3JlYXRlVGltZXJIYW5kbGVyKHRydWUsIGZ1bmN0aW9uIChpZGxlSWQpIHtcbiAgICAgICAgICAgIGlkbGVJZCAmJiBnZXRDYW5jZWxJZGxlQ2FsbGJhY2soKShpZGxlSWQpO1xuICAgICAgICAgICAgcmV0dXJuIGdldElkbGVDYWxsYmFjaygpKGZ1bmN0aW9uIChkZWFkbGluZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJfMS5kbigpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRlYWRsaW5lIHx8IF9jcmVhdGVEZWFkbGluZShmYWxzZSkpO1xuICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChpZGxlSWQpIHtcbiAgICAgICAgICAgIGdldENhbmNlbElkbGVDYWxsYmFjaygpKGlkbGVJZCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGFuZGxlcl8xLmg7XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gKG9wdGlvbnMgfHwge30pLnRpbWVvdXQ7XG4gICAgaWYgKGlzVW5kZWZpbmVkKHRpbWVvdXQpKSB7XG4gICAgICAgIHRpbWVvdXQgPSBfZGVmYXVsdElkbGVUaW1lb3V0O1xuICAgIH1cbiAgICByZXR1cm4gc2NoZWR1bGVUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2soX2NyZWF0ZURlYWRsaW5lKHRydWUpKTtcbiAgICB9LCB0aW1lb3V0KTtcbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVJbnRlcnZhbChjYWxsYmFjaywgdGltZW91dCkge1xuICAgIHZhciB0aGVBcmd1bWVudHMgPSBBcnJTbGljZVtDQUxMXShhcmd1bWVudHMpO1xuICAgIHZhciBoYW5kbGVyID0gX2NyZWF0ZVRpbWVySGFuZGxlcih0cnVlLCBmdW5jdGlvbiAoaW50ZXJ2YWxJZCkge1xuICAgICAgICBpbnRlcnZhbElkICYmIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgICAgIHJldHVybiBmbkFwcGx5KHNldEludGVydmFsLCBVTkRFRl9WQUxVRSwgdGhlQXJndW1lbnRzKTtcbiAgICB9LCBmdW5jdGlvbiAoaW50ZXJ2YWxJZCkge1xuICAgICAgICBmbkFwcGx5KGNsZWFySW50ZXJ2YWwsIFVOREVGX1ZBTFVFLCBbaW50ZXJ2YWxJZF0pO1xuICAgIH0pO1xuICAgIHJldHVybiBoYW5kbGVyLmg7XG59XG5cbmV4cG9ydCB7IGFyckFwcGVuZCwgYXJyQ29udGFpbnMsIGFyckV2ZXJ5LCBhcnJGaWx0ZXIsIGFyckZpbmQsIGFyckZpbmRJbmRleCwgYXJyRmluZExhc3QsIGFyckZpbmRMYXN0SW5kZXgsIGFyckZvckVhY2gsIGFyckZyb20sIGFyckluY2x1ZGVzLCBhcnJJbmRleE9mLCBhcnJMYXN0SW5kZXhPZiwgYXJyTWFwLCBhcnJSZWR1Y2UsIGFyclNsaWNlLCBhcnJTb21lLCBhcnJheURlZXBDb3B5SGFuZGxlciwgYXNTdHJpbmcsIGNyZWF0ZUFycmF5SXRlcmF0b3IsIGNyZWF0ZUNhY2hlZFZhbHVlLCBjcmVhdGVDdXN0b21FcnJvciwgY3JlYXRlRGVmZXJyZWRDYWNoZWRWYWx1ZSwgY3JlYXRlRW51bSwgY3JlYXRlRW51bUtleU1hcCwgY3JlYXRlRW51bVZhbHVlTWFwLCBjcmVhdGVGaWxlbmFtZVJlZ2V4LCBjcmVhdGVGbkRlZmVycmVkUHJveHksIGNyZWF0ZUl0ZXJhYmxlLCBjcmVhdGVJdGVyYXRvciwgY3JlYXRlUHJveHlGdW5jcywgY3JlYXRlUmFuZ2VJdGVyYXRvciwgY3JlYXRlU2ltcGxlTWFwLCBjcmVhdGVUaW1lb3V0LCBjcmVhdGVUaW1lb3V0V2l0aCwgY3JlYXRlVHlwZU1hcCwgY3JlYXRlV2lsZGNhcmRSZWdleCwgZGF0ZURlZXBDb3B5SGFuZGxlciwgZGVlcEV4dGVuZCwgZHVtcE9iaiwgZWxhcHNlZFRpbWUsIGVuY29kZUFzSHRtbCwgZW5jb2RlQXNKc29uLCBmbkFwcGx5LCBmbkJpbmQsIGZuQ2FsbCwgZnVuY3Rpb25EZWVwQ29weUhhbmRsZXIsIGdldENhbmNlbElkbGVDYWxsYmFjaywgZ2V0RGVmZXJyZWQsIGdldERvY3VtZW50LCBnZXRHbG9iYWwsIGdldEhpc3RvcnksIGdldElkbGVDYWxsYmFjaywgZ2V0SW5zdCwgZ2V0SW50VmFsdWUsIGdldEtub3duU3ltYm9sLCBnZXRMYXp5LCBnZXRMZW5ndGgsIGdldE5hdmlnYXRvciwgZ2V0UGVyZm9ybWFuY2UsIGdldFN5bWJvbCwgZ2V0VmFsdWVCeUl0ZXIsIGdldFZhbHVlQnlLZXksIGdldFdpbmRvdywgZ2V0V3JpdGFibGVEZWZlcnJlZCwgZ2V0V3JpdGFibGVMYXp5LCBoYXNEb2N1bWVudCwgaGFzSGlzdG9yeSwgaGFzSWRsZUNhbGxiYWNrLCBoYXNOYXZpZ2F0b3IsIGhhc1BlcmZvcm1hbmNlLCBoYXNTeW1ib2wsIGhhc1ZhbHVlLCBoYXNXaW5kb3csIGlzQXJyYXksIGlzQXJyYXlCdWZmZXIsIGlzQXN5bmNGdW5jdGlvbiwgaXNBc3luY0dlbmVyYXRvciwgaXNCaWdJbnQsIGlzQmxvYiwgaXNCb29sZWFuLCBpc0RhdGUsIGlzRGVmaW5lZCwgaXNFbGVtZW50LCBpc0VsZW1lbnRMaWtlLCBpc0VtcHR5LCBpc0Vycm9yLCBpc0ZpbGUsIGlzRmluaXRlTnVtYmVyLCBpc0Zvcm1EYXRhLCBpc0Z1bmN0aW9uLCBpc0dlbmVyYXRvciwgaXNJbnRlZ2VyLCBpc0l0ZXJhYmxlLCBpc0l0ZXJhdG9yLCBpc01hcCwgaXNNYXBMaWtlLCBpc05vZGUsIGlzTm90VHJ1dGh5LCBpc051bGxPclVuZGVmaW5lZCwgaXNOdW1iZXIsIGlzT2JqZWN0LCBpc1BsYWluT2JqZWN0LCBpc1ByaW1pdGl2ZSwgaXNQcmltaXRpdmVUeXBlLCBpc1Byb21pc2UsIGlzUHJvbWlzZUxpa2UsIGlzUmVnRXhwLCBpc1NldCwgaXNTZXRMaWtlLCBpc1N0cmljdE51bGxPclVuZGVmaW5lZCwgaXNTdHJpY3RVbmRlZmluZWQsIGlzU3RyaW5nLCBpc1N5bWJvbCwgaXNUaGVuYWJsZSwgaXNUcnV0aHksIGlzVHlwZW9mLCBpc1VuZGVmaW5lZCwgaXNXZWFrTWFwLCBpc1dlYWtTZXQsIGlzV2ViV29ya2VyLCBpdGVyRm9yT2YsIGxhenlTYWZlR2V0SW5zdCwgbWFrZUdsb2JSZWdleCwgbWFrZUl0ZXJhYmxlLCBtYXRoQWJzLCBtYXRoQWNvcywgbWF0aEFzaW4sIG1hdGhBdGFuLCBtYXRoQXRhbjIsIG1hdGhDZWlsLCBtYXRoQ29zLCBtYXRoRXhwLCBtYXRoRmxvb3IsIG1hdGhMb2csIG1hdGhNYXgsIG1hdGhNaW4sIG1hdGhQb3csIG1hdGhSYW5kb20sIG1hdGhSb3VuZCwgbWF0aFNpbiwgbWF0aFNxcnQsIG1hdGhUYW4sIG1hdGhUb0ludCwgbWF0aFRydW5jLCBuZXdTeW1ib2wsIG5vcm1hbGl6ZUpzTmFtZSwgb2JqQXNzaWduLCBvYmpDb3B5UHJvcHMsIG9iakNyZWF0ZSwgb2JqRGVlcENvcHksIG9iakRlZXBGcmVlemUsIG9iakRlZmluZSwgb2JqRGVmaW5lQWNjZXNzb3JzLCBvYmpEZWZpbmVHZXQsIG9iakRlZmluZVByb3AsIG9iakRlZmluZVByb3BlcnRpZXMsIG9iakRlZmluZVByb3BzLCBvYmpFbnRyaWVzLCBvYmpFeHRlbmQsIG9iakZvckVhY2hLZXksIG9iakZyZWV6ZSwgb2JqRnJvbUVudHJpZXMsIG9iakdldE93blByb3BlcnR5RGVzY3JpcHRvciwgb2JqR2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycywgb2JqR2V0T3duUHJvcGVydHlOYW1lcywgb2JqR2V0T3duUHJvcGVydHlTeW1ib2xzLCBvYmpHZXRQcm90b3R5cGVPZiwgb2JqSGFzT3duLCBvYmpIYXNPd25Qcm9wZXJ0eSwgb2JqSXMsIG9iaklzRXh0ZW5zaWJsZSwgb2JqSXNGcm96ZW4sIG9iaklzU2VhbGVkLCBvYmpLZXlzLCBvYmpQcmV2ZW50RXh0ZW5zaW9ucywgb2JqUHJvcGVydHlJc0VudW1lcmFibGUsIG9ialNlYWwsIG9ialNldFByb3RvdHlwZU9mLCBvYmpUb1N0cmluZywgb2JqVmFsdWVzLCBwZXJmTm93LCBwbGFpbk9iakRlZXBDb3B5SGFuZGxlciwgcG9seUFyckZpbmQsIHBvbHlBcnJGaW5kSW5kZXgsIHBvbHlBcnJGaW5kTGFzdCwgcG9seUFyckZpbmRMYXN0SW5kZXgsIHBvbHlBcnJGcm9tLCBwb2x5QXJySW5jbHVkZXMsIHBvbHlHZXRLbm93blN5bWJvbCwgcG9seUlzQXJyYXksIHBvbHlOZXdTeW1ib2wsIHBvbHlPYmpFbnRyaWVzLCBwb2x5T2JqSGFzT3duLCBwb2x5T2JqSXMsIHBvbHlPYmpLZXlzLCBwb2x5U3RySW5jbHVkZXMsIHBvbHlTdHJTdWJzdHIsIHBvbHlTdHJTeW1TcGxpdCwgcG9seVN0clRyaW0sIHBvbHlTdHJUcmltRW5kLCBwb2x5U3RyVHJpbVN0YXJ0LCBwb2x5U3ltYm9sRm9yLCBwb2x5U3ltYm9sS2V5Rm9yLCBwb2x5VXRjTm93LCByZWFkQXJncywgc2FmZSwgc2FmZUdldCwgc2FmZUdldERlZmVycmVkLCBzYWZlR2V0TGF6eSwgc2FmZUdldFdyaXRhYmxlRGVmZXJyZWQsIHNhZmVHZXRXcml0YWJsZUxhenksIHNjaGVkdWxlSWRsZUNhbGxiYWNrLCBzY2hlZHVsZUludGVydmFsLCBzY2hlZHVsZVRpbWVvdXQsIHNjaGVkdWxlVGltZW91dFdpdGgsIHNldEJ5cGFzc0xhenlDYWNoZSwgc2V0RGVmYXVsdElkbGVUaW1lb3V0LCBzZXREZWZhdWx0TWF4RXhlY3V0aW9uVGltZSwgc2V0R2xvYmFsVGltZW91dE92ZXJyaWRlcywgc2V0VGltZW91dE92ZXJyaWRlcywgc2V0VmFsdWVCeUl0ZXIsIHNldFZhbHVlQnlLZXksIHN0ckNhbWVsQ2FzZSwgc3RyQ29udGFpbnMsIHN0ckVuZHNXaXRoLCBzdHJJbmNsdWRlcywgc3RySW5kZXhPZiwgc3RySXNOdWxsT3JFbXB0eSwgc3RySXNOdWxsT3JXaGl0ZVNwYWNlLCBzdHJLZWJhYkNhc2UsIHN0ckxhc3RJbmRleE9mLCBzdHJMZWZ0LCBzdHJMZXR0ZXJDYXNlLCBzdHJMb3dlciwgc3RyUGFkRW5kLCBzdHJQYWRTdGFydCwgc3RyUmVwZWF0LCBzdHJSaWdodCwgc3RyU2xpY2UsIHN0clNuYWtlQ2FzZSwgc3RyU3BsaXQsIHN0clN0YXJ0c1dpdGgsIHN0clN1YnN0ciwgc3RyU3Vic3RyaW5nLCBzdHJTeW1TcGxpdCwgc3RyVHJpbSwgc3RyVHJpbUVuZCwgc3RyVHJpbUxlZnQsIHN0clRyaW1SaWdodCwgc3RyVHJpbVN0YXJ0LCBzdHJVcHBlciwgc3ltYm9sRm9yLCBzeW1ib2xLZXlGb3IsIHRocm93RXJyb3IsIHRocm93UmFuZ2VFcnJvciwgdGhyb3dUeXBlRXJyb3IsIHRocm93VW5zdXBwb3J0ZWQsIHV0Y05vdyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHMtdXRpbHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nevware21/ts-utils/dist/es5/mod/ts-utils.js\n");

/***/ })

};
;
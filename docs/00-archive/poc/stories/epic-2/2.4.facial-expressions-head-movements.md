# Story 2.4: Avatar 基本表情與頭部動作

## Status
Approved

---

## Story

**As a** 開發者,
**I want** 實作 Avatar 的基本表情控制（微笑）與頭部動作（點頭），
**so that** Avatar 可以表達情緒與回應，提升互動體驗。

---

## Acceptance Criteria

1. 分析 Ready Player Me Avatar 可用的 Blendshapes 清單
2. 實作微笑表情：使用 `mouthSmile` Blendshape（值 0-1）
3. 實作點頭動作：控制頭部骨架（Head bone）的 X 軸旋轉
4. 建立 `useAvatarAnimation` Hook 的擴展，支援表情與動作控制
5. 建立測試 UI：加入「微笑」與「點頭」按鈕，點擊後觸發對應動畫
6. 動畫執行時間：微笑 0.5 秒，點頭 1 秒（一次完整點頭）
7. 動畫使用 Ease 曲線，平滑自然
8. 動畫可與待機動畫並存（不互相覆蓋）

---

## Tasks / Subtasks

- [ ] **Task 1: 分析 Avatar Blendshapes** (AC: 1)
  - [ ] 開啟 Chrome DevTools Console
  - [ ] 在 `AvatarModel` 組件的 onLoad 回調中加入除錯程式碼：
    ```typescript
    onLoad={(model) => {
      const headMesh = model.getObjectByName('Wolf3D_Head') as SkinnedMesh;
      if (headMesh?.morphTargetDictionary) {
        console.log('Available Blendshapes:', Object.keys(headMesh.morphTargetDictionary));
      }
    }}
    ```
  - [ ] 記錄所有可用的 Blendshape 名稱
  - [ ] 找出以下關鍵 Blendshapes：
    - `mouthSmile`: 微笑
    - `mouthFrown`: 皺眉
    - `eyesWide`: 睜大眼睛
    - `browInnerUp`: 揚眉
  - [ ] 建立 Blendshape 文件：
    ```typescript
    // lib/avatar/constants.ts
    export const BLENDSHAPES = {
      SMILE: 'mouthSmile',
      FROWN: 'mouthFrown',
      EYES_WIDE: 'eyesWide',
      BROW_UP: 'browInnerUp',
      EYES_CLOSED: 'eyesClosed',
    } as const;
    ```

- [ ] **Task 2: 擴展動畫工具函式** (AC: 2, 3, 6, 7)
  - [ ] 開啟 `lib/avatar/animations.ts`
  - [ ] 加入表情動畫控制器：
    ```typescript
    /**
     * 表情動畫控制器
     */
    export class ExpressionController {
      private targetValue: number = 0;
      private currentValue: number = 0;
      private animationDuration: number = 0.5;
      private startTime: number = 0;
      private isAnimating: boolean = false;

      /**
       * 觸發表情動畫
       * @param value - 目標值 (0-1)
       * @param duration - 動畫時長（秒）
       */
      trigger(value: number, duration: number = 0.5) {
        this.targetValue = value;
        this.animationDuration = duration;
        this.startTime = performance.now() / 1000;
        this.isAnimating = true;
      }

      /**
       * 更新表情值並返回當前值
       * @param currentTime - 當前時間（秒）
       * @returns 當前 Blendshape 值 (0-1)
       */
      update(currentTime: number): number {
        if (!this.isAnimating) {
          return this.currentValue;
        }

        const elapsed = currentTime - this.startTime;
        const progress = Math.min(elapsed / this.animationDuration, 1);

        // Ease-In-Out 曲線
        const easedProgress = this.easeInOutCubic(progress);
        this.currentValue = this.currentValue + (this.targetValue - this.currentValue) * easedProgress;

        if (progress >= 1) {
          this.isAnimating = false;
          this.currentValue = this.targetValue;
        }

        return this.currentValue;
      }

      private easeInOutCubic(t: number): number {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
      }
    }
    ```
  - [ ] 加入頭部動作控制器：
    ```typescript
    /**
     * 頭部點頭動畫控制器
     */
    export class HeadNodController {
      private isNodding: boolean = false;
      private nodStartTime: number = 0;
      private nodDuration: number = 1.0;

      /**
       * 觸發點頭動畫
       * @param duration - 點頭時長（秒）
       */
      trigger(duration: number = 1.0) {
        this.isNodding = true;
        this.nodStartTime = performance.now() / 1000;
        this.nodDuration = duration;
      }

      /**
       * 更新點頭動畫並返回頭部旋轉角度
       * @param currentTime - 當前時間（秒）
       * @returns X 軸旋轉角度（弧度）
       */
      update(currentTime: number): number {
        if (!this.isNodding) {
          return 0;
        }

        const elapsed = currentTime - this.nodStartTime;
        const progress = elapsed / this.nodDuration;

        if (progress >= 1) {
          this.isNodding = false;
          return 0;
        }

        // 正弦波模擬點頭（向下再向上）
        const angle = Math.sin(progress * Math.PI) * 0.3; // 最大 0.3 弧度（約17度）
        return angle;
      }
    }
    ```

- [ ] **Task 3: 擴展 useAvatarAnimation Hook** (AC: 4, 8)
  - [ ] 開啟 `components/avatar/hooks/useAvatarAnimation.ts`
  - [ ] 加入表情與頭部動作支援：
    ```typescript
    import { ExpressionController, HeadNodController } from '@/lib/avatar/animations';
    import { BLENDSHAPES } from '@/lib/avatar/constants';

    export function useAvatarAnimation(avatarRef: React.RefObject<Group>) {
      const blinkController = useRef(new BlinkController());
      const smileController = useRef(new ExpressionController());
      const headNodController = useRef(new HeadNodController());

      // 對外暴露控制函式
      const controls = {
        smile: (intensity: number = 1.0, duration: number = 0.5) => {
          smileController.current.trigger(intensity, duration);
        },
        nod: (duration: number = 1.0) => {
          headNodController.current.trigger(duration);
        },
      };

      useFrame((state) => {
        if (!avatarRef.current) return;

        const time = state.clock.getElapsedTime();

        // 1. 呼吸動畫（Story 2.3）
        // ... 保留原有程式碼

        // 2. 眨眼動畫（Story 2.3）
        // ... 保留原有程式碼

        // 3. 微笑表情動畫（新增）
        const headMesh = avatarRef.current.getObjectByName('Wolf3D_Head') as SkinnedMesh;
        if (headMesh?.morphTargetDictionary && headMesh.morphTargetInfluences) {
          const smileIndex = headMesh.morphTargetDictionary[BLENDSHAPES.SMILE];
          if (smileIndex !== undefined) {
            const smileValue = smileController.current.update(time);
            headMesh.morphTargetInfluences[smileIndex] = smileValue;
          }
        }

        // 4. 點頭動作（新增）
        const headBone = avatarRef.current.getObjectByName('Head');
        if (headBone) {
          const nodAngle = headNodController.current.update(time);
          headBone.rotation.x = nodAngle;
        }
      });

      return controls;
    }
    ```
  - [ ] 更新 Hook 回傳值型別：
    ```typescript
    // types/avatar.ts
    export interface AvatarAnimationControls {
      smile: (intensity?: number, duration?: number) => void;
      nod: (duration?: number) => void;
    }
    ```

- [ ] **Task 4: 更新 AvatarModel 組件** (AC: 4)
  - [ ] 開啟 `components/avatar/AvatarModel.tsx`
  - [ ] 修改 useAvatarAnimation 呼叫，取得控制函式：
    ```typescript
    const animationControls = useAvatarAnimation(avatarRef);

    // 透過 useImperativeHandle 暴露控制函式（供父組件使用）
    useImperativeHandle(ref, () => ({
      smile: animationControls.smile,
      nod: animationControls.nod,
    }));
    ```
  - [ ] 更新 AvatarModelProps 型別，支援 ref：
    ```typescript
    export interface AvatarModelProps {
      // ... 原有 props
    }

    export interface AvatarModelHandle {
      smile: (intensity?: number, duration?: number) => void;
      nod: (duration?: number) => void;
    }
    ```
  - [ ] 使用 forwardRef 包裝組件：
    ```typescript
    const AvatarModel = forwardRef<AvatarModelHandle, AvatarModelProps>((props, ref) => {
      // ... 組件邏輯
    });
    ```

- [ ] **Task 5: 建立測試 UI 控制面板** (AC: 5)
  - [ ] 建立 `components/avatar/AvatarControlPanel.tsx` 檔案
  - [ ] 實作控制面板 UI：
    ```typescript
    'use client';

    import { AvatarModelHandle } from './AvatarModel';

    interface AvatarControlPanelProps {
      avatarRef: React.RefObject<AvatarModelHandle>;
    }

    export default function AvatarControlPanel({ avatarRef }: AvatarControlPanelProps) {
      const handleSmile = () => {
        avatarRef.current?.smile(1.0, 0.5);
      };

      const handleNod = () => {
        avatarRef.current?.nod(1.0);
      };

      return (
        <div className="absolute bottom-8 left-1/2 -translate-x-1/2 z-10">
          <div className="bg-slate-800/80 backdrop-blur-sm border border-slate-600 rounded-lg p-4 shadow-xl">
            <h3 className="text-white text-sm font-semibold mb-3">Avatar Controls</h3>
            <div className="flex gap-3">
              <button
                onClick={handleSmile}
                className="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-md transition-colors text-sm font-medium"
              >
                😊 Smile
              </button>
              <button
                onClick={handleNod}
                className="px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded-md transition-colors text-sm font-medium"
              >
                👍 Nod
              </button>
            </div>
          </div>
        </div>
      );
    }
    ```

- [ ] **Task 6: 整合控制面板至場景** (AC: 5)
  - [ ] 開啟 `components/avatar/AvatarCanvas.tsx`
  - [ ] 建立 AvatarModel 的 ref：
    ```typescript
    import { useRef } from 'react';
    import { AvatarModelHandle } from './AvatarModel';
    import AvatarControlPanel from './AvatarControlPanel';

    export default function AvatarCanvas() {
      const avatarModelRef = useRef<AvatarModelHandle>(null);

      return (
        <div className="relative w-full h-screen">
          <Canvas>
            {/* ... 場景內容 */}
            <AvatarModel ref={avatarModelRef} modelUrl={currentAvatar} />
          </Canvas>

          <AvatarControlPanel avatarRef={avatarModelRef} />
        </div>
      );
    }
    ```

- [ ] **Task 7: 測試表情動畫** (AC: 2, 6, 7)
  - [ ] 執行 `pnpm dev`，開啟 Avatar 場景
  - [ ] 點擊「😊 Smile」按鈕
  - [ ] 驗證以下項目：
    - ✅ Avatar 嘴角向上翹起（微笑）
    - ✅ 動畫時長約 0.5 秒
    - ✅ 動畫平滑自然（Ease-In-Out 曲線）
    - ✅ 微笑後可恢復到中性表情
  - [ ] 測試不同微笑強度：
    ```typescript
    avatarRef.current?.smile(0.5, 0.5); // 淺笑
    avatarRef.current?.smile(1.0, 0.5); // 大笑
    ```
  - [ ] 使用 OrbitControls 從不同角度檢視表情
  - [ ] 記錄最佳參數值

- [ ] **Task 8: 測試點頭動畫** (AC: 3, 6, 7)
  - [ ] 點擊「👍 Nod」按鈕
  - [ ] 驗證以下項目：
    - ✅ Avatar 頭部向下點頭再回到原位
    - ✅ 動畫時長約 1 秒
    - ✅ 點頭幅度適中（約 15-20 度）
    - ✅ 動畫使用正弦波，平滑自然
  - [ ] 從側面觀察點頭動作（使用 OrbitControls）
  - [ ] 測試連續點頭：
    - 連續點擊 3 次「Nod」按鈕
    - 驗證動畫不會累加或衝突
  - [ ] 如點頭過大/過小，調整 `angle` 參數（0.2-0.4 弧度）

- [ ] **Task 9: 動畫並存測試** (AC: 8)
  - [ ] 同時觸發微笑與點頭：
    - 點擊「Smile」按鈕
    - 立即點擊「Nod」按鈕
  - [ ] 驗證以下項目：
    - ✅ 兩個動畫同時播放
    - ✅ 動畫不互相干擾
    - ✅ 待機動畫（呼吸、眨眼）持續播放
  - [ ] 測試動畫優先級：
    - 待機動畫不會覆蓋表情動畫
    - 表情動畫完成後不影響待機動畫
  - [ ] 記錄任何動畫衝突問題

---

## Dev Notes

### 相關來源樹（Source Tree）

Epic 2 Story 2.4 完成後的檔案結構：

```
avatar-chat-poc/
├── components/
│   └── avatar/
│       ├── AvatarCanvas.tsx        # 更新：整合控制面板與 ref
│       ├── AvatarModel.tsx         # 更新：forwardRef 暴露控制函式
│       ├── AvatarControlPanel.tsx  # 新增：測試 UI 控制面板
│       ├── AvatarLoadingState.tsx
│       └── hooks/
│           └── useAvatarAnimation.ts  # 更新：加入表情與頭部動作
├── lib/
│   └── avatar/
│       ├── loaders.ts
│       ├── constants.ts            # 更新：加入 BLENDSHAPES 常數
│       └── animations.ts           # 更新：加入 ExpressionController, HeadNodController
└── types/
    └── avatar.ts                   # 更新：加入 AvatarAnimationControls 型別
```

### Blendshapes 技術詳解

**Blendshapes 工作原理**:
- Blendshapes（變形目標）是預定義的頂點變形
- 每個 Blendshape 儲存一組頂點位置偏移量
- 值範圍 0-1：0 = 基礎形狀，1 = 完全變形
- 可同時混合多個 Blendshapes（如微笑 + 眨眼）

**Ready Player Me 常見 Blendshapes**:
| Blendshape 名稱 | 功能 | 值範圍 | 用途 |
|----------------|------|--------|------|
| `eyesClosed` | 閉眼 | 0-1 | 眨眼、睡眠 |
| `mouthSmile` | 微笑 | 0-1 | 愉快、友好 |
| `mouthFrown` | 皺眉 | 0-1 | 不滿、困惑 |
| `eyesWide` | 睜大眼睛 | 0-1 | 驚訝、專注 |
| `browInnerUp` | 揚眉 | 0-1 | 好奇、疑問 |
| `mouthOpen` | 張嘴 | 0-1 | 說話、驚訝 |

**Blendshape 混合數學**:
```typescript
// 單一 Blendshape
finalVertex = baseVertex + (targetVertex - baseVertex) * blendshapeValue;

// 多個 Blendshapes 混合
finalVertex = baseVertex
  + (smile_target - baseVertex) * smileValue
  + (eyesClosed_target - baseVertex) * eyesClosedValue;

// 範例：微笑 + 眨眼
smileValue = 0.8;      // 80% 微笑
eyesClosedValue = 1.0; // 100% 閉眼
結果：Avatar 閉眼微笑
```

### 表情動畫控制器設計

**為何使用 ExpressionController？**
- ✅ 統一管理表情動畫狀態
- ✅ 支援平滑過渡（Ease-In-Out）
- ✅ 可擴展支援更多表情
- ✅ 避免直接修改 Blendshape 值（更安全）

**動畫狀態機**:
```
[靜止] ---(trigger)---> [動畫中]
                           ↓
                    (duration 秒後)
                           ↓
                        [完成]
```

**Ease-In-Out Cubic 曲線**:
```typescript
// 線性變化（生硬）
value = progress;

// Ease-In-Out Cubic（平滑）
if (progress < 0.5) {
  value = 4 * progress^3;         // 加速
} else {
  value = 1 - (-2 * progress + 2)^3 / 2;  // 減速
}

// 效果比較
時間:   0%    25%    50%    75%    100%
線性:   0     0.25   0.5    0.75   1.0
Cubic:  0     0.0625 0.5    0.9375 1.0
        (慢)  (快)   (中)   (快)   (慢)
```

### 頭部點頭動畫設計

**點頭動作原理**:
- 控制 Head 骨架的 X 軸旋轉（Rotation.x）
- 正值 = 頭向下，負值 = 頭向上
- 使用正弦波模擬自然點頭（向下再向上）

**點頭數學**:
```typescript
// 正弦波公式
angle = sin(progress * π) * maxAngle;

// 參數說明
progress: 0-1（動畫進度）
π: 180度（半個週期）
maxAngle: 0.3 弧度（約 17 度）

// 效果
progress = 0.0 → angle = 0.0   (起始位置)
progress = 0.5 → angle = 0.3   (最低點，向下)
progress = 1.0 → angle = 0.0   (回到原位)
```

**為何使用正弦波？**
- ✅ 平滑的加速與減速
- ✅ 自動回到原點（無需額外處理）
- ✅ 符合人體自然動作曲線
- ✅ 數學公式簡單，效能高

**點頭幅度調校**:
| 角度（弧度） | 角度（度） | 效果 | 用途 |
|------------|----------|------|------|
| 0.2 | 11° | 微點頭 | 輕微認同 |
| 0.3 | 17° | 標準點頭 | 一般回應 |
| 0.4 | 23° | 大幅點頭 | 強烈認同 |
| 0.5 | 29° | 誇張點頭 | 戲劇化效果 |

### forwardRef 與 useImperativeHandle 說明

**為何使用 forwardRef？**
- React 預設不允許透過 ref 存取子組件
- forwardRef 允許父組件取得子組件的 ref
- 用於暴露子組件的方法給父組件

**基本用法**:
```typescript
// 子組件（AvatarModel）
const AvatarModel = forwardRef<AvatarModelHandle, AvatarModelProps>((props, ref) => {
  useImperativeHandle(ref, () => ({
    smile: () => { /* 微笑邏輯 */ },
    nod: () => { /* 點頭邏輯 */ },
  }));

  return <group>...</group>;
});

// 父組件（AvatarCanvas）
const avatarRef = useRef<AvatarModelHandle>(null);
<AvatarModel ref={avatarRef} />;
avatarRef.current?.smile();  // 呼叫子組件方法
```

**型別定義**:
```typescript
// 定義暴露的方法介面
export interface AvatarModelHandle {
  smile: (intensity?: number, duration?: number) => void;
  nod: (duration?: number) => void;
}

// Props 型別（不包含 ref）
export interface AvatarModelProps {
  modelUrl: string;
  // ...
}

// forwardRef 型別參數
// <Handle型別, Props型別>
forwardRef<AvatarModelHandle, AvatarModelProps>
```

### 動畫並存機制

**多動畫並存策略**:
1. **獨立控制器**：每個動畫使用獨立的 Controller
2. **不同作用域**：
   - 呼吸 → Spine2 節點 Scale
   - 眨眼 → eyesClosed Blendshape
   - 微笑 → mouthSmile Blendshape
   - 點頭 → Head 節點 Rotation
3. **無衝突設計**：不同動畫操作不同屬性，自然並存

**潛在衝突處理**:
```typescript
// 問題：眨眼與微笑可能同時修改臉部 Mesh
// 解決：使用不同的 Blendshapes

// 正確（無衝突）
morphTargetInfluences[eyesClosedIndex] = 1.0;  // 眨眼
morphTargetInfluences[mouthSmileIndex] = 0.8;  // 微笑

// 錯誤（衝突）
// 如果兩個動畫都修改 mouthSmile，需要動畫優先級系統
```

### 重要架構決策

1. **為何使用命令式控制（Imperative）？**
   ```typescript
   // 命令式（推薦）
   avatarRef.current?.smile();

   // 宣告式（不推薦）
   <AvatarModel isSmiling={true} />
   ```
   - ✅ 動畫觸發時機更明確
   - ✅ 避免不必要的重新渲染
   - ✅ 更符合動畫控制直覺
   - ✅ 未來整合 LLM 更容易

2. **動畫控制器設計模式**:
   - 使用 Class 封裝狀態與邏輯
   - 使用 useRef 避免重新建立
   - 提供 trigger/update 分離介面
   - 支援參數化配置（duration, intensity）

3. **測試 UI 的角色**:
   - POC 階段：驗證動畫功能
   - 開發階段：快速測試與調校
   - 正式版：可移除或保留為開發工具
   - 未來：由 LLM/情緒系統觸發動畫

4. **擴展性考量**:
   ```typescript
   // 當前設計（2個動作）
   controls = { smile, nod };

   // 未來擴展（更多表情）
   controls = {
     smile, frown, surprise, angry, sad,  // 表情
     nod, shake, tilt,                    // 頭部動作
     wave, point, thumbsUp,               // 手部動作（Epic 4+）
   };
   ```

### 測試控制面板設計

**UI 設計原則**:
- 位於場景底部，不遮擋 Avatar
- 半透明背景（backdrop-blur）保持專業感
- 按鈕使用 Emoji 增強視覺識別
- 懸浮效果（hover）提供即時回饋

**可訪問性考量**:
```typescript
<button
  onClick={handleSmile}
  aria-label="Trigger smile animation"  // 螢幕閱讀器
  className="..."
>
  😊 Smile
</button>
```

**未來擴展**:
```typescript
// 滑桿控制表情強度
<input
  type="range"
  min="0"
  max="1"
  step="0.1"
  value={smileIntensity}
  onChange={(e) => avatarRef.current?.smile(parseFloat(e.target.value))}
/>

// 表情預設組合
<button onClick={() => {
  avatarRef.current?.smile(0.8);
  avatarRef.current?.eyesWide(0.5);
}}>
  😃 Happy
</button>
```

### Testing

**測試框架**: 手動測試 + 視覺驗證 + 互動測試

**測試範圍**:
1. ✅ 可用 Blendshapes 正確識別
2. ✅ 微笑動畫正確播放
3. ✅ 點頭動畫正確播放
4. ✅ 動畫時長符合規格
5. ✅ 動畫使用 Ease 曲線
6. ✅ 動畫可與待機動畫並存
7. ✅ UI 控制面板正常運作
8. ✅ 連續觸發動畫無衝突

**測試執行方式**:
```bash
# 啟動開發伺服器
pnpm dev

# 瀏覽器開啟
http://localhost:3000

# 測試項目
1. 開啟 DevTools Console，檢視 Available Blendshapes
2. 點擊「😊 Smile」按鈕，觀察嘴角變化
3. 點擊「👍 Nod」按鈕，觀察頭部點頭
4. 使用 OrbitControls 從不同角度檢視動畫
5. 同時點擊兩個按鈕，測試並存
6. 連續點擊 5 次「Smile」，檢查是否累加
```

**驗證清單**:
- [ ] Console 顯示 Blendshapes 清單
- [ ] 微笑動畫嘴角向上翹起
- [ ] 點頭動畫頭部向下再回復
- [ ] 微笑時長約 0.5 秒
- [ ] 點頭時長約 1 秒
- [ ] 動畫平滑無抖動
- [ ] 微笑與點頭可同時播放
- [ ] 待機動畫（呼吸、眨眼）持續運作
- [ ] 控制面板按鈕可正常點擊
- [ ] Console 無錯誤訊息

### 已知問題與注意事項

**Blendshape 相容性**:
- ⚠️ 不同 Ready Player Me Avatar 可能有不同 Blendshapes
- ⚠️ 某些 Avatar 可能缺少 `mouthSmile` Blendshape
- ⚠️ Blendshape 名稱可能因模型而異

**容錯處理**:
```typescript
// 檢查 Blendshape 是否存在
const smileIndex = headMesh.morphTargetDictionary?.[BLENDSHAPES.SMILE];
if (smileIndex === undefined) {
  console.warn('mouthSmile Blendshape not found');
  return; // 跳過動畫
}
```

**動畫衝突風險**:
- 當前設計：動畫獨立，無衝突
- 未來風險：Lip Sync 可能與表情動畫衝突
- 解決方案：需要動畫優先級系統（Epic 3）

**效能影響**:
- 每個動畫控制器增加少量 CPU 成本
- 多個動畫並存不會顯著影響效能
- FPS 應保持 ≥ 30

### 效能優化建議

**優化 1: 條件更新**
```typescript
// 只在動畫中更新
if (smileController.current.isAnimating) {
  const value = smileController.current.update(time);
  morphTargetInfluences[smileIndex] = value;
}
// 靜止時跳過更新
```

**優化 2: 批次更新**
```typescript
// 一次更新多個 Blendshapes
const updates = {
  [smileIndex]: smileValue,
  [eyesClosedIndex]: blinkValue,
};
Object.entries(updates).forEach(([index, value]) => {
  morphTargetInfluences[index] = value;
});
```

**優化 3: 避免重複查找**
```typescript
// 快取 Blendshape 索引
const blendshapeIndices = useRef<Record<string, number>>({});

useEffect(() => {
  if (headMesh?.morphTargetDictionary) {
    blendshapeIndices.current = {
      smile: headMesh.morphTargetDictionary[BLENDSHAPES.SMILE],
      eyesClosed: headMesh.morphTargetDictionary[BLENDSHAPES.EYES_CLOSED],
    };
  }
}, [scene]);
```

### 依賴關係

**前置條件**:
- ✅ Story 2.1 已完成（Three.js 場景）
- ✅ Story 2.2 已完成（Avatar 模型）
- ✅ Story 2.3 已完成（待機動畫系統）
- ✅ Avatar 包含 mouthSmile Blendshape 與 Head 骨架

**後續 Story 依賴**:
- Story 2.5: 會使用相同的動畫控制機制
- Epic 3 (Lip Sync): 需要整合表情動畫系統
- Epic 4 (情緒系統): 會自動觸發表情動畫

**技術債務**:
- [ ] 未來需實作動畫優先級系統
- [ ] 未來需支援表情混合（如微笑+驚訝）
- [ ] 未來需加入動畫預設組合
- [ ] 正式版需移除或隱藏測試 UI

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-14 | 1.0 | 建立 Story 2.4 草稿 | SM Agent |

---

## Dev Agent Record

*(此部分由 Dev Agent 在實作時填寫)*

### Agent Model Used
_待填寫_

### Debug Log References
_待填寫_

### Completion Notes List
_待填寫_

### File List
_待填寫_

---

## QA Results

*(此部分由 QA Agent 在審核時填寫)*

_待填寫_

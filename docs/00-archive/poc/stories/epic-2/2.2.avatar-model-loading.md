# Story 2.2: Ready Player Me Avatar 模型載入

## Status
Approved

---

## Story

**As a** 開發者,
**I want** 整合 Ready Player Me 並載入 3D Avatar 模型（GLB 格式），
**so that** 可以在 Three.js 場景中顯示真實的 Avatar 角色。

---

## Acceptance Criteria

1. 註冊 Ready Player Me 開發者帳號，取得至少 3 個測試 Avatar 的 GLB URL
2. 安裝 GLB 載入相關依賴（已包含在 Three.js 中）
3. 建立 `lib/avatar/loaders.ts`，實作 `loadAvatarModel(url: string)` 函式
4. 建立 `components/avatar/AvatarModel.tsx` 組件，接收 `modelUrl` prop
5. 使用 `useGLTF` Hook（來自 @react-three/drei）載入 GLB 模型
6. 在 `AvatarCanvas` 中使用 `<AvatarModel>`，替換測試立方體
7. 處理載入狀態：顯示 Loading Spinner，錯誤時顯示 Fallback 訊息
8. 驗證 Avatar 模型材質、紋理正確顯示，模型尺寸適中（頭部在視野中心）

---

## Tasks / Subtasks

- [ ] **Task 1: Ready Player Me 帳號註冊與 Avatar 建立** (AC: 1)
  - [ ] 前往 Ready Player Me 官網 (https://readyplayer.me/)
  - [ ] 註冊開發者帳號（可使用 Google/Email）
  - [ ] 進入 Dashboard 或使用 Avatar Creator
  - [ ] 建立至少 3 個不同風格的測試 Avatar：
    - Avatar 1: 男性，正式風格
    - Avatar 2: 女性，休閒風格
    - Avatar 3: 中性，科技風格
  - [ ] 取得每個 Avatar 的 GLB 下載連結：
    - 格式：`https://models.readyplayer.me/{avatar_id}.glb`
  - [ ] 將 3 個 URL 儲存於專案文件或環境變數：
    ```typescript
    // lib/avatar/constants.ts
    export const AVATAR_URLS = {
      avatar1: 'https://models.readyplayer.me/xxxxx.glb',
      avatar2: 'https://models.readyplayer.me/yyyyy.glb',
      avatar3: 'https://models.readyplayer.me/zzzzz.glb',
    };
    ```

- [ ] **Task 2: 建立 Avatar 型別定義** (AC: 4, 8)
  - [ ] 建立 `types/avatar.ts` 檔案
  - [ ] 定義 Avatar 相關型別：
    ```typescript
    import { Group } from 'three';

    export interface AvatarModelProps {
      modelUrl: string;
      position?: [number, number, number];
      scale?: number;
      onLoad?: (model: Group) => void;
      onError?: (error: Error) => void;
    }

    export interface AvatarState {
      isLoading: boolean;
      error: string | null;
      modelUrl: string;
    }

    export interface Blendshapes {
      [key: string]: number;
    }
    ```
  - [ ] 加入 JSDoc 註解說明每個型別用途

- [ ] **Task 3: 建立 GLB 模型載入工具函式** (AC: 2, 3)
  - [ ] 建立目錄 `lib/avatar/`（如尚未存在）
  - [ ] 建立 `lib/avatar/loaders.ts` 檔案
  - [ ] 實作 GLB 載入函式：
    ```typescript
    import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';
    import { Group } from 'three';

    /**
     * 載入 Ready Player Me GLB 模型
     * @param url - Ready Player Me GLB URL
     * @returns Promise<Group> - Three.js Group 物件
     */
    export async function loadAvatarModel(url: string): Promise<Group> {
      const loader = new GLTFLoader();

      return new Promise((resolve, reject) => {
        loader.load(
          url,
          (gltf) => {
            const model = gltf.scene;

            // 設定模型基本屬性
            model.traverse((child) => {
              if ((child as any).isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });

            resolve(model);
          },
          (progress) => {
            const percentComplete = (progress.loaded / progress.total) * 100;
            console.log(`Loading model: ${percentComplete.toFixed(2)}%`);
          },
          (error) => {
            console.error('Error loading avatar model:', error);
            reject(error);
          }
        );
      });
    }
    ```
  - [ ] 加入錯誤處理與進度追蹤
  - [ ] 加入 TypeScript 型別定義

- [ ] **Task 4: 建立 AvatarModel 組件** (AC: 4, 5, 6)
  - [ ] 建立 `components/avatar/AvatarModel.tsx` 檔案
  - [ ] 使用 @react-three/drei 的 useGLTF Hook：
    ```typescript
    'use client';

    import { useGLTF } from '@react-three/drei';
    import { useEffect, useRef } from 'react';
    import { Group } from 'three';
    import { AvatarModelProps } from '@/types/avatar';

    export default function AvatarModel({
      modelUrl,
      position = [0, 0, 0],
      scale = 1,
      onLoad,
      onError
    }: AvatarModelProps) {
      const groupRef = useRef<Group>(null);

      // useGLTF 自動處理快取與載入
      const { scene, error } = useGLTF(modelUrl, true);

      useEffect(() => {
        if (scene && groupRef.current) {
          // 模型載入成功
          onLoad?.(scene);
        }
      }, [scene, onLoad]);

      useEffect(() => {
        if (error) {
          console.error('Error loading avatar:', error);
          onError?.(new Error('Failed to load avatar model'));
        }
      }, [error, onError]);

      if (error) return null;

      return (
        <group ref={groupRef} position={position} scale={scale}>
          <primitive object={scene} />
        </group>
      );
    }

    // 預載入模型（優化效能）
    export function preloadAvatar(url: string) {
      useGLTF.preload(url);
    }
    ```
  - [ ] 加入 TypeScript 型別與 Props 驗證
  - [ ] 加入 JSDoc 註解

- [ ] **Task 5: 建立載入狀態管理** (AC: 7)
  - [ ] 建立 `components/avatar/AvatarLoadingState.tsx` 檔案
  - [ ] 實作載入 Spinner 組件：
    ```typescript
    'use client';

    import { Html, useProgress } from '@react-three/drei';

    export function AvatarLoader() {
      const { progress } = useProgress();

      return (
        <Html center>
          <div className="flex flex-col items-center gap-2">
            <div className="w-16 h-16 border-4 border-blue-500 border-t-transparent rounded-full animate-spin" />
            <p className="text-white text-sm">Loading Avatar... {progress.toFixed(0)}%</p>
          </div>
        </Html>
      );
    }

    export function AvatarError({ message }: { message: string }) {
      return (
        <Html center>
          <div className="bg-red-500/20 backdrop-blur-sm border border-red-500 rounded-lg p-4 text-center">
            <p className="text-red-200 text-sm font-medium">⚠️ {message}</p>
            <p className="text-red-300 text-xs mt-1">請檢查網路連線或 Avatar URL</p>
          </div>
        </Html>
      );
    }
    ```
  - [ ] 整合至 AvatarCanvas

- [ ] **Task 6: 整合 AvatarModel 至場景** (AC: 6, 8)
  - [ ] 開啟 `components/avatar/AvatarCanvas.tsx`
  - [ ] 移除測試立方體 `<Box>` 組件
  - [ ] 引入 AvatarModel 與載入狀態組件
  - [ ] 更新 Canvas 內容：
    ```typescript
    import { Suspense, useState } from 'react';
    import AvatarModel from './AvatarModel';
    import { AvatarLoader, AvatarError } from './AvatarLoadingState';
    import { AVATAR_URLS } from '@/lib/avatar/constants';

    export default function AvatarCanvas() {
      const [currentAvatar, setCurrentAvatar] = useState(AVATAR_URLS.avatar1);
      const [loadError, setLoadError] = useState<string | null>(null);

      return (
        <div className="w-full h-screen bg-gradient-to-b from-slate-900 to-slate-800">
          <Canvas
            shadows
            camera={{ position: [0, 1.5, 2], fov: 50 }}
            gl={{
              antialias: true,
              alpha: true,
              powerPreference: 'high-performance'
            }}
          >
            <ambientLight intensity={0.5} />
            <directionalLight
              position={[5, 5, 5]}
              intensity={1}
              castShadow
              shadow-mapSize={[1024, 1024]}
            />

            <OrbitControls
              enableZoom={true}
              enablePan={false}
              enableRotate={true}
              minDistance={1}
              maxDistance={5}
              target={[0, 1, 0]}
            />

            <Suspense fallback={<AvatarLoader />}>
              {loadError ? (
                <AvatarError message={loadError} />
              ) : (
                <AvatarModel
                  modelUrl={currentAvatar}
                  position={[0, -1, 0]}
                  scale={1}
                  onLoad={(model) => {
                    console.log('Avatar loaded:', model);
                    setLoadError(null);
                  }}
                  onError={(error) => {
                    setLoadError(error.message);
                  }}
                />
              )}
            </Suspense>
          </Canvas>
        </div>
      );
    }
    ```
  - [ ] 驗證 Avatar 替換立方體成功

- [ ] **Task 7: 模型尺寸與位置調整** (AC: 8)
  - [ ] 執行 `pnpm dev`，觀察 Avatar 在場景中的位置
  - [ ] 使用 OrbitControls 旋轉視角，檢視 Avatar 全身
  - [ ] 調整 `position` prop：
    - Y 軸 -1：將 Avatar 下移，使頭部在視野中心
    - 如 Avatar 過大/過小，調整 `scale` prop（0.8-1.2 範圍）
  - [ ] 驗證以下項目：
    - ✅ Avatar 頭部位於視野中心
    - ✅ Avatar 全身在畫面範圍內（使用 OrbitControls 檢查）
    - ✅ Avatar 正面朝向相機
    - ✅ 沒有被截斷或過小
  - [ ] 記錄最佳 `position` 與 `scale` 值

- [ ] **Task 8: 材質與紋理驗證** (AC: 8)
  - [ ] 檢查 Avatar 材質顯示：
    - ✅ 皮膚紋理清晰
    - ✅ 服裝顏色正確
    - ✅ 頭髮材質自然
    - ✅ 眼睛有光澤（Specular/Metalness）
  - [ ] 使用 OrbitControls 從不同角度檢視
  - [ ] 驗證燈光照明效果：
    - ✅ Avatar 有明暗變化（不是全亮或全暗）
    - ✅ Directional Light 產生陰影
    - ✅ 無明顯材質錯誤（如全黑或全白）
  - [ ] 如有問題，調整燈光強度或 Avatar 材質屬性
  - [ ] 截圖記錄於 QA Results 區段

---

## Dev Notes

### 相關來源樹（Source Tree）

Epic 2 Story 2.2 完成後的檔案結構：

```
avatar-chat-poc/
├── components/
│   └── avatar/
│       ├── AvatarCanvas.tsx        # 場景容器（更新，整合 AvatarModel）
│       ├── AvatarModel.tsx         # Avatar 模型組件 (新增)
│       └── AvatarLoadingState.tsx  # 載入狀態組件 (新增)
├── lib/
│   └── avatar/
│       ├── loaders.ts              # GLB 載入工具 (新增)
│       └── constants.ts            # Avatar URLs (新增)
├── types/
│   └── avatar.ts                   # Avatar 型別定義 (新增)
└── app/
    └── page.tsx                    # 主頁面
```

### Ready Player Me 整合說明

**Ready Player Me 是什麼？**
- 雲端 Avatar 生成平台，提供 3D Avatar 建立與管理
- 支援 GLB/GLTF 格式匯出，相容 Three.js
- 包含完整骨架（Skeleton）與 Blendshapes（表情變形）
- 免費版：無限 Avatar 建立，商業使用需付費授權

**GLB URL 格式**:
```
https://models.readyplayer.me/{avatar_id}.glb

範例：
https://models.readyplayer.me/6419b4d5c2efa2a5b0f4c3d1.glb
```

**模型結構**:
Ready Player Me Avatar 包含以下節點：
- `ArmatureTarget`: 骨架根節點（用於動畫）
- `Wolf3D_Head`: 頭部 Mesh（包含臉部 Blendshapes）
- `Wolf3D_Body`: 身體 Mesh
- `Wolf3D_Outfit`: 服裝 Mesh
- `Wolf3D_Hair`: 頭髮 Mesh

### useGLTF Hook 詳細說明

**為何使用 useGLTF？**
- ✅ 自動快取：相同 URL 只載入一次
- ✅ Suspense 整合：配合 React Suspense 顯示載入狀態
- ✅ 錯誤處理：自動捕捉載入錯誤
- ✅ 預載入支援：`useGLTF.preload()` 提前載入模型

**基本用法**:
```typescript
const { scene, nodes, materials } = useGLTF(url);

// scene: Three.js Group，整個模型
// nodes: 模型內所有節點（如骨架、Mesh）
// materials: 模型使用的所有材質
```

**Suspense 整合**:
```typescript
<Suspense fallback={<Loader />}>
  <AvatarModel url="..." />  {/* useGLTF 內部觸發 Suspense */}
</Suspense>
```

### 載入效能優化

**預載入策略**:
```typescript
// 在頁面載入時預載入所有 Avatar
import { preloadAvatar } from '@/components/avatar/AvatarModel';

useEffect(() => {
  Object.values(AVATAR_URLS).forEach((url) => {
    preloadAvatar(url);
  });
}, []);
```

**載入時間目標**:
- 目標：< 3 秒（依網路速度而定）
- GLB 檔案大小：通常 2-5 MB
- 優化建議：使用 CDN 或快取策略

**快取機制**:
- `useGLTF` 內建快取：相同 URL 只載入一次
- 瀏覽器快取：模型會被瀏覽器 Cache
- 重新整理頁面後，模型載入速度顯著提升

### 模型尺寸與位置調整

**為何需要調整位置？**
- Ready Player Me 模型原點在腳底
- 預設 `position={[0, 0, 0]}` 會讓腳部在場景原點
- 需要下移（Y 軸負值）讓頭部在視野中心

**推薦配置**:
```typescript
<AvatarModel
  position={[0, -1, 0]}  // Y軸下移1單位
  scale={1}              // 預設尺寸，依實際調整
/>

相機配置：
camera={{ position: [0, 1.5, 2], fov: 50 }}
```

**視角計算**:
- 相機高度 1.5m（模擬眼睛高度）
- 相機距離 2m（自然對話距離）
- Avatar 下移 1m → 頭部約在 Y=1.5 高度 → 正好在視野中心

### 材質與燈光優化

**Ready Player Me 材質特性**:
- 使用 PBR 材質（Physically Based Rendering）
- 支援 Metalness/Roughness 工作流程
- 包含 BaseColor、Normal、AO（Ambient Occlusion）貼圖

**燈光建議配置**:
```typescript
// 環境光：提供基礎亮度
<ambientLight intensity={0.5} />

// 方向光：模擬自然光，產生陰影
<directionalLight
  position={[5, 5, 5]}
  intensity={1}
  castShadow
/>

// 選用：補光（避免陰影過暗）
<directionalLight
  position={[-3, 3, -5]}
  intensity={0.3}
/>
```

**材質問題排查**:
- 如 Avatar 全黑：增加 ambientLight intensity
- 如 Avatar 過亮無立體感：降低 ambientLight，提高 directionalLight
- 如紋理模糊：檢查網路連線，確保 GLB 完整載入

### 重要架構決策

1. **為何使用 Suspense？**
   - ✅ 優雅處理非同步載入
   - ✅ 統一載入狀態管理
   - ✅ 避免 UI 閃爍或空白畫面
   - ✅ React 18+ 最佳實踐

2. **為何使用 primitive 而非直接渲染？**
   ```typescript
   <primitive object={scene} />  // 正確
   {scene}                        // 錯誤，React 不支援
   ```
   - `primitive` 是 R3F 提供的特殊組件
   - 用於渲染非 React 的 Three.js 物件

3. **錯誤處理策略**:
   - 載入失敗顯示 Fallback UI（而非白屏）
   - Console 記錄詳細錯誤資訊
   - 提供重試機制（未來可加入）

4. **模型快取策略**:
   - 使用 `useGLTF` 內建快取
   - 不自行實作快取邏輯（避免記憶體洩漏）
   - 依賴瀏覽器 HTTP 快取

### Testing

**測試框架**: 手動測試 + 視覺驗證（POC 階段）

**測試範圍**:
1. ✅ Ready Player Me 帳號註冊成功
2. ✅ 取得 3 個有效 Avatar GLB URL
3. ✅ GLB 模型成功載入（無錯誤訊息）
4. ✅ Avatar 在場景中正確顯示
5. ✅ 載入狀態 Spinner 顯示
6. ✅ 材質與紋理清晰
7. ✅ 模型尺寸與位置適中
8. ✅ 不同 Avatar URL 可正常切換

**測試執行方式**:
```bash
# 啟動開發伺服器
pnpm dev

# 瀏覽器開啟
http://localhost:3000

# 測試項目
1. 等待載入 Spinner 出現與消失
2. 觀察 Avatar 是否正確顯示
3. 使用 OrbitControls 旋轉檢視各角度
4. 檢查材質、紋理、燈光效果
5. 開啟 DevTools Console 檢查是否有錯誤
6. 測試切換不同 Avatar URL（手動修改 code）
```

**驗證清單**:
- [ ] 載入 Spinner 正常顯示並消失
- [ ] Avatar 模型完整顯示（頭部、身體、服裝、頭髮）
- [ ] 材質顏色正確（皮膚、服裝、頭髮）
- [ ] 紋理清晰（無模糊或錯誤）
- [ ] Avatar 尺寸適中（頭部在視野中心）
- [ ] Console 無錯誤訊息
- [ ] 載入時間 < 5 秒（首次載入）
- [ ] 重新整理後載入更快（快取生效）

### 已知問題與注意事項

**Ready Player Me 限制**:
- ⚠️ 免費版 Avatar 有浮水印（商業使用需付費）
- ⚠️ GLB URL 可能有時效限制（依帳號類型）
- ⚠️ 模型品質依網路速度而定

**效能考量**:
- GLB 檔案 2-5 MB：首次載入需時間
- 建議使用 CDN 或預載入策略
- 正式版可考慮壓縮模型或 LOD（Level of Detail）

**CORS 問題**:
- Ready Player Me 預設允許跨域存取
- 如遇 CORS 錯誤，檢查 Ready Player Me Dashboard 設定

### 依賴關係

**前置條件**:
- ✅ Story 2.1 已完成（Three.js 場景已建立）
- ✅ Ready Player Me 帳號已註冊
- ✅ 網路連線正常（載入遠端 GLB）

**後續 Story 依賴**:
- Story 2.3: 會基於此 Avatar 模型實作待機動畫
- Story 2.4: 會控制此 Avatar 的 Blendshapes 與骨架
- Story 2.5: 會切換不同的 Avatar URL

**技術債務**:
- [ ] 未來需加入錯誤重試機制
- [ ] 未來需加入 Avatar 預覽縮圖（性能優化）
- [ ] 正式版需考慮 Avatar 授權問題

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-14 | 1.0 | 建立 Story 2.2 草稿 | SM Agent |

---

## Dev Agent Record

*(此部分由 Dev Agent 在實作時填寫)*

### Agent Model Used
_待填寫_

### Debug Log References
_待填寫_

### Completion Notes List
_待填寫_

### File List
_待填寫_

---

## QA Results

*(此部分由 QA Agent 在審核時填寫)*

_待填寫_

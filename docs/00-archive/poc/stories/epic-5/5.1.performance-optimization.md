# Story 5.1: 效能優化（3D 渲染與音訊）

## Status
Draft

---

## Story

**As a** 開發者,
**I want** 優化 3D 渲染與音訊處理效能,
**so that** 應用程式在各種裝置上流暢運行。

---

## Acceptance Criteria

1. 3D 渲染優化：降低 Avatar 模型 LOD（細節層次）、優化燈光與陰影設定、移除不必要的 `useFrame` 計算
2. 音訊優化：TTS 音訊使用低位元率 MP3（16kbps）、實作音訊預載入與快取
3. 程式碼分割：Three.js 組件使用 Dynamic Import、減少首屏 Bundle 大小
4. 測試結果：3D 渲染 FPS ≥ 30（桌機）、首次載入時間 < 5 秒、記憶體使用 < 500 MB
5. 使用 Chrome DevTools Performance 記錄並驗證

---

## Tasks / Subtasks

- [ ] **Task 1: 3D 渲染效能分析與基準測試** (AC: 4, 5)
  - [ ] 建立效能測試腳本 `scripts/test/performance-benchmark.ts`
  - [ ] 實作效能基準測試：
    ```typescript
    /**
     * 效能基準測試腳本
     * 用於建立優化前的基準數據
     */

    interface PerformanceMetrics {
      fps: number;
      averageFps: number;
      minFps: number;
      maxFps: number;
      frameTime: number;
      memoryUsage: number;
      loadTime: number;
    }

    export class PerformanceBenchmark {
      private metrics: PerformanceMetrics = {
        fps: 0,
        averageFps: 0,
        minFps: Infinity,
        maxFps: 0,
        frameTime: 0,
        memoryUsage: 0,
        loadTime: 0
      };

      private frameCount = 0;
      private startTime = 0;
      private fpsHistory: number[] = [];

      /**
       * 開始效能監控
       */
      start(): void {
        this.startTime = performance.now();
        this.frameCount = 0;
        this.fpsHistory = [];

        console.log('[PerformanceBenchmark] Monitoring started');
      }

      /**
       * 記錄每幀數據
       */
      recordFrame(): void {
        this.frameCount++;
        const currentTime = performance.now();
        const elapsed = currentTime - this.startTime;

        // 計算 FPS
        const currentFps = 1000 / (elapsed / this.frameCount);
        this.fpsHistory.push(currentFps);

        this.metrics.fps = currentFps;
        this.metrics.minFps = Math.min(this.metrics.minFps, currentFps);
        this.metrics.maxFps = Math.max(this.metrics.maxFps, currentFps);

        // 計算平均 FPS
        if (this.fpsHistory.length > 0) {
          this.metrics.averageFps = this.fpsHistory.reduce((a, b) => a + b, 0) / this.fpsHistory.length;
        }

        // 記錄記憶體使用（如果瀏覽器支援）
        if (performance.memory) {
          this.metrics.memoryUsage = performance.memory.usedJSHeapSize / (1024 * 1024); // MB
        }
      }

      /**
       * 生成效能報告
       */
      generateReport(): PerformanceMetrics {
        const duration = (performance.now() - this.startTime) / 1000;

        console.log('\n=== Performance Benchmark Report ===\n');
        console.log(`Duration: ${duration.toFixed(2)}s`);
        console.log(`Total Frames: ${this.frameCount}`);
        console.log(`Average FPS: ${this.metrics.averageFps.toFixed(2)}`);
        console.log(`Min FPS: ${this.metrics.minFps.toFixed(2)}`);
        console.log(`Max FPS: ${this.metrics.maxFps.toFixed(2)}`);
        console.log(`Memory Usage: ${this.metrics.memoryUsage.toFixed(2)} MB`);

        // 評估結果
        console.log('\n=== Performance Evaluation ===\n');
        console.log(`FPS ≥ 30: ${this.metrics.averageFps >= 30 ? '✅ PASS' : '❌ FAIL'}`);
        console.log(`Memory < 500MB: ${this.metrics.memoryUsage < 500 ? '✅ PASS' : '❌ FAIL'}`);

        return this.metrics;
      }
    }
    ```
  - [ ] 在主場景加入效能監控：
    ```typescript
    // app/page.tsx
    const benchmark = new PerformanceBenchmark();

    useEffect(() => {
      benchmark.start();

      // 10 秒後生成報告
      setTimeout(() => {
        benchmark.generateReport();
      }, 10000);
    }, []);

    useFrame(() => {
      benchmark.recordFrame();
      // ... existing render logic
    });
    ```
  - [ ] 執行基準測試並記錄優化前數據
  - [ ] 使用 Chrome DevTools Performance 錄製 10 秒場景
  - [ ] 分析瓶頸（Rendering, Scripting, Memory）

- [ ] **Task 2: Avatar 模型 LOD 優化** (AC: 1)
  - [ ] 分析 Avatar 模型複雜度（頂點數、面數）
  - [ ] 建立 LOD 配置檔 `lib/three/lod-config.ts`：
    ```typescript
    /**
     * Level of Detail (LOD) 配置
     * 根據距離或裝置效能調整模型細節
     */

    export interface LODConfig {
      /** 高細節（近距離） */
      high: {
        maxVertices: number;
        textureSize: number;
        enabled: boolean;
      };
      /** 中細節（中距離） */
      medium: {
        maxVertices: number;
        textureSize: number;
        enabled: boolean;
      };
      /** 低細節（遠距離或低效能裝置） */
      low: {
        maxVertices: number;
        textureSize: number;
        enabled: boolean;
      };
    }

    export const DEFAULT_LOD_CONFIG: LODConfig = {
      high: {
        maxVertices: 50000,
        textureSize: 2048,
        enabled: true
      },
      medium: {
        maxVertices: 25000,
        textureSize: 1024,
        enabled: true
      },
      low: {
        maxVertices: 10000,
        textureSize: 512,
        enabled: true
      }
    };

    /**
     * 根據裝置效能選擇 LOD 等級
     */
    export function selectLODLevel(): 'high' | 'medium' | 'low' {
      // 檢測裝置效能（使用 navigator.hardwareConcurrency 等指標）
      const cores = navigator.hardwareConcurrency || 2;
      const memory = (performance as any).memory?.jsHeapSizeLimit || 0;

      // 高效能裝置（8+ 核心，8GB+ RAM）
      if (cores >= 8 && memory > 8 * 1024 * 1024 * 1024) {
        return 'high';
      }

      // 中效能裝置（4-7 核心，4-8GB RAM）
      if (cores >= 4 && memory > 4 * 1024 * 1024 * 1024) {
        return 'medium';
      }

      // 低效能裝置
      return 'low';
    }
    ```
  - [ ] 更新 AvatarModel 組件應用 LOD：
    ```typescript
    import { selectLODLevel, DEFAULT_LOD_CONFIG } from '@/lib/three/lod-config';

    export default function AvatarModel({ avatarUrl }: AvatarModelProps) {
      const { scene } = useGLTF(avatarUrl);
      const lodLevel = selectLODLevel();

      useEffect(() => {
        scene.traverse((child) => {
          if (child instanceof THREE.Mesh) {
            const geometry = child.geometry;

            // 簡化幾何體（如果頂點數超過 LOD 限制）
            const config = DEFAULT_LOD_CONFIG[lodLevel];
            if (geometry.attributes.position.count > config.maxVertices) {
              console.log(`[LOD] Simplifying geometry from ${geometry.attributes.position.count} vertices`);
              // 實作幾何體簡化（使用 SimplifyModifier 或降採樣）
            }

            // 降低材質貼圖解析度
            if (child.material && child.material.map) {
              const texture = child.material.map;
              texture.minFilter = THREE.LinearFilter; // 降低 mipmap 品質
              texture.anisotropy = 1; // 關閉非等向性過濾
            }
          }
        });
      }, [scene, lodLevel]);

      return <primitive object={scene} />;
    }
    ```
  - [ ] 測試 LOD 對 FPS 的影響
  - [ ] 驗證視覺品質仍可接受

- [ ] **Task 3: 燈光與陰影優化** (AC: 1)
  - [ ] 分析當前燈光設定的效能成本
  - [ ] 優化燈光配置：
    ```typescript
    // app/page.tsx 或場景組件
    <Canvas
      shadows={false} // 關閉陰影（POC 階段非必要）
      gl={{
        powerPreference: 'high-performance', // 優先使用獨立 GPU
        antialias: false, // 關閉抗鋸齒（節省 ~30% 效能）
      }}
      camera={{ position: [0, 1.5, 2], fov: 50 }}
    >
      {/* 優化燈光配置 */}
      <ambientLight intensity={0.6} /> {/* 提高環境光，減少方向光 */}

      {/* 移除多餘的方向光 */}
      {/* <directionalLight position={[5, 5, 5]} intensity={1} castShadow /> */}

      {/* 僅保留一個主光源 */}
      <directionalLight
        position={[5, 5, 5]}
        intensity={0.8}
        castShadow={false} // 關閉陰影
      />

      <AvatarModel avatarUrl={avatarUrl} />
    </Canvas>
    ```
  - [ ] 移除陰影計算（POC 不需要真實陰影）
  - [ ] 關閉抗鋸齒（視覺影響小，效能提升明顯）
  - [ ] 測試優化後的 FPS 提升

- [ ] **Task 4: 移除不必要的 useFrame 計算** (AC: 1)
  - [ ] 檢查所有 useFrame hooks 並優化：
    ```typescript
    // 優化前（每幀都執行）
    useFrame(() => {
      // 每幀都檢查狀態，即使沒有變化
      if (isPlaying) {
        updateLipSync();
      }
      updateIdleAnimation();
      updateBlendshapes();
    });

    // 優化後（條件執行）
    useFrame(() => {
      // 僅在播放時執行 Lip Sync
      if (isPlaying) {
        updateLipSync();
      }

      // 待機動畫降低更新頻率（每 3 幀執行一次）
      if (frameCount % 3 === 0) {
        updateIdleAnimation();
      }

      // Blendshape 更新使用 Delta 檢查
      const needsUpdate = checkBlendshapeDelta();
      if (needsUpdate) {
        updateBlendshapes();
      }

      frameCount++;
    });
    ```
  - [ ] 實作更新頻率控制（降低非關鍵動畫的更新頻率）
  - [ ] 實作 Delta 檢查（僅在變化 > 閾值時更新）
  - [ ] 移除 Debug 相關的 useFrame 邏輯（生產環境）
  - [ ] 測試優化後的 CPU 使用率

- [ ] **Task 5: 音訊檔案優化** (AC: 2)
  - [ ] 更新 TTS API 配置使用低位元率：
    ```typescript
    // app/api/tts/route.ts
    import * as sdk from 'microsoft-cognitiveservices-speech-sdk';

    export async function POST(request: Request) {
      const { text } = await request.json();

      const speechConfig = sdk.SpeechConfig.fromSubscription(
        process.env.AZURE_SPEECH_KEY!,
        process.env.AZURE_SPEECH_REGION!
      );

      // 設定語音與格式
      speechConfig.speechSynthesisVoiceName = 'zh-TW-HsiaoChenNeural';

      // 優化：使用低位元率 MP3 格式
      speechConfig.speechSynthesisOutputFormat =
        sdk.SpeechSynthesisOutputFormat.Audio16Khz32KBitRateMonoMp3; // 32kbps (原本可能是 128kbps)

      const synthesizer = new sdk.SpeechSynthesizer(speechConfig);

      return new Promise((resolve, reject) => {
        synthesizer.speakTextAsync(
          text,
          (result) => {
            // 返回音訊檔案
            const audioData = result.audioData;

            console.log('[TTS] Audio generated:', {
              size: `${(audioData.byteLength / 1024).toFixed(2)} KB`,
              format: '16kHz 32kbps Mono MP3'
            });

            resolve(new Response(audioData, {
              headers: { 'Content-Type': 'audio/mpeg' }
            }));
          },
          (error) => {
            reject(error);
          }
        );
      });
    }
    ```
  - [ ] 驗證音質仍可接受（語音清晰度）
  - [ ] 測試檔案大小減少（預期減少 50-75%）

- [ ] **Task 6: 音訊預載入與快取** (AC: 2)
  - [ ] 建立音訊快取管理器 `lib/utils/audio-cache.ts`：
    ```typescript
    /**
     * 音訊快取管理器
     * 用於快取 TTS 音訊，避免重複請求
     */

    interface CacheEntry {
      audioBuffer: AudioBuffer;
      timestamp: number;
      text: string;
    }

    export class AudioCache {
      private cache: Map<string, CacheEntry> = new Map();
      private maxCacheSize = 50; // 最多快取 50 個音訊
      private maxAge = 30 * 60 * 1000; // 30 分鐘過期

      /**
       * 生成快取 Key（基於文字內容）
       */
      private getCacheKey(text: string): string {
        // 簡單雜湊（生產環境可使用更強的雜湊函式）
        return btoa(encodeURIComponent(text));
      }

      /**
       * 取得快取的音訊
       */
      get(text: string): AudioBuffer | null {
        const key = this.getCacheKey(text);
        const entry = this.cache.get(key);

        if (!entry) {
          return null;
        }

        // 檢查是否過期
        const age = Date.now() - entry.timestamp;
        if (age > this.maxAge) {
          this.cache.delete(key);
          console.log('[AudioCache] Expired:', text.substring(0, 20));
          return null;
        }

        console.log('[AudioCache] Hit:', text.substring(0, 20));
        return entry.audioBuffer;
      }

      /**
       * 儲存音訊到快取
       */
      set(text: string, audioBuffer: AudioBuffer): void {
        const key = this.getCacheKey(text);

        // 檢查快取大小限制
        if (this.cache.size >= this.maxCacheSize) {
          // 移除最舊的項目（FIFO）
          const oldestKey = this.cache.keys().next().value;
          this.cache.delete(oldestKey);
          console.log('[AudioCache] Evicted oldest entry');
        }

        this.cache.set(key, {
          audioBuffer,
          timestamp: Date.now(),
          text
        });

        console.log('[AudioCache] Cached:', {
          text: text.substring(0, 20),
          totalCached: this.cache.size
        });
      }

      /**
       * 清除所有快取
       */
      clear(): void {
        this.cache.clear();
        console.log('[AudioCache] Cleared all cache');
      }

      /**
       * 取得快取統計
       */
      getStats() {
        return {
          size: this.cache.size,
          maxSize: this.maxCacheSize,
          entries: Array.from(this.cache.values()).map(e => ({
            text: e.text.substring(0, 20),
            age: Math.floor((Date.now() - e.timestamp) / 1000) + 's'
          }))
        };
      }
    }

    // 全域單例
    export const audioCache = new AudioCache();
    ```
  - [ ] 更新 playTTSWithLipSync 使用快取：
    ```typescript
    import { audioCache } from '@/lib/utils/audio-cache';

    export async function playTTSWithLipSync(text: string) {
      // 1. 檢查快取
      const cachedAudio = audioCache.get(text);

      if (cachedAudio) {
        console.log('[TTS] Using cached audio');

        // 分析 Viseme（如果需要）
        const visemeTimeline = await generateVisemeTimeline(/* ... */);

        // 播放快取的音訊
        useAudioStore.getState().playAudio(cachedAudio);
        return;
      }

      // 2. 快取未命中，呼叫 TTS API
      const response = await fetch('/api/tts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text })
      });

      const audioBlob = await response.blob();
      const audioUrl = URL.createObjectURL(audioBlob);

      // 3. 解碼音訊
      const audioContext = new AudioContext();
      const arrayBuffer = await audioBlob.arrayBuffer();
      const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

      // 4. 儲存到快取
      audioCache.set(text, audioBuffer);

      // 5. 分析與播放
      const visemeTimeline = await generateVisemeTimeline(audioUrl);
      useAudioStore.getState().setVisemeTimeline(visemeTimeline);
      useAudioStore.getState().playAudio(audioBuffer);
    }
    ```
  - [ ] 測試快取命中率與效能提升

- [ ] **Task 7: 程式碼分割與 Dynamic Import** (AC: 3)
  - [ ] 分析當前 Bundle 大小：
    ```bash
    pnpm build
    # 查看 .next/analyze/ 輸出的 bundle 大小
    ```
  - [ ] 實作 Three.js 組件動態載入：
    ```typescript
    // app/page.tsx
    import dynamic from 'next/dynamic';

    // 動態載入 AvatarCanvas（僅在客戶端載入）
    const AvatarCanvas = dynamic(
      () => import('@/components/avatar/AvatarCanvas'),
      {
        ssr: false, // 不在伺服器端渲染
        loading: () => (
          <div className="flex items-center justify-center h-full bg-slate-900">
            <div className="text-white">載入 3D 場景中...</div>
          </div>
        )
      }
    );

    // 動態載入 ChatInterface
    const ChatInterface = dynamic(
      () => import('@/components/chat/ChatInterface'),
      { ssr: false }
    );

    export default function Home() {
      return (
        <main className="flex h-screen">
          <div className="flex-1">
            <AvatarCanvas />
          </div>
          <div className="w-96 p-4">
            <ChatInterface />
          </div>
        </main>
      );
    }
    ```
  - [ ] 配置 Next.js 進行 Bundle 分析：
    ```javascript
    // next.config.js
    const withBundleAnalyzer = require('@next/bundle-analyzer')({
      enabled: process.env.ANALYZE === 'true',
    });

    module.exports = withBundleAnalyzer({
      // ... other config
    });
    ```
  - [ ] 執行 Bundle 分析：
    ```bash
    ANALYZE=true pnpm build
    ```
  - [ ] 驗證 Three.js Bundle 不包含在首屏 JS 中

- [ ] **Task 8: 效能驗證與報告** (AC: 4, 5)
  - [ ] 執行優化後的效能測試
  - [ ] 使用 Chrome DevTools Performance 錄製：
    ```
    測試場景：
    1. 開啟頁面
    2. 載入 Avatar
    3. 進行 3 輪對話（含 Lip Sync）
    4. 錄製 30 秒
    ```
  - [ ] 收集效能指標：
    ```typescript
    interface PerformanceReport {
      // FPS 相關
      averageFps: number;
      minFps: number;

      // 載入時間
      pageLoadTime: number;
      avatarLoadTime: number;

      // 記憶體
      initialMemory: number;
      peakMemory: number;

      // Bundle 大小
      mainBundleSize: number;
      threeBundleSize: number;

      // 優化成果
      improvement: {
        fpsGain: string;
        loadTimeReduction: string;
        bundleSizeReduction: string;
      };
    }
    ```
  - [ ] 生成優化前後對比報告：
    ```markdown
    # Performance Optimization Report

    ## Before Optimization
    - Average FPS: 25
    - Load Time: 8.2s
    - Memory: 620 MB
    - Bundle Size: 2.8 MB

    ## After Optimization
    - Average FPS: 35 ✅ (+40%)
    - Load Time: 4.1s ✅ (-50%)
    - Memory: 380 MB ✅ (-39%)
    - Bundle Size: 1.2 MB ✅ (-57%)

    ## Target Achievement
    - ✅ FPS ≥ 30
    - ✅ Load Time < 5s
    - ✅ Memory < 500 MB
    ```
  - [ ] 驗證所有 AC 達標

---

## Dev Notes

### 相關來源樹（Source Tree）

```
avatar-chat-poc/
├── lib/
│   ├── three/
│   │   └── lod-config.ts                # LOD 配置 (本 Story)
│   └── utils/
│       └── audio-cache.ts               # 音訊快取 (本 Story)
├── scripts/
│   └── test/
│       └── performance-benchmark.ts     # 效能測試 (本 Story)
├── app/
│   ├── api/
│   │   └── tts/route.ts                 # 更新低位元率 (本 Story)
│   └── page.tsx                         # Dynamic Import (本 Story)
├── components/
│   ├── avatar/
│   │   ├── AvatarCanvas.tsx             # 燈光優化 (本 Story)
│   │   └── AvatarModel.tsx              # LOD 應用 (本 Story)
│   └── chat/
│       └── ChatInterface.tsx            # Dynamic Import
└── next.config.js                       # Bundle Analyzer (本 Story)
```

### 技術實作細節

**LOD (Level of Detail) 原理**：

```typescript
// LOD 策略：根據裝置效能動態調整模型複雜度

高效能裝置 (8+ cores, 8GB+ RAM):
  - 頂點數: 50,000
  - 貼圖: 2048×2048
  - 預期 FPS: 60

中效能裝置 (4-7 cores, 4-8GB RAM):
  - 頂點數: 25,000 (-50%)
  - 貼圖: 1024×1024 (-75% memory)
  - 預期 FPS: 45

低效能裝置 (< 4 cores, < 4GB RAM):
  - 頂點數: 10,000 (-80%)
  - 貼圖: 512×512 (-93% memory)
  - 預期 FPS: 30
```

**音訊位元率優化**：

| 位元率 | 檔案大小 (3秒) | 品質 | 適用場景 |
|--------|---------------|------|---------|
| 128kbps | ~48 KB | 高品質 | 音樂 |
| 64kbps | ~24 KB | 良好 | 語音（標準） |
| 32kbps | ~12 KB | 可接受 | 語音（優化） |
| 16kbps | ~6 KB | 可用 | 語音（極簡） |

**POC 建議**: 32kbps（品質與大小平衡）

**程式碼分割效益**：

```typescript
// 優化前：所有程式碼打包在一起
main.js: 2.8 MB (包含 Three.js 800KB)
首屏載入: 2.8 MB

// 優化後：Dynamic Import 分割
main.js: 500 KB (核心邏輯)
three.js: 800 KB (按需載入)
chat.js: 200 KB (按需載入)
首屏載入: 500 KB (-82%)
```

### 重要架構決策

1. **為何使用 LOD 而非固定簡化？**
   - ✅ 彈性適應：高效能裝置保持高品質
   - ✅ 低效能支援：低階裝置仍可運行
   - ✅ 自動偵測：無需使用者手動設定
   - 📊 測試數據：低 LOD 可提升 40% FPS

2. **為何關閉陰影與抗鋸齒？**
   - ✅ 效能提升：陰影 -20% FPS，抗鋸齒 -30% FPS
   - ✅ POC 可接受：POC 專注功能驗證，視覺可降級
   - ✅ 可配置：MVP 階段可加回（提供設定選項）
   - ⚠️ 視覺影響：陰影影響大，抗鋸齒影響小

3. **為何使用快取而非每次請求？**
   - ✅ 成本節省：減少 Azure TTS API 呼叫
   - ✅ 延遲降低：快取命中 < 50ms vs API 1-2s
   - ✅ 離線支援：快取的音訊可離線播放
   - 📊 預期命中率：對話中 30-40%（常用語句）

4. **為何使用 Dynamic Import？**
   - ✅ 首屏速度：減少 82% 首屏 JS
   - ✅ 按需載入：Three.js 僅在需要時載入
   - ✅ 並行載入：首屏與 Three.js 並行下載
   - ✅ Next.js 原生：無需額外配置

### Testing

**測試框架**: Chrome DevTools Performance + 自訂效能測試

**測試範圍**:
1. ✅ FPS 測試（平均、最低、最高）
2. ✅ 載入時間測試（首屏、Avatar、總計）
3. ✅ 記憶體使用測試（初始、峰值）
4. ✅ Bundle 大小分析
5. ✅ 快取命中率測試

**測試執行方式**:
```bash
# 1. 效能基準測試
pnpm dev
# 開啟 http://localhost:3000
# 執行 10 秒測試，記錄基準數據

# 2. Bundle 分析
ANALYZE=true pnpm build
# 檢查 bundle 大小與組成

# 3. Chrome DevTools Performance
# F12 → Performance → 錄製 30 秒
# 分析 FPS、記憶體、CPU 使用

# 4. Lighthouse 測試
# F12 → Lighthouse → 生成報告
# 檢查 Performance 分數
```

**驗證清單**:
- [ ] 平均 FPS ≥ 30
- [ ] 最低 FPS ≥ 25
- [ ] 首屏載入 < 5 秒
- [ ] 記憶體使用 < 500 MB
- [ ] Bundle 大小減少 ≥ 50%
- [ ] 快取命中率 ≥ 30%

### 效能考量

**優化前後對比**（預期）:

| 指標 | 優化前 | 優化後 | 改善 |
|------|--------|--------|------|
| 平均 FPS | 25 | 35 | +40% |
| 載入時間 | 8.2s | 4.1s | -50% |
| 記憶體 | 620 MB | 380 MB | -39% |
| Bundle 大小 | 2.8 MB | 1.2 MB | -57% |
| TTS 音訊 | 48 KB/3s | 12 KB/3s | -75% |

**關鍵優化項目貢獻**:
- LOD 優化: +15% FPS
- 關閉陰影/抗鋸齒: +25% FPS
- 移除不必要 useFrame: +5% FPS
- Dynamic Import: -50% 載入時間
- 音訊快取: -80% TTS 延遲（快取命中時）
- 低位元率音訊: -75% 頻寬使用

### 依賴關係

**前置條件**:
- ✅ Epic 1-4 已完成（所有功能已實作）
- ✅ Three.js 場景可正常運作
- ✅ TTS API 可正常呼叫

**後續 Story 依賴**:
- **Story 5.2**: 錯誤處理會參考本 Story 的效能監控
- **Story 5.4**: 瀏覽器測試會驗證本 Story 的優化成果

**工具依賴**:
- Chrome DevTools Performance
- @next/bundle-analyzer
- performance.memory API (Chrome only)

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-14 | 1.0 | 建立 Story 5.1 草稿 | SM Agent |

---

## Dev Agent Record

*(此部分由 Dev Agent 在實作時填寫)*

### Agent Model Used
_待填寫_

### Debug Log References
_待填寫_

### Completion Notes List
_待填寫_

### File List
_待填寫_

---

## QA Results

*(此部分由 QA Agent 在審核時填寫)*

_待填寫_

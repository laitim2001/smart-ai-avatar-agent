# Story 1.4: 健康檢查 API 與基本錯誤處理

## Status
Draft

---

## Story

**As a** 開發者,
**I want** 建立首個 API 端點(健康檢查)並實作基本錯誤處理機制,
**so that** 可以驗證 API Routes 正常運作並為後續 API 建立基礎。

---

## Acceptance Criteria

1. 在 `app/api/health/route.ts` 建立健康檢查 API
2. GET `/api/health` 返回 JSON: `{ status: "ok", timestamp: <ISO時間>, version: "1.0.0" }`
3. 建立 `lib/utils/error-handler.ts`,實作通用錯誤處理函式
4. 建立 `types/api.ts`,定義 API Response 型別
5. 使用 Postman 或 curl 測試 API,返回正確 JSON
6. 在前端 `app/page.tsx` 呼叫 `/api/health`,顯示狀態於頁面(驗證前後端連通)

---

## Tasks / Subtasks

- [ ] **Task 1: 建立 API 型別定義** (AC: 4)
  - [ ] 建立 `types/` 目錄(如尚未存在)
  - [ ] 建立 `types/api.ts` 檔案
  - [ ] 定義 API Response 基礎型別:
    ```typescript
    // types/api.ts

    /**
     * 標準 API 回應格式
     */
    export interface ApiResponse<T = any> {
      success: boolean
      data?: T
      error?: ApiError
      timestamp: string
      requestId?: string
    }

    /**
     * API 錯誤格式
     */
    export interface ApiError {
      code: string
      message: string
      details?: Record<string, any>
      stack?: string  // 僅開發環境
    }

    /**
     * Health Check 回應格式
     */
    export interface HealthCheckResponse {
      status: 'ok' | 'degraded' | 'error'
      timestamp: string
      version: string
      services?: ServiceStatus[]
    }

    /**
     * 服務狀態(未來用於檢查 Azure 服務)
     */
    export interface ServiceStatus {
      name: string
      status: 'up' | 'down'
      responseTime?: number
    }
    ```
  - [ ] 加入 JSDoc 註解說明用途
  - [ ] 驗證型別定義無語法錯誤

- [ ] **Task 2: 建立錯誤處理工具函式** (AC: 3)
  - [ ] 建立 `lib/utils/` 目錄(如尚未存在)
  - [ ] 建立 `lib/utils/error-handler.ts` 檔案
  - [ ] 實作錯誤處理函式:
    ```typescript
    // lib/utils/error-handler.ts
    import { NextResponse } from 'next/server'
    import type { ApiError, ApiResponse } from '@/types/api'

    /**
     * 自訂 API 錯誤類別
     */
    export class AppError extends Error {
      constructor(
        public code: string,
        public message: string,
        public statusCode: number = 500,
        public details?: Record<string, any>
      ) {
        super(message)
        this.name = 'AppError'
      }
    }

    /**
     * 處理錯誤並返回標準格式的 NextResponse
     */
    export function handleError(error: unknown): NextResponse<ApiResponse> {
      console.error('[API Error]', error)

      // 自訂錯誤
      if (error instanceof AppError) {
        return NextResponse.json<ApiResponse>(
          {
            success: false,
            error: {
              code: error.code,
              message: error.message,
              details: error.details,
              stack: process.env.NODE_ENV === 'development' ? error.stack : undefined,
            },
            timestamp: new Date().toISOString(),
            requestId: crypto.randomUUID(),
          },
          { status: error.statusCode }
        )
      }

      // 未知錯誤
      const message = error instanceof Error ? error.message : 'Internal server error'
      return NextResponse.json<ApiResponse>(
        {
          success: false,
          error: {
            code: 'INTERNAL_ERROR',
            message,
            stack: process.env.NODE_ENV === 'development'
              ? (error instanceof Error ? error.stack : undefined)
              : undefined,
          },
          timestamp: new Date().toISOString(),
          requestId: crypto.randomUUID(),
        },
        { status: 500 }
      )
    }

    /**
     * 建立成功回應
     */
    export function createSuccessResponse<T>(
      data: T,
      status: number = 200
    ): NextResponse<ApiResponse<T>> {
      return NextResponse.json<ApiResponse<T>>(
        {
          success: true,
          data,
          timestamp: new Date().toISOString(),
        },
        { status }
      )
    }
    ```
  - [ ] 加入完整的 JSDoc 註解與使用範例
  - [ ] 執行 `pnpm build` 驗證 TypeScript 編譯成功

- [ ] **Task 3: 建立 Health Check API** (AC: 1, 2)
  - [ ] 建立 `app/api/` 目錄(如尚未存在)
  - [ ] 建立 `app/api/health/` 目錄
  - [ ] 建立 `app/api/health/route.ts` 檔案
  - [ ] 實作 GET endpoint:
    ```typescript
    // app/api/health/route.ts
    import { NextRequest } from 'next/server'
    import { createSuccessResponse, handleError } from '@/lib/utils/error-handler'
    import type { HealthCheckResponse } from '@/types/api'

    /**
     * Health Check API
     * GET /api/health
     *
     * 檢查 API 服務健康狀態
     */
    export async function GET(request: NextRequest) {
      try {
        const response: HealthCheckResponse = {
          status: 'ok',
          timestamp: new Date().toISOString(),
          version: '1.0.0',
        }

        return createSuccessResponse(response)

      } catch (error) {
        return handleError(error)
      }
    }

    /**
     * Runtime Configuration
     * 使用 Edge Runtime 以獲得更快的冷啟動
     */
    export const runtime = 'edge'
    ```
  - [ ] 加入詳細的 API 文件註解
  - [ ] 驗證檔案結構正確

- [ ] **Task 4: 本地測試 API** (AC: 5)
  - [ ] 啟動開發伺服器: `pnpm dev`
  - [ ] 使用瀏覽器測試:
    - 開啟 `http://localhost:3000/api/health`
    - 驗證返回 JSON 格式正確
    - 檢查 status, timestamp, version 欄位
  - [ ] 使用 curl 測試:
    ```bash
    curl -X GET http://localhost:3000/api/health
    ```
  - [ ] 預期輸出:
    ```json
    {
      "success": true,
      "data": {
        "status": "ok",
        "timestamp": "2025-10-14T10:00:00.000Z",
        "version": "1.0.0"
      },
      "timestamp": "2025-10-14T10:00:00.000Z"
    }
    ```
  - [ ] 驗證 HTTP Status Code 為 200
  - [ ] 檢查 Response Headers:
    - `Content-Type: application/json`
    - `Cache-Control: no-cache` (動態內容)

- [ ] **Task 5: 前端整合測試** (AC: 6)
  - [ ] 建立 `lib/api/` 目錄
  - [ ] 建立 `lib/api/client.ts` API 客戶端工具:
    ```typescript
    // lib/api/client.ts
    import type { ApiResponse } from '@/types/api'

    /**
     * API 客戶端基礎 URL
     */
    const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || '/api'

    /**
     * 通用 API 請求函式
     */
    export async function apiRequest<T>(
      endpoint: string,
      options?: RequestInit
    ): Promise<T> {
      const url = `${API_BASE_URL}${endpoint}`

      const response = await fetch(url, {
        ...options,
        headers: {
          'Content-Type': 'application/json',
          ...options?.headers,
        },
      })

      const data: ApiResponse<T> = await response.json()

      if (!response.ok || !data.success) {
        throw new Error(data.error?.message || 'API request failed')
      }

      return data.data as T
    }

    /**
     * Health Check 請求
     */
    export async function checkHealth() {
      return apiRequest('/health')
    }
    ```
  - [ ] 在 `app/page.tsx` 加入 Health Check 狀態顯示:
    ```tsx
    'use client'

    import { useEffect, useState } from 'react'
    import { Button } from '@/components/ui/Button'
    import { checkHealth } from '@/lib/api/client'
    import type { HealthCheckResponse } from '@/types/api'

    export default function Home() {
      const [healthStatus, setHealthStatus] = useState<HealthCheckResponse | null>(null)
      const [isLoading, setIsLoading] = useState(false)
      const [error, setError] = useState<string | null>(null)

      const fetchHealthStatus = async () => {
        setIsLoading(true)
        setError(null)

        try {
          const status = await checkHealth()
          setHealthStatus(status)
        } catch (err) {
          setError(err instanceof Error ? err.message : 'Failed to fetch health status')
        } finally {
          setIsLoading(false)
        }
      }

      useEffect(() => {
        fetchHealthStatus()
      }, [])

      return (
        <main className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-b from-background to-gray-900">
          {/* 原有內容 */}
          <div className="text-center space-y-8 p-8">
            {/* ... Logo & Title ... */}

            {/* API Health Status */}
            <div className="mt-12 p-6 bg-gray-800/50 rounded-lg border border-gray-700 max-w-md mx-auto">
              <h3 className="text-lg font-semibold text-white mb-4">API 健康狀態</h3>

              {isLoading && (
                <div className="text-gray-400">檢查中...</div>
              )}

              {error && (
                <div className="text-red-400">
                  ❌ {error}
                </div>
              )}

              {healthStatus && (
                <div className="space-y-2">
                  <div className="flex items-center justify-between">
                    <span className="text-gray-400">狀態:</span>
                    <span className={`font-medium ${
                      healthStatus.status === 'ok' ? 'text-green-400' : 'text-red-400'
                    }`}>
                      {healthStatus.status === 'ok' ? '✅ 正常' : '❌ 異常'}
                    </span>
                  </div>
                  <div className="flex items-center justify-between">
                    <span className="text-gray-400">版本:</span>
                    <span className="text-white">{healthStatus.version}</span>
                  </div>
                  <div className="flex items-center justify-between">
                    <span className="text-gray-400">時間:</span>
                    <span className="text-white text-sm">
                      {new Date(healthStatus.timestamp).toLocaleString('zh-TW')}
                    </span>
                  </div>
                </div>
              )}

              <Button
                size="sm"
                variant="outline"
                onClick={fetchHealthStatus}
                isLoading={isLoading}
                className="mt-4"
              >
                重新檢查
              </Button>
            </div>

            {/* 原有內容繼續 */}
          </div>
        </main>
      )
    }
    ```
  - [ ] 驗證前端正確顯示 API 健康狀態
  - [ ] 測試「重新檢查」按鈕功能正常

- [ ] **Task 6: 錯誤場景測試** (AC: 3)
  - [ ] 測試錯誤處理:
    - 故意在 Health API 中拋出錯誤
    - 驗證返回標準錯誤格式
    - 檢查 HTTP Status Code 為 500
  - [ ] 測試範例錯誤:
    ```typescript
    // app/api/health/route.ts (測試用)
    export async function GET(request: NextRequest) {
      try {
        // 測試錯誤
        throw new AppError('TEST_ERROR', 'This is a test error', 500)

        // ... original code
      } catch (error) {
        return handleError(error)
      }
    }
    ```
  - [ ] 預期錯誤輸出:
    ```json
    {
      "success": false,
      "error": {
        "code": "TEST_ERROR",
        "message": "This is a test error"
      },
      "timestamp": "2025-10-14T10:00:00.000Z",
      "requestId": "uuid-string"
    }
    ```
  - [ ] 驗證前端正確顯示錯誤訊息
  - [ ] 測試完成後恢復原始程式碼

- [ ] **Task 7: 文件與註解完善** (AC: 1-6)
  - [ ] 在 `app/api/health/route.ts` 加入完整 API 文件:
    ```typescript
    /**
     * @swagger
     * /api/health:
     *   get:
     *     summary: Health check endpoint
     *     description: 檢查 API 服務健康狀態
     *     tags:
     *       - Health
     *     responses:
     *       200:
     *         description: Service is healthy
     *         content:
     *           application/json:
     *             schema:
     *               type: object
     *               properties:
     *                 status:
     *                   type: string
     *                   example: ok
     *                 timestamp:
     *                   type: string
     *                   format: date-time
     *                 version:
     *                   type: string
     *                   example: 1.0.0
     */
    ```
  - [ ] 在 README.md 加入 API 使用說明
  - [ ] 建立 API 測試清單於 `docs/api-testing.md`

---

## Dev Notes

### 相關來源樹 (Source Tree)

根據架構文件,API 與錯誤處理的檔案結構應如下:

```
avatar-chat-poc/
├── app/
│   ├── api/
│   │   └── health/
│   │       └── route.ts           # ✅ Health Check API (Task 3)
│   └── page.tsx                   # ✅ 前端整合 (Task 5)
│
├── lib/
│   ├── api/
│   │   └── client.ts              # ✅ API 客戶端工具 (Task 5)
│   └── utils/
│       └── error-handler.ts       # ✅ 錯誤處理工具 (Task 2)
│
└── types/
    └── api.ts                     # ✅ API 型別定義 (Task 1)
```

### 技術實作細節

**Next.js API Routes 架構**:
- **檔案位置**: `app/api/**/route.ts` (App Router 規範)
- **HTTP Methods**: 使用 named export (GET, POST, PUT, DELETE)
- **Runtime**: 支援 Node.js 與 Edge Runtime
  - Edge Runtime: 更快冷啟動,限制較多(無 Node.js API)
  - Node.js Runtime: 完整 Node.js 功能,冷啟動較慢

**Edge Runtime 選擇理由**:
```typescript
export const runtime = 'edge'
```
- ✅ Health Check API 無需 Node.js 特定功能
- ✅ 冷啟動時間 < 100ms (vs Node.js ~500ms)
- ✅ 全球 Edge 部署,降低延遲
- ✅ 符合 Serverless 最佳實踐

**錯誤處理策略**:
1. **統一錯誤格式**: 所有 API 返回相同結構
2. **HTTP Status Code 對應**:
   - 200: 成功
   - 400: 客戶端錯誤(驗證失敗)
   - 500: 伺服器錯誤
3. **錯誤分類**:
   - `AppError`: 可預期的業務邏輯錯誤
   - 其他: 未預期的系統錯誤
4. **開發 vs 生產**:
   - 開發: 返回完整 stack trace
   - 生產: 隱藏敏感資訊

**API 回應格式設計**:
```typescript
interface ApiResponse<T> {
  success: boolean    // 快速判斷成功/失敗
  data?: T           // 成功時的資料
  error?: ApiError   // 失敗時的錯誤資訊
  timestamp: string  // 伺服器時間
  requestId?: string // 追蹤請求(Debug 用)
}
```

**為何使用 wrapper 格式而非直接返回資料？**
- ✅ 前端可統一處理回應(檢查 `success`)
- ✅ 錯誤資訊結構化,便於顯示
- ✅ 包含 timestamp 與 requestId,便於 Debug
- ✅ 未來可擴展(加入 pagination, metadata)

### 架構決策

1. **為何使用 `createSuccessResponse` 而非直接 `NextResponse.json`？**
   - ✅ 統一回應格式,減少手動錯誤
   - ✅ 自動加入 timestamp 與標準結構
   - ✅ 便於未來擴展(如加入 API 版本號)

2. **為何 `handleError` 使用 `crypto.randomUUID()`？**
   - ✅ 生成唯一 requestId 用於追蹤
   - ✅ 便於關聯前端錯誤與後端日誌
   - ✅ Edge Runtime 支援 `crypto` Web API

3. **為何前端使用 `use client`？**
   - ✅ Health Check 需要 `useEffect` (客戶端 hook)
   - ✅ 動態資料載入,無法使用 Server Component
   - ✅ 互動功能(重新檢查按鈕)需要客戶端 JavaScript

4. **為何 API Client 使用 `/api` 相對路徑？**
   - ✅ 本地開發與生產環境統一
   - ✅ Next.js 自動處理 API Routes
   - ✅ 避免 CORS 問題(同源)

### Testing

**測試框架**: Vitest + Supertest (API 測試)

**測試範圍**:
1. ✅ Health API 測試:
   - GET /api/health 返回 200
   - 回應包含 status, timestamp, version
   - status 值為 'ok'
   - 回應格式符合 ApiResponse<HealthCheckResponse>

2. ✅ 錯誤處理測試:
   - AppError 正確轉換為 HTTP 回應
   - 未知錯誤返回 500
   - 開發環境包含 stack trace
   - 生產環境隱藏 stack trace

3. ✅ API Client 測試:
   - apiRequest() 正確處理成功回應
   - apiRequest() 正確處理錯誤回應
   - checkHealth() 返回 HealthCheckResponse

**測試執行方式**:
```bash
# 執行 API 測試
pnpm test app/api

# 執行錯誤處理測試
pnpm test lib/utils/error-handler
```

### 效能考量

**API 回應時間目標**:
- Health Check: < 100ms
- 其他 API: < 2s (P95)

**優化策略**:
- ✅ 使用 Edge Runtime (更快冷啟動)
- ✅ 避免不必要的計算(Health Check 僅返回靜態資訊)
- ✅ 未來加入 Redis 快取(如需要)

**監控指標**:
- Response Time (P50, P95, P99)
- Error Rate (< 1%)
- Request Volume
- Cold Start Time (Edge Runtime)

### 依賴關係

**前置條件**:
- ✅ Story 1.1 已完成 (Next.js 專案已初始化)
- ✅ Story 1.3 已完成 (Button 組件可用於前端測試)

**新增依賴**:
無 (使用 Next.js 內建功能)

**後續 Story 依賴**:
- Story 1.5: CI/CD 會測試 Health API
- Story 3.3: Chat API 會使用相同的錯誤處理機制
- Story 3.5: TTS API 會使用相同的 API Response 格式
- Story 5.2: 錯誤處理完善會擴展 error-handler.ts

### 安全性考量

**API 安全**:
- ✅ Health Check API 無敏感資訊
- ✅ 生產環境隱藏 stack trace
- ✅ 未來加入 Rate Limiting (防濫用)

**錯誤訊息安全**:
- ✅ 不洩漏內部路徑或系統資訊
- ✅ 使用通用錯誤訊息(使用者友善)
- ✅ 詳細錯誤僅記錄於後端日誌

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-14 | 1.0 | 建立 Story 1.4 草稿 | SM Agent |

---

## Dev Agent Record

*(此部分由 Dev Agent 在實作時填寫)*

### Agent Model Used
_待填寫_

### Debug Log References
_待填寫_

### Completion Notes List
_待填寫_

### File List
_待填寫_

---

## QA Results

*(此部分由 QA Agent 在審核時填寫)*

_待填寫_

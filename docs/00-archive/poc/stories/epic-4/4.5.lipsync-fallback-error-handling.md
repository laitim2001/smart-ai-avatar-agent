# Story 4.5: Lip Sync 降級方案與錯誤處理

## Status
Draft

---

## Story

**As a** 開發者,
**I want** 當 Lip Sync 失敗時有優雅的降級方案,
**so that** 使用者仍可正常使用對話功能（僅無嘴型）。

---

## Acceptance Criteria

1. 捕捉 Lip Sync 分析錯誤（如：音訊格式不支援）
2. 錯誤發生時：Console 記錄錯誤（開發模式）、音訊正常播放但不驅動嘴型、Avatar 保持微笑表情（fallback）
3. 使用者無感知崩潰，對話繼續
4. 提供設定選項：「關閉 Lip Sync」（節省效能）
5. 測試：故意傳入錯誤音訊，系統不崩潰，僅跳過嘴型

---

## Tasks / Subtasks

- [ ] **Task 1: 建立錯誤處理類型定義** (AC: 1)
  - [ ] 更新 `types/lipsync.ts` 加入錯誤類型
  - [ ] 定義 Lip Sync 錯誤類型：
    ```typescript
    /**
     * Lip Sync 錯誤類型
     */
    export enum LipSyncErrorType {
      /** 音訊載入失敗 */
      AUDIO_LOAD_FAILED = 'AUDIO_LOAD_FAILED',
      /** 音訊解碼失敗 */
      AUDIO_DECODE_FAILED = 'AUDIO_DECODE_FAILED',
      /** 音訊分析失敗 */
      AUDIO_ANALYSIS_FAILED = 'AUDIO_ANALYSIS_FAILED',
      /** Blendshape 初始化失敗 */
      BLENDSHAPE_INIT_FAILED = 'BLENDSHAPE_INIT_FAILED',
      /** Blendshape 應用失敗 */
      BLENDSHAPE_APPLY_FAILED = 'BLENDSHAPE_APPLY_FAILED',
      /** 未知錯誤 */
      UNKNOWN_ERROR = 'UNKNOWN_ERROR'
    }

    /**
     * Lip Sync 錯誤詳情
     */
    export interface LipSyncError {
      /** 錯誤類型 */
      type: LipSyncErrorType;
      /** 錯誤訊息 */
      message: string;
      /** 原始錯誤物件 */
      originalError?: Error;
      /** 錯誤發生時間 */
      timestamp: Date;
      /** 是否為致命錯誤（需完全降級） */
      isFatal: boolean;
    }

    /**
     * Lip Sync 配置（含錯誤處理選項）
     */
    export interface LipSyncConfig {
      /** 是否啟用 Lip Sync */
      enabled: boolean;
      /** 錯誤時是否自動降級 */
      autoFallback: boolean;
      /** 降級時的 Avatar 表情 */
      fallbackExpression: VisemeType;
      /** 是否在 console 記錄錯誤 */
      logErrors: boolean;
      /** 錯誤回調函式 */
      onError?: (error: LipSyncError) => void;
    }

    /**
     * 預設 Lip Sync 配置
     */
    export const DEFAULT_LIPSYNC_CONFIG: LipSyncConfig = {
      enabled: true,
      autoFallback: true,
      fallbackExpression: 'neutral', // 預設閉嘴
      logErrors: true,
      onError: undefined
    };
    ```
  - [ ] 加入 JSDoc 註解說明錯誤處理策略
  - [ ] 驗證型別定義無 TypeScript 錯誤

- [ ] **Task 2: 更新 AudioAnalyser 加入錯誤處理** (AC: 1, 2)
  - [ ] 開啟 `lib/three/lipsync.ts`
  - [ ] 包裝所有可能失敗的操作：
    ```typescript
    import { LipSyncErrorType, type LipSyncError } from '@/types/lipsync';

    export class AudioAnalyser {
      // ... existing code ...

      /**
       * 從 URL 載入音訊並解碼（含錯誤處理）
       */
      async loadAudioFromUrl(audioUrl: string): Promise<AudioBuffer> {
        try {
          console.log('[LipSync] Loading audio from:', audioUrl);

          const response = await fetch(audioUrl);
          if (!response.ok) {
            throw this.createError(
              LipSyncErrorType.AUDIO_LOAD_FAILED,
              `Failed to fetch audio: ${response.statusText}`,
              true
            );
          }

          const arrayBuffer = await response.arrayBuffer();

          try {
            const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
            console.log('[LipSync] Audio loaded successfully');
            return audioBuffer;

          } catch (decodeError) {
            throw this.createError(
              LipSyncErrorType.AUDIO_DECODE_FAILED,
              'Failed to decode audio data (unsupported format?)',
              true,
              decodeError as Error
            );
          }

        } catch (error) {
          // 重新拋出已處理的錯誤
          if (this.isLipSyncError(error)) {
            throw error;
          }

          // 處理未預期的錯誤
          throw this.createError(
            LipSyncErrorType.UNKNOWN_ERROR,
            `Unexpected error: ${(error as Error).message}`,
            true,
            error as Error
          );
        }
      }

      /**
       * 分析音訊緩衝區（含錯誤處理）
       */
      async analyseAudioBuffer(audioBuffer: AudioBuffer): Promise<VisemeData[]> {
        try {
          // ... existing analysis logic ...
          return visemeTimeline;

        } catch (error) {
          throw this.createError(
            LipSyncErrorType.AUDIO_ANALYSIS_FAILED,
            `Failed to analyse audio: ${(error as Error).message}`,
            false, // 非致命，可降級
            error as Error
          );
        }
      }

      /**
       * 建立 Lip Sync 錯誤物件
       */
      private createError(
        type: LipSyncErrorType,
        message: string,
        isFatal: boolean,
        originalError?: Error
      ): LipSyncError {
        return {
          type,
          message,
          originalError,
          timestamp: new Date(),
          isFatal
        };
      }

      /**
       * 檢查是否為 Lip Sync 錯誤
       */
      private isLipSyncError(error: unknown): error is LipSyncError {
        return (
          typeof error === 'object' &&
          error !== null &&
          'type' in error &&
          'message' in error &&
          'isFatal' in error
        );
      }
    }
    ```
  - [ ] 加入錯誤日誌記錄
  - [ ] 測試錯誤拋出與捕捉機制

- [ ] **Task 3: 更新 BlendshapeController 加入錯誤處理** (AC: 2)
  - [ ] 開啟 `lib/three/blendshape-controller.ts`
  - [ ] 加入安全檢查與錯誤處理：
    ```typescript
    export class BlendshapeController {
      // ... existing code ...

      /**
       * 初始化控制器（含錯誤處理）
       */
      initialize(avatarMesh: THREE.SkinnedMesh): boolean {
        try {
          if (!avatarMesh) {
            throw this.createError(
              LipSyncErrorType.BLENDSHAPE_INIT_FAILED,
              'Avatar mesh is null or undefined',
              true
            );
          }

          if (!avatarMesh.morphTargetDictionary || !avatarMesh.morphTargetInfluences) {
            throw this.createError(
              LipSyncErrorType.BLENDSHAPE_INIT_FAILED,
              'Avatar mesh does not have morph targets',
              true
            );
          }

          this.mesh = avatarMesh;
          this.morphTargetDictionary = avatarMesh.morphTargetDictionary;
          this.morphTargetInfluences = avatarMesh.morphTargetInfluences;

          console.log('[BlendshapeController] Initialized successfully');
          return true;

        } catch (error) {
          console.error('[BlendshapeController] Initialization failed:', error);
          return false;
        }
      }

      /**
       * 應用 Viseme（含錯誤處理）
       */
      applySmoothVisemeWithEasing(
        viseme: VisemeType,
        targetWeight: number,
        transitionDuration: number = 50
      ): void {
        try {
          if (!this.mesh || !this.morphTargetDictionary || !this.morphTargetInfluences) {
            throw this.createError(
              LipSyncErrorType.BLENDSHAPE_APPLY_FAILED,
              'Controller not initialized',
              false
            );
          }

          // ... existing viseme application logic ...

        } catch (error) {
          // 靜默失敗，不中斷動畫循環
          console.warn('[BlendshapeController] Failed to apply viseme:', error);
        }
      }

      /**
       * 建立 Lip Sync 錯誤物件（與 AudioAnalyser 相同）
       */
      private createError(
        type: LipSyncErrorType,
        message: string,
        isFatal: boolean
      ): LipSyncError {
        return {
          type,
          message,
          timestamp: new Date(),
          isFatal
        };
      }
    }
    ```
  - [ ] 測試 blendshape 錯誤處理邏輯

- [ ] **Task 4: 更新 LipSyncController 實作降級方案** (AC: 2, 3)
  - [ ] 開啟 `components/avatar/LipSyncController.tsx`
  - [ ] 加入降級狀態管理：
    ```typescript
    import { DEFAULT_LIPSYNC_CONFIG, type LipSyncConfig, type LipSyncError } from '@/types/lipsync';

    interface LipSyncControllerProps {
      avatarMeshRef: React.MutableRefObject<THREE.SkinnedMesh | null>;
      enabled?: boolean;
      config?: Partial<LipSyncConfig>; // 新增配置選項
    }

    export default function LipSyncController({
      avatarMeshRef,
      enabled = true,
      config: userConfig = {}
    }: LipSyncControllerProps) {
      const config = { ...DEFAULT_LIPSYNC_CONFIG, ...userConfig };

      // 降級狀態（當錯誤發生時設為 true）
      const [isFallbackMode, setIsFallbackMode] = useState(false);

      const {
        applyVisemeWithEasing,
        updateTransitions,
        initializeController,
        applyViseme
      } = useBlendshapeController();

      // ... existing code ...

      // 錯誤處理函式
      const handleLipSyncError = useCallback((error: LipSyncError) => {
        if (config.logErrors) {
          console.error('[LipSyncController] Error occurred:', {
            type: error.type,
            message: error.message,
            timestamp: error.timestamp,
            isFatal: error.isFatal
          });
        }

        // 呼叫使用者提供的錯誤回調
        config.onError?.(error);

        // 若為致命錯誤，啟用降級模式
        if (error.isFatal && config.autoFallback) {
          console.warn('[LipSyncController] Entering fallback mode (Lip Sync disabled)');
          setIsFallbackMode(true);

          // 設定 Avatar 為降級表情（預設 neutral）
          applyViseme(config.fallbackExpression, 0.2); // 微笑（weight 0.2）
        }

      }, [config, applyViseme]);

      // 初始化（含錯誤處理）
      useEffect(() => {
        if (avatarMeshRef.current && enabled && !isFallbackMode) {
          const success = initializeController(avatarMeshRef.current);

          if (!success) {
            handleLipSyncError({
              type: LipSyncErrorType.BLENDSHAPE_INIT_FAILED,
              message: 'Failed to initialize blendshape controller',
              timestamp: new Date(),
              isFatal: true
            });
          }
        }
      }, [avatarMeshRef, enabled, isFallbackMode, initializeController, handleLipSyncError]);

      // 每幀更新邏輯（含降級檢查）
      useFrame(() => {
        if (!enabled || isFallbackMode) {
          return; // 降級模式下不執行 Lip Sync
        }

        try {
          // 1. 更新 Easing 過渡動畫
          updateTransitions();

          // 2. Lip Sync 同步邏輯
          if (isPlaying && audioContext && visemeTimeline.length > 0) {
            const currentPlaybackTime = audioContext.currentTime - playbackStartTime;
            const viseme = findVisemeAtTime(visemeTimeline, currentPlaybackTime, currentIndexRef.current);

            if (viseme) {
              applyVisemeWithEasing(viseme.viseme, viseme.weight, 50);

              const newIndex = visemeTimeline.findIndex(v => v === viseme);
              if (newIndex !== -1) {
                currentIndexRef.current = newIndex;
              }
            }
          }

        } catch (error) {
          handleLipSyncError({
            type: LipSyncErrorType.BLENDSHAPE_APPLY_FAILED,
            message: `Failed to apply lip sync: ${(error as Error).message}`,
            originalError: error as Error,
            timestamp: new Date(),
            isFatal: false // 非致命，下一幀繼續嘗試
          });
        }
      });

      return null;
    }
    ```
  - [ ] 測試降級模式觸發與恢復

- [ ] **Task 5: 更新 playTTSWithLipSync 加入錯誤處理** (AC: 1, 2, 3)
  - [ ] 開啟 `lib/api/chat.ts`
  - [ ] 包裝 Viseme 分析錯誤處理：
    ```typescript
    export async function playTTSWithLipSync(text: string) {
      try {
        console.log('[TTS] Generating speech...', text);

        // 1. 呼叫 TTS API
        const response = await fetch('/api/tts', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text })
        });

        if (!response.ok) {
          throw new Error('TTS API failed');
        }

        // 2. 取得音訊 Blob
        const audioBlob = await response.blob();
        const audioUrl = URL.createObjectURL(audioBlob);

        // 3. 分析音訊產生 Viseme 時間軸（含錯誤處理）
        let visemeTimeline: VisemeData[] = [];
        let lipSyncEnabled = true;

        try {
          console.log('[TTS] Analysing audio for visemes...');
          visemeTimeline = await generateVisemeTimeline(audioUrl);

          console.log('[TTS] Viseme timeline generated:', {
            dataPoints: visemeTimeline.length
          });

        } catch (error) {
          console.warn('[TTS] Viseme analysis failed, playing audio only:', error);
          lipSyncEnabled = false; // 降級：僅播放音訊，無 Lip Sync

          // 設定空的 viseme 時間軸（LipSyncController 會進入降級模式）
          visemeTimeline = [];
        }

        // 4. 將 Viseme 時間軸儲存到 audioStore（即使為空陣列）
        useAudioStore.getState().setVisemeTimeline(visemeTimeline);

        // 5. 載入並播放音訊（無論 Lip Sync 是否成功）
        const audioContext = new AudioContext();
        const arrayBuffer = await audioBlob.arrayBuffer();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

        // 6. 播放音訊
        useAudioStore.getState().playAudio(audioBuffer);

        if (lipSyncEnabled) {
          console.log('[TTS] Playback started with Lip Sync');
        } else {
          console.log('[TTS] Playback started (Lip Sync disabled due to error)');
        }

      } catch (error) {
        console.error('[TTS] Failed to play TTS:', error);

        // TTS 完全失敗，拋出錯誤供上層處理
        throw error;
      }
    }
    ```
  - [ ] 測試 Viseme 分析失敗時的降級行為

- [ ] **Task 6: 建立 Lip Sync 設定 UI** (AC: 4)
  - [ ] 建立 `components/settings/LipSyncSettings.tsx` 設定組件
  - [ ] 實作設定介面：
    ```typescript
    'use client';

    import { useState } from 'react';
    import { DEFAULT_LIPSYNC_CONFIG, type LipSyncConfig } from '@/types/lipsync';

    interface LipSyncSettingsProps {
      initialConfig?: Partial<LipSyncConfig>;
      onChange?: (config: LipSyncConfig) => void;
    }

    export default function LipSyncSettings({
      initialConfig = {},
      onChange
    }: LipSyncSettingsProps) {
      const [config, setConfig] = useState<LipSyncConfig>({
        ...DEFAULT_LIPSYNC_CONFIG,
        ...initialConfig
      });

      const handleToggle = (key: keyof LipSyncConfig) => {
        const newConfig = { ...config, [key]: !config[key] };
        setConfig(newConfig);
        onChange?.(newConfig);
      };

      return (
        <div className="bg-white rounded-lg shadow p-6 space-y-4">
          <h3 className="text-lg font-semibold text-gray-900">
            Lip Sync 設定
          </h3>

          {/* 啟用/關閉 Lip Sync */}
          <div className="flex items-center justify-between">
            <div>
              <label className="text-sm font-medium text-gray-700">
                啟用 Lip Sync
              </label>
              <p className="text-xs text-gray-500">
                關閉以節省效能（Avatar 保持微笑）
              </p>
            </div>
            <button
              onClick={() => handleToggle('enabled')}
              className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${
                config.enabled ? 'bg-blue-600' : 'bg-gray-200'
              }`}
            >
              <span
                className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
                  config.enabled ? 'translate-x-6' : 'translate-x-1'
                }`}
              />
            </button>
          </div>

          {/* 自動降級 */}
          <div className="flex items-center justify-between">
            <div>
              <label className="text-sm font-medium text-gray-700">
                自動降級
              </label>
              <p className="text-xs text-gray-500">
                錯誤發生時自動關閉 Lip Sync
              </p>
            </div>
            <button
              onClick={() => handleToggle('autoFallback')}
              disabled={!config.enabled}
              className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${
                config.autoFallback && config.enabled
                  ? 'bg-blue-600'
                  : 'bg-gray-200'
              } ${!config.enabled ? 'opacity-50 cursor-not-allowed' : ''}`}
            >
              <span
                className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
                  config.autoFallback && config.enabled ? 'translate-x-6' : 'translate-x-1'
                }`}
              />
            </button>
          </div>

          {/* Debug 日誌 */}
          <div className="flex items-center justify-between">
            <div>
              <label className="text-sm font-medium text-gray-700">
                Console 錯誤日誌
              </label>
              <p className="text-xs text-gray-500">
                在 Console 顯示 Lip Sync 錯誤（開發用）
              </p>
            </div>
            <button
              onClick={() => handleToggle('logErrors')}
              className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${
                config.logErrors ? 'bg-blue-600' : 'bg-gray-200'
              }`}
            >
              <span
                className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
                  config.logErrors ? 'translate-x-6' : 'translate-x-1'
                }`}
              />
            </button>
          </div>

          {/* 當前狀態顯示 */}
          <div className="mt-6 pt-4 border-t border-gray-200">
            <div className="text-sm text-gray-600 space-y-1">
              <p>
                狀態: <span className={`font-medium ${config.enabled ? 'text-green-600' : 'text-gray-400'}`}>
                  {config.enabled ? '✓ 啟用' : '✗ 關閉'}
                </span>
              </p>
              <p className="text-xs text-gray-500">
                關閉 Lip Sync 可減少 CPU 使用約 5%
              </p>
            </div>
          </div>
        </div>
      );
    }
    ```
  - [ ] 整合到主頁面或設定頁面
  - [ ] 測試設定變更立即生效

- [ ] **Task 7: 建立錯誤測試工具** (AC: 5)
  - [ ] 建立 `scripts/test/test-lipsync-errors.ts` 錯誤測試腳本
  - [ ] 實作錯誤模擬：
    ```typescript
    /**
     * Lip Sync 錯誤處理測試腳本
     * 用於驗證降級方案是否正常運作
     */

    import { generateVisemeTimeline } from '@/lib/three/lipsync';

    async function testLipSyncErrorHandling() {
      console.log('=== Lip Sync Error Handling Test ===\n');

      // 測試 1：錯誤的音訊 URL
      console.log('Test 1: Invalid audio URL');
      try {
        await generateVisemeTimeline('https://invalid-url.com/audio.mp3');
        console.log('❌ FAIL: Should have thrown error');
      } catch (error) {
        console.log('✅ PASS: Error caught:', error);
      }

      // 測試 2：不支援的音訊格式
      console.log('\nTest 2: Unsupported audio format');
      try {
        // 模擬不支援的格式（如 .wav 未正確編碼）
        const invalidBlob = new Blob(['invalid audio data'], { type: 'audio/wav' });
        const invalidUrl = URL.createObjectURL(invalidBlob);

        await generateVisemeTimeline(invalidUrl);
        console.log('❌ FAIL: Should have thrown error');
      } catch (error) {
        console.log('✅ PASS: Error caught:', error);
      }

      // 測試 3：空音訊檔案
      console.log('\nTest 3: Empty audio file');
      try {
        const emptyBlob = new Blob([], { type: 'audio/mp3' });
        const emptyUrl = URL.createObjectURL(emptyBlob);

        await generateVisemeTimeline(emptyUrl);
        console.log('❌ FAIL: Should have thrown error');
      } catch (error) {
        console.log('✅ PASS: Error caught:', error);
      }

      console.log('\n=== All Error Tests Completed ===');
    }

    // 執行測試
    testLipSyncErrorHandling();
    ```
  - [ ] 執行測試腳本：`pnpm tsx scripts/test/test-lipsync-errors.ts`
  - [ ] 驗證所有錯誤正確拋出與捕捉

- [ ] **Task 8: 端到端降級測試** (AC: 2, 3, 5)
  - [ ] 準備測試場景：
    ```bash
    # 測試場景 1：模擬網路錯誤
    # 方法：修改 TTS API 返回 404

    # 測試場景 2：模擬音訊解碼錯誤
    # 方法：傳入損壞的音訊檔案

    # 測試場景 3：模擬 Blendshape 初始化失敗
    # 方法：使用無 morph targets 的 Avatar 模型
    ```
  - [ ] 執行端到端測試：
    ```bash
    pnpm dev

    # 測試步驟：
    1. 觸發錯誤（如修改 TTS API）
    2. 觀察 Console 錯誤日誌
    3. 確認音訊仍正常播放
    4. 確認 Avatar 保持降級表情（neutral/微笑）
    5. 確認對話功能未中斷
    6. 確認無頁面崩潰或白屏
    ```
  - [ ] 記錄測試結果：
    ```markdown
    # Lip Sync 降級測試結果

    ## 測試場景 1：網路錯誤
    - ✅ Console 記錄錯誤
    - ✅ 音訊正常播放（無 Lip Sync）
    - ✅ Avatar 保持 neutral 表情
    - ✅ 對話功能繼續

    ## 測試場景 2：音訊解碼失敗
    - ✅ Console 記錄錯誤
    - ✅ 降級為純對話（無音訊無 Lip Sync）
    - ✅ 使用者收到友善錯誤提示

    ## 測試場景 3：Blendshape 初始化失敗
    - ✅ Console 記錄錯誤
    - ✅ 音訊正常播放
    - ✅ Avatar 靜止（無任何動畫）
    - ✅ 對話功能繼續
    ```
  - [ ] 驗證所有降級場景使用者體驗無崩潰

---

## Dev Notes

### 相關來源樹（Source Tree）

```
avatar-chat-poc/
├── types/
│   └── lipsync.ts                        # 更新錯誤型別 (本 Story)
├── lib/
│   ├── three/
│   │   ├── lipsync.ts                    # 更新錯誤處理 (本 Story)
│   │   └── blendshape-controller.ts      # 更新錯誤處理 (本 Story)
│   └── api/
│       └── chat.ts                       # 更新 TTS 錯誤處理 (本 Story)
├── components/
│   ├── avatar/
│   │   └── LipSyncController.tsx         # 實作降級方案 (本 Story)
│   └── settings/
│       └── LipSyncSettings.tsx           # 設定 UI (本 Story)
└── scripts/
    └── test/
        └── test-lipsync-errors.ts        # 錯誤測試腳本 (本 Story)
```

### 技術實作細節

**錯誤處理策略**：

```typescript
// 三層錯誤處理架構

// Layer 1: 底層函式（拋出 LipSyncError）
async function loadAudio(url) {
  if (invalid) {
    throw { type: 'AUDIO_LOAD_FAILED', isFatal: true };
  }
}

// Layer 2: 整合函式（捕捉並降級）
async function playTTSWithLipSync(text) {
  try {
    visemes = await analyseAudio(audio);
  } catch (error) {
    console.warn('Viseme failed, playing audio only');
    visemes = []; // 降級
  }
}

// Layer 3: UI 組件（顯示降級狀態）
function LipSyncController() {
  if (isFallbackMode) {
    return; // 跳過 Lip Sync 邏輯
  }
}
```

**降級模式類型**：

| 錯誤類型 | 降級策略 | 使用者體驗 |
|---------|---------|-----------|
| 音訊載入失敗 | 顯示錯誤訊息 | 無音訊無 Lip Sync |
| 音訊解碼失敗 | 播放失敗提示 | 僅文字對話 |
| Viseme 分析失敗 | 播放音訊 | 有音訊無 Lip Sync |
| Blendshape 初始化失敗 | Avatar 靜止 | 有音訊無動畫 |
| Blendshape 應用失敗 | 繼續嘗試 | 可能有斷斷續續的 Lip Sync |

### 重要架構決策

1. **為何需要多層錯誤處理？**
   - ✅ 彈性降級：不同層級錯誤有不同降級策略
   - ✅ 使用者體驗：確保部分功能失敗不影響整體
   - ✅ Debug 友善：每層記錄錯誤便於排查
   - ✅ 漸進式增強：核心功能（音訊）優先保證

2. **為何使用 isFatal 標記？**
   - ✅ 區分嚴重性：致命錯誤需完全降級，非致命可重試
   - ✅ 自動決策：系統自動判斷是否進入降級模式
   - ✅ 彈性處理：開發者可自訂致命性判斷邏輯
   - 📊 範例：音訊載入失敗=致命，單幀 blendshape 失敗=非致命

3. **為何提供手動關閉 Lip Sync 選項？**
   - ✅ 效能優化：低階裝置可關閉節省 CPU
   - ✅ 使用者選擇：部分使用者可能不喜歡 Lip Sync
   - ✅ Debug 工具：開發時可快速關閉排查問題
   - ✅ 降級預覽：測試降級模式 UI

### Testing

**測試框架**: 手動錯誤模擬測試

**測試範圍**:
1. ✅ 音訊載入錯誤捕捉
2. ✅ 音訊解碼錯誤捕捉
3. ✅ Viseme 分析錯誤捕捉
4. ✅ Blendshape 初始化錯誤捕捉
5. ✅ 降級模式自動啟用
6. ✅ 使用者體驗無崩潰

**測試執行方式**:
```bash
# 1. 單元測試（錯誤拋出）
pnpm tsx scripts/test/test-lipsync-errors.ts

# 2. 端到端測試（降級行為）
pnpm dev
# 手動觸發各種錯誤場景
# 驗證降級行為符合預期

# 3. 設定 UI 測試
# 切換 Lip Sync 開關
# 驗證立即生效
```

**驗證清單**:
- [ ] 所有錯誤類型正確拋出
- [ ] 錯誤日誌清晰易懂
- [ ] 降級模式正確觸發
- [ ] 音訊播放不受影響
- [ ] Avatar 保持降級表情
- [ ] 對話功能繼續運作
- [ ] 無頁面崩潰或白屏

### 效能考量

**降級模式效能提升**:
- **CPU 使用**: -5%（關閉 Lip Sync）
- **記憶體**: -10MB（無 Viseme 數據）
- **FPS**: +2-5（無 blendshape 計算）

### 依賴關係

**前置條件**:
- ✅ Story 4.1-4.4（所有 Lip Sync 功能）

**後續使用**:
- Epic 5 的錯誤處理會參考本 Story 的降級策略

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-14 | 1.0 | 建立 Story 4.5 草稿 | SM Agent |

---

## Dev Agent Record

*(此部分由 Dev Agent 在實作時填寫)*

### Agent Model Used
_待填寫_

### Debug Log References
_待填寫_

### Completion Notes List
_待填寫_

### File List
_待填寫_

---

## QA Results

*(此部分由 QA Agent 在審核時填寫)*

_待填寫_

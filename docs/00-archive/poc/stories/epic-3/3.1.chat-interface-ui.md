# Story 3.1: 對話介面 UI 實作

## Status
Approved

---

## Story

**As a** 使用者,
**I want** 一個簡潔的對話介面（輸入框、歷史記錄、送出按鈕），
**so that** 我可以透過文字與 Avatar 對話。

---

## Acceptance Criteria

1. 建立 `components/chat/ChatInterface.tsx` 對話介面組件
2. 介面包含：對話歷史區域（顯示最近 5 則訊息，使用者/Avatar 分別顯示）、文字輸入框（Textarea，支援 Enter 送出）、送出按鈕（含 Loading 狀態）、清除對話按鈕
3. 使用 Tailwind CSS 設計，符合品牌風格（深藍、白色）
4. 輸入框 placeholder: 「輸入訊息與 Avatar 對話...」
5. 訊息區域可滾動，新訊息自動滾動到底部
6. 使用者訊息顯示在右側（藍色氣泡），Avatar 訊息顯示在左側（灰色氣泡）
7. Loading 狀態時，送出按鈕顯示 Spinner 且禁用輸入

---

## Tasks / Subtasks

- [ ] **Task 1: 建立 ChatInterface 組件基本結構** (AC: 1, 2)
  - [ ] 建立目錄 `components/chat/`（如尚未存在）
  - [ ] 建立 `components/chat/ChatInterface.tsx` 檔案
  - [ ] 實作基本組件架構：
    ```typescript
    'use client';

    import { useState, useRef, useEffect } from 'react';

    interface Message {
      id: string;
      role: 'user' | 'avatar';
      content: string;
      timestamp: Date;
    }

    export default function ChatInterface() {
      const [messages, setMessages] = useState<Message[]>([]);
      const [input, setInput] = useState('');
      const [isLoading, setIsLoading] = useState(false);
      const messagesEndRef = useRef<HTMLDivElement>(null);

      return (
        <div className="flex flex-col h-full bg-white rounded-lg shadow-lg">
          {/* 對話歷史區域 */}
          <div className="flex-1 overflow-y-auto p-4 space-y-4">
            {/* 訊息將在 Task 2 實作 */}
          </div>

          {/* 輸入區域 */}
          <div className="border-t border-gray-200 p-4">
            {/* 輸入框與按鈕將在 Task 3 實作 */}
          </div>
        </div>
      );
    }
    ```
  - [ ] 加入 TypeScript 型別定義（Message interface）
  - [ ] 加入 JSDoc 註解說明用途
  - [ ] 驗證組件基本結構正確渲染

- [ ] **Task 2: 實作對話歷史顯示區域** (AC: 2, 5, 6)
  - [ ] 實作訊息列表渲染邏輯：
    ```typescript
    <div className="flex-1 overflow-y-auto p-4 space-y-4" ref={messagesContainerRef}>
      {messages.length === 0 ? (
        <div className="flex items-center justify-center h-full text-gray-400">
          <p>開始與 Avatar 對話...</p>
        </div>
      ) : (
        messages.slice(-5).map((message) => (
          <div
            key={message.id}
            className={`flex ${message.role === 'user' ? 'justify-end' : 'justify-start'}`}
          >
            <div
              className={`max-w-[70%] rounded-lg px-4 py-2 ${
                message.role === 'user'
                  ? 'bg-blue-600 text-white'
                  : 'bg-gray-200 text-gray-900'
              }`}
            >
              <p className="text-sm whitespace-pre-wrap break-words">
                {message.content}
              </p>
              <p className="text-xs mt-1 opacity-70">
                {message.timestamp.toLocaleTimeString('zh-TW', {
                  hour: '2-digit',
                  minute: '2-digit'
                })}
              </p>
            </div>
          </div>
        ))
      )}
      <div ref={messagesEndRef} />
    </div>
    ```
  - [ ] 實作訊息限制邏輯（只顯示最近 5 則訊息）
  - [ ] 加入訊息氣泡樣式（使用者：藍色右側，Avatar：灰色左側）
  - [ ] 加入時間戳記顯示（格式：HH:mm）
  - [ ] 實作空狀態顯示（無訊息時的提示）
  - [ ] 測試訊息區域可正常滾動
  - [ ] 驗證訊息樣式符合設計規範

- [ ] **Task 3: 實作自動滾動到底部功能** (AC: 5)
  - [ ] 建立 messagesEndRef 用於滾動定位
  - [ ] 實作 scrollToBottom 函式：
    ```typescript
    const scrollToBottom = () => {
      messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    };

    useEffect(() => {
      scrollToBottom();
    }, [messages]);
    ```
  - [ ] 在 messages 變更時觸發自動滾動
  - [ ] 測試新訊息加入時自動滾動行為
  - [ ] 驗證滾動動畫流暢（smooth behavior）
  - [ ] 測試快速連續訊息時滾動正確性

- [ ] **Task 4: 實作文字輸入框與基本互動** (AC: 2, 4, 7)
  - [ ] 實作 Textarea 輸入框：
    ```typescript
    <div className="border-t border-gray-200 p-4 bg-gray-50">
      <div className="flex items-end space-x-2">
        <textarea
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder="輸入訊息與 Avatar 對話..."
          disabled={isLoading}
          rows={1}
          className="flex-1 resize-none rounded-lg border border-gray-300 px-4 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:bg-gray-100 disabled:cursor-not-allowed"
        />
        <button
          onClick={handleSend}
          disabled={isLoading || input.trim() === ''}
          className="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 disabled:bg-gray-300 disabled:cursor-not-allowed transition-colors flex items-center space-x-2"
        >
          {isLoading ? (
            <>
              <Spinner />
              <span>傳送中...</span>
            </>
          ) : (
            <span>送出</span>
          )}
        </button>
        <button
          onClick={handleClear}
          disabled={isLoading || messages.length === 0}
          className="bg-gray-200 text-gray-700 px-4 py-2 rounded-lg hover:bg-gray-300 disabled:bg-gray-100 disabled:cursor-not-allowed transition-colors"
        >
          清除
        </button>
      </div>
    </div>
    ```
  - [ ] 加入 placeholder 文字：「輸入訊息與 Avatar 對話...」
  - [ ] 實作 input state 雙向綁定
  - [ ] 實作 disabled 狀態（Loading 時禁用）
  - [ ] 加入 focus 樣式（藍色 ring）
  - [ ] 測試輸入框基本互動功能
  - [ ] 驗證 disabled 狀態樣式正確

- [ ] **Task 5: 實作 Enter 鍵送出與按鈕互動** (AC: 2, 7)
  - [ ] 實作 handleKeyDown 函式（支援 Enter 送出）：
    ```typescript
    const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        if (!isLoading && input.trim() !== '') {
          handleSend();
        }
      }
    };
    ```
  - [ ] 實作 handleSend 函式（送出訊息）：
    ```typescript
    const handleSend = () => {
      if (input.trim() === '' || isLoading) return;

      const userMessage: Message = {
        id: `user-${Date.now()}`,
        role: 'user',
        content: input.trim(),
        timestamp: new Date()
      };

      setMessages((prev) => [...prev, userMessage]);
      setInput('');
      setIsLoading(true);

      // 模擬 Avatar 回應（後續 Story 3.3 將整合真實 API）
      setTimeout(() => {
        const avatarMessage: Message = {
          id: `avatar-${Date.now()}`,
          role: 'avatar',
          content: '這是 Avatar 的測試回應。',
          timestamp: new Date()
        };
        setMessages((prev) => [...prev, avatarMessage]);
        setIsLoading(false);
      }, 1500);
    };
    ```
  - [ ] 實作 handleClear 函式（清除對話）：
    ```typescript
    const handleClear = () => {
      if (window.confirm('確定要清除所有對話紀錄嗎？')) {
        setMessages([]);
      }
    };
    ```
  - [ ] 支援 Enter 送出、Shift+Enter 換行
  - [ ] 送出後清空輸入框
  - [ ] 測試送出按鈕點擊功能
  - [ ] 測試清除按鈕確認對話框
  - [ ] 驗證按鈕 disabled 邏輯正確

- [ ] **Task 6: 實作 Loading Spinner 組件** (AC: 7)
  - [ ] 建立 `components/chat/Spinner.tsx` Loading 組件：
    ```typescript
    export default function Spinner() {
      return (
        <svg
          className="animate-spin h-5 w-5"
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
        >
          <circle
            className="opacity-25"
            cx="12"
            cy="12"
            r="10"
            stroke="currentColor"
            strokeWidth="4"
          />
          <path
            className="opacity-75"
            fill="currentColor"
            d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
          />
        </svg>
      );
    }
    ```
  - [ ] 在 ChatInterface 中引入 Spinner
  - [ ] 實作 Loading 狀態顯示（送出按鈕顯示 Spinner + 「傳送中...」）
  - [ ] 測試 Spinner 動畫流暢度
  - [ ] 驗證 Loading 狀態時所有互動正確禁用

- [ ] **Task 7: Tailwind CSS 樣式優化與品牌風格** (AC: 3)
  - [ ] 配置品牌色彩（深藍：`blue-600`、白色：`white`、灰色：`gray-200`）
  - [ ] 優化對話介面整體佈局（確保高度自適應）
  - [ ] 加入 hover 狀態樣式（按鈕 hover 效果）
  - [ ] 加入 transition 動畫（顏色過渡、opacity 變化）
  - [ ] 實作 responsive 設計（手機、平板、桌面）：
    ```typescript
    <div className="flex flex-col h-full bg-white rounded-lg shadow-lg max-w-2xl mx-auto">
      {/* 手機版調整 */}
      <div className="flex-1 overflow-y-auto p-2 sm:p-4 space-y-2 sm:space-y-4">
        {/* ... */}
      </div>
      <div className="border-t border-gray-200 p-2 sm:p-4 bg-gray-50">
        <div className="flex flex-col sm:flex-row items-stretch sm:items-end space-y-2 sm:space-y-0 sm:space-x-2">
          {/* ... */}
        </div>
      </div>
    </div>
    ```
  - [ ] 測試不同螢幕尺寸下的樣式表現
  - [ ] 驗證品牌風格一致性（顏色、間距、圓角）
  - [ ] 使用 Chrome DevTools 檢查 CSS 樣式正確套用

- [ ] **Task 8: 整合 ChatInterface 至主頁面與測試** (AC: 1-7)
  - [ ] 開啟 `app/page.tsx`
  - [ ] 引入 ChatInterface 組件：
    ```typescript
    import ChatInterface from '@/components/chat/ChatInterface';
    import AvatarCanvas from '@/components/avatar/AvatarCanvas';

    export default function Home() {
      return (
        <main className="flex h-screen bg-gradient-to-b from-slate-900 to-slate-800">
          {/* 左側：Avatar 顯示區 */}
          <div className="flex-1">
            <AvatarCanvas />
          </div>

          {/* 右側：對話介面 */}
          <div className="w-96 p-4">
            <ChatInterface />
          </div>
        </main>
      );
    }
    ```
  - [ ] 執行 `pnpm dev` 啟動開發伺服器
  - [ ] 開啟 `http://localhost:3000` 驗證介面正常顯示
  - [ ] 測試所有互動功能：
    - [ ] 輸入文字並送出（Enter 或按鈕）
    - [ ] 訊息正確顯示（使用者右側藍色、Avatar 左側灰色）
    - [ ] 自動滾動到最新訊息
    - [ ] Loading 狀態顯示 Spinner 且禁用輸入
    - [ ] 清除按鈕清空所有訊息
    - [ ] 顯示最近 5 則訊息限制
  - [ ] 驗證 responsive 設計在不同裝置上的表現
  - [ ] 確認 Console 無錯誤或警告訊息

---

## Dev Notes

### 相關來源樹（Source Tree）

根據架構文件，Epic 3 的檔案結構應如下：

```
avatar-chat-poc/
├── components/
│   ├── avatar/
│   │   ├── AvatarCanvas.tsx        # Three.js 場景容器 (Epic 2)
│   │   ├── AvatarModel.tsx         # Avatar 模型組件 (Epic 2)
│   │   └── AvatarSelector.tsx      # Avatar 選擇器 (Epic 2)
│   └── chat/
│       ├── ChatInterface.tsx       # 對話介面組件 (本 Story)
│       ├── Spinner.tsx             # Loading Spinner 組件 (本 Story)
│       └── MessageBubble.tsx       # 訊息氣泡組件 (選用，可重構)
├── stores/
│   ├── avatarStore.ts              # Zustand Avatar 狀態管理 (Epic 2)
│   ├── chatStore.ts                # Zustand Chat 狀態管理 (Story 3.2)
│   └── audioStore.ts               # Zustand Audio 狀態管理 (Story 3.6)
├── app/
│   ├── api/
│   │   ├── chat/
│   │   │   └── route.ts            # Chat API 路由 (Story 3.3)
│   │   └── tts/
│   │       └── route.ts            # TTS API 路由 (Story 3.5)
│   └── page.tsx                    # 主頁面整合
└── types/
    ├── avatar.ts                   # Avatar 相關型別定義
    └── chat.ts                     # Chat 相關型別定義 (本 Story)
```

### 技術實作細節

**React Hooks 使用**：
- `useState`: 管理訊息陣列、輸入文字、Loading 狀態
- `useRef`: 用於自動滾動定位（messagesEndRef）
- `useEffect`: 監聽 messages 變更並觸發自動滾動

**Message Interface 設計**：
```typescript
interface Message {
  id: string;            // 唯一識別碼（格式：`user-${timestamp}` 或 `avatar-${timestamp}`）
  role: 'user' | 'avatar'; // 訊息來源：使用者或 Avatar
  content: string;       // 訊息內容（支援多行文字）
  timestamp: Date;       // 訊息時間戳記（用於顯示時間與排序）
}
```

**自動滾動實作原理**：
1. **Ref 定位**: 在訊息列表最後放置一個空 `<div ref={messagesEndRef} />`
2. **滾動觸發**: 使用 `useEffect` 監聽 `messages` 變更
3. **平滑滾動**: 使用 `scrollIntoView({ behavior: 'smooth' })` 實現動畫效果
4. **效能考量**: 只在 messages 變更時觸發，避免不必要的重渲染

**Enter 鍵送出邏輯**：
```typescript
const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();  // 防止換行
    if (!isLoading && input.trim() !== '') {
      handleSend();
    }
  }
  // Shift + Enter 允許換行（預設行為）
};
```

**訊息限制實作**：
- 使用 `messages.slice(-5)` 取最近 5 則訊息
- 完整訊息陣列保留在 state 中（後續可用於歷史查詢）
- 渲染時僅顯示最近 5 則（避免 DOM 過度膨脹）

**Tailwind CSS 響應式設計**：
```typescript
// 手機優先策略（Mobile First）
className="p-2 sm:p-4"           // 手機 8px，桌面 16px
className="flex-col sm:flex-row" // 手機垂直排列，桌面水平排列
className="space-y-2 sm:space-y-4" // 手機 8px 間距，桌面 16px 間距
className="max-w-[70%]"          // 訊息氣泡最大寬度 70%（避免過寬）
```

### 重要架構決策

1. **為何使用本地 State 而非 Zustand？**
   - ✅ 本 Story 專注於 UI 實作，使用 `useState` 簡化開發
   - ✅ Story 3.2 將建立 Zustand `chatStore`，屆時重構為全域狀態
   - ✅ 循序漸進，先驗證 UI 邏輯再整合狀態管理
   - ⚠️ 注意：Story 3.2 整合時需重構 `messages`, `input`, `isLoading` 為 Zustand state

2. **為何模擬 Avatar 回應？**
   - ✅ 本 Story 只負責 UI，無需真實 API
   - ✅ 使用 `setTimeout` 模擬 1.5 秒延遲，驗證 Loading 狀態
   - ✅ Story 3.3 將實作真實 Chat API（Azure OpenAI + SSE）
   - ✅ Story 3.4 將實作 SSE 串流接收，替換模擬邏輯

3. **為何限制最近 5 則訊息？**
   - ✅ 符合 AC 要求（顯示最近 5 則訊息）
   - ✅ 減少 DOM 節點數量，提升渲染效能
   - ✅ 簡化 UI 設計，避免訊息區域過度擁擠
   - ✅ 完整訊息陣列保留在 state，後續可實作「查看更多」功能

4. **為何使用 Textarea 而非 Input？**
   - ✅ 支援多行文字輸入（Shift + Enter 換行）
   - ✅ 更符合對話介面使用情境（長訊息輸入）
   - ✅ 可透過 `rows={1}` + `resize-none` 控制初始高度
   - ⚠️ 注意：未來可實作自動高度調整（根據內容動態增長）

5. **為何獨立 Spinner 組件？**
   - ✅ 可重複使用（其他組件也可能需要 Loading 指示器）
   - ✅ 符合 Single Responsibility Principle（單一職責）
   - ✅ 便於後續替換為第三方 UI 函式庫（如 Radix UI、shadcn/ui）

### Testing

**測試框架**: 手動測試 + Chrome DevTools（POC 階段）

**測試範圍**:
1. ✅ ChatInterface 組件正常渲染
2. ✅ 訊息輸入與送出功能正常
3. ✅ Enter 鍵送出、Shift+Enter 換行行為正確
4. ✅ 訊息顯示樣式正確（使用者藍色右側、Avatar 灰色左側）
5. ✅ 自動滾動到最新訊息功能正常
6. ✅ Loading 狀態顯示 Spinner 且禁用輸入
7. ✅ 清除按鈕清空所有訊息
8. ✅ 顯示最近 5 則訊息限制正確
9. ✅ Responsive 設計在不同裝置正常運作

**測試執行方式**:
```bash
# 啟動開發伺服器
pnpm dev

# 瀏覽器開啟
http://localhost:3000

# 測試項目
1. 視覺檢查：對話介面顯示在右側，樣式符合品牌風格
2. 輸入測試：輸入文字 → 按 Enter → 訊息顯示在右側藍色氣泡
3. 模擬回應測試：1.5 秒後 Avatar 回應顯示在左側灰色氣泡
4. 滾動測試：連續送出 6 則訊息 → 自動滾動到最新訊息
5. Loading 測試：送出訊息時 → 按鈕顯示 Spinner + 「傳送中...」
6. 清除測試：點擊清除按鈕 → 確認對話框 → 所有訊息清空
7. Enter 鍵測試：Enter 送出、Shift+Enter 換行
8. Responsive 測試：調整瀏覽器寬度 → 檢查手機/平板/桌面樣式
```

**驗證清單**:
- [ ] `pnpm dev` 啟動無錯誤
- [ ] 對話介面正確顯示在右側
- [ ] 輸入文字並送出，訊息顯示正確
- [ ] Enter 鍵送出、Shift+Enter 換行行為正確
- [ ] 使用者訊息藍色右側、Avatar 訊息灰色左側
- [ ] 新訊息自動滾動到底部
- [ ] Loading 狀態顯示 Spinner 且禁用輸入
- [ ] 清除按鈕清空所有訊息並有確認對話框
- [ ] 顯示最近 5 則訊息（第 6 則訊息送出後，第 1 則消失）
- [ ] Responsive 設計在手機/平板/桌面正常運作
- [ ] Console 無錯誤或警告訊息

### 效能考量

**渲染效能**:
- **訊息限制**: 使用 `slice(-5)` 限制 DOM 節點數量（≤ 5 個訊息氣泡）
- **避免不必要重渲染**: 使用 `useEffect` 依賴陣列精確控制副作用
- **平滑滾動**: `scrollIntoView({ behavior: 'smooth' })` 提供良好視覺體驗

**記憶體管理**:
- **訊息陣列**: POC 階段無限制，正式版可實作訊息上限（如 100 則）
- **清除功能**: 提供使用者手動清除訊息，避免長時間使用記憶體膨脹

**未來優化方向**（MVP 階段）:
1. **虛擬滾動**: 若訊息數量 > 100，考慮使用 `react-virtual` 優化渲染
2. **訊息分頁**: 實作「載入更多」功能，按需載入歷史訊息
3. **Textarea 自動高度**: 根據內容動態調整輸入框高度（使用 `auto-resize` 套件）
4. **Debounce 輸入**: 若整合即時輸入提示，需加入 debounce 避免過度請求

### 安全性考量

**XSS 防護**:
- ✅ React 預設轉義所有文字內容，避免 XSS 攻擊
- ✅ 使用 `whitespace-pre-wrap` 保留換行，但不渲染 HTML
- ⚠️ 未來若需支援 Markdown 或 HTML，必須使用 `DOMPurify` 過濾

**輸入驗證**:
- ✅ 送出前檢查 `input.trim() !== ''`，避免空訊息
- ✅ 使用 `maxLength` 限制輸入長度（未來可加入，如 1000 字元）

**使用者體驗安全**:
- ✅ 清除對話時有確認對話框，避免誤操作
- ✅ Loading 狀態禁用輸入，避免重複送出

### 依賴關係

**前置條件**:
- ✅ Story 1.1 已完成（Next.js 專案已建立）
- ✅ Story 1.3 已完成（Tailwind CSS 已配置）
- ✅ Story 2.1 已完成（AvatarCanvas 已建立，可整合至主頁面）
- ✅ Node.js 18+ 與 pnpm 已安裝

**後續 Story 依賴**:
- **Story 3.2**: 會建立 Zustand `chatStore`，需重構本 Story 的本地 state
- **Story 3.3**: 會實作真實 Chat API（Azure OpenAI + SSE），替換模擬回應邏輯
- **Story 3.4**: 會實作 SSE 串流接收，整合至 ChatInterface 顯示即時回應
- **Story 3.7**: 會整合完整對話流程（Chat → TTS → Avatar 動作），驗證端到端體驗

**關鍵路徑**:
- 本 Story 是 Epic 3 的 UI 基礎，必須優先完成
- Story 3.2（Zustand 狀態管理）依賴本 Story 的 UI 結構
- Story 3.3/3.4（Chat API + SSE）依賴本 Story 的訊息顯示邏輯

**與 Epic 2 整合**:
- 本 Story 的 ChatInterface 會與 Epic 2 的 AvatarCanvas 並排顯示
- 主頁面佈局：左側 Avatar 3D 場景（Epic 2）、右側對話介面（Epic 3）
- 後續 Story 3.4/3.7 會透過狀態管理連接對話與 Avatar 動作

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-14 | 1.0 | 建立 Story 3.1 草稿 | SM Agent |

---

## Dev Agent Record

*(此部分由 Dev Agent 在實作時填寫)*

### Agent Model Used
_待填寫_

### Debug Log References
_待填寫_

### Completion Notes List
_待填寫_

### File List
_待填寫_

---

## QA Results

*(此部分由 QA Agent 在審核時填寫)*

_待填寫_

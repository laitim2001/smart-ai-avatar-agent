# Story 3.4: 前端 SSE 串流接收與顯示

## Status
Approved

---

## Story

**As a** 使用者,
**I want** 看到 Avatar 的回應即時逐字顯示（打字機效果），
**so that** 對話感覺更自然且即時。

---

## Acceptance Criteria

1. 建立 `lib/api/chat.ts`，實作 `sendMessage()` 函式
2. 使用 `fetch` 呼叫 `/api/chat`，讀取 SSE 串流
3. 每收到一個 chunk，將文字附加到當前訊息
4. 在 UI 中即時顯示逐字出現的效果
5. 串流結束後，將完整訊息加入 `chatStore`
6. 處理連線中斷或錯誤情況，顯示錯誤訊息
7. Loading 狀態正確更新（開始/結束）
8. 測試：輸入「你好」，Avatar 回應即時顯示

---

## Tasks / Subtasks

- [ ] **Task 1: 建立 SSE 串流接收函式** (AC: 1, 2)
  - [ ] 建立目錄 `lib/api/`（如尚未存在）
  - [ ] 建立 `lib/api/chat.ts` 檔案
  - [ ] 實作 SSE 串流接收邏輯：
    ```typescript
    import { ChatMessage } from '@/types/chat';

    /**
     * 發送訊息至 Chat API 並接收 SSE 串流回應
     * @param messages 對話歷史
     * @param onChunk 每個 chunk 的回調函式
     * @param onComplete 完整回應的回調函式
     * @param onError 錯誤處理回調
     */
    export async function sendMessage(
      messages: ChatMessage[],
      onChunk: (content: string) => void,
      onComplete: (fullContent: string) => void,
      onError: (error: Error) => void
    ): Promise<void> {
      try {
        const response = await fetch('/api/chat', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ messages }),
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error || 'Chat API request failed');
        }

        // 檢查是否為 SSE 串流
        const contentType = response.headers.get('content-type');
        if (!contentType?.includes('text/event-stream')) {
          throw new Error('Expected SSE stream but got: ' + contentType);
        }

        // 讀取 SSE 串流
        const reader = response.body?.getReader();
        if (!reader) {
          throw new Error('No response body reader available');
        }

        const decoder = new TextDecoder();
        let fullContent = '';

        while (true) {
          const { done, value } = await reader.read();

          if (done) {
            onComplete(fullContent);
            break;
          }

          // 解碼 chunk
          const chunk = decoder.decode(value, { stream: true });

          // 處理 SSE 格式（可能包含多個 data: 行）
          const lines = chunk.split('\n');
          for (const line of lines) {
            if (line.startsWith('data: ')) {
              const jsonStr = line.slice(6); // 移除 "data: " 前綴
              try {
                const data = JSON.parse(jsonStr);

                if (data.error) {
                  throw new Error(data.error);
                }

                if (data.done) {
                  // 串流結束
                  onComplete(fullContent);
                  return;
                }

                if (data.content) {
                  fullContent += data.content;
                  onChunk(data.content);
                }
              } catch (parseError) {
                console.warn('[SSE Parse Warning]', parseError, jsonStr);
              }
            }
          }
        }

      } catch (error) {
        onError(error instanceof Error ? error : new Error('Unknown error'));
      }
    }
    ```
  - [ ] 加入 JSDoc 註解說明函式參數與用途
  - [ ] 加入錯誤處理（網路錯誤、解析錯誤、API 錯誤）
  - [ ] 驗證函式可正確接收 SSE 串流

- [ ] **Task 2: 整合 SSE 接收至 chatStore** (AC: 3, 5, 7)
  - [ ] 開啟 `stores/chatStore.ts`
  - [ ] 重構 `sendMessage` action 整合 SSE：
    ```typescript
    import { sendMessage as sendMessageAPI } from '@/lib/api/chat';

    export const useChatStore = create<ChatStore>((set, get) => ({
      // ... 現有 state

      sendMessage: async () => {
        const { input, isLoading, messages } = get();

        // 驗證輸入與狀態
        if (input.trim() === '' || isLoading) return;

        // 建立使用者訊息
        const userMessage: Message = {
          id: `user-${Date.now()}`,
          role: 'user',
          content: input.trim(),
          timestamp: new Date()
        };

        // 更新狀態
        set((state) => ({
          messages: [...state.messages, userMessage],
          input: '',
          isLoading: true
        }));

        // 準備 Avatar 訊息（即時更新）
        const avatarMessageId = `avatar-${Date.now()}`;
        let avatarContent = '';

        // 建立臨時 Avatar 訊息
        const avatarMessage: Message = {
          id: avatarMessageId,
          role: 'avatar',
          content: '',
          timestamp: new Date()
        };

        set((state) => ({
          messages: [...state.messages, avatarMessage]
        }));

        // 呼叫 SSE API
        const chatMessages = [...messages, userMessage].map(m => ({
          role: m.role === 'avatar' ? 'assistant' : m.role,
          content: m.content
        }));

        await sendMessageAPI(
          chatMessages,
          // onChunk: 即時更新 Avatar 訊息內容
          (chunk) => {
            avatarContent += chunk;
            set((state) => ({
              messages: state.messages.map(m =>
                m.id === avatarMessageId
                  ? { ...m, content: avatarContent }
                  : m
              )
            }));
          },
          // onComplete: 完成後更新狀態
          (fullContent) => {
            set((state) => ({
              messages: state.messages.map(m =>
                m.id === avatarMessageId
                  ? { ...m, content: fullContent, timestamp: new Date() }
                  : m
              ),
              isLoading: false
            }));
          },
          // onError: 錯誤處理
          (error) => {
            console.error('[Chat Error]', error);

            // 移除臨時 Avatar 訊息，加入錯誤訊息
            set((state) => ({
              messages: [
                ...state.messages.filter(m => m.id !== avatarMessageId),
                {
                  id: `error-${Date.now()}`,
                  role: 'avatar',
                  content: `抱歉，我遇到了一些問題：${error.message}`,
                  timestamp: new Date()
                }
              ],
              isLoading: false
            }));
          }
        );
      },

      // ... 其他 actions
    }));
    ```
  - [ ] 實作即時更新邏輯（每個 chunk 更新 Avatar 訊息內容）
  - [ ] 實作完成後狀態更新（`isLoading: false`）
  - [ ] 實作錯誤處理（顯示錯誤訊息給使用者）
  - [ ] 驗證 chatStore 整合正確

- [ ] **Task 3: 實作打字機效果動畫** (AC: 4)
  - [ ] 開啟 `components/chat/ChatInterface.tsx`
  - [ ] 加入打字機效果樣式：
    ```typescript
    // 為串流中的訊息加入閃爍游標
    <div
      className={`max-w-[70%] rounded-lg px-4 py-2 ${
        message.role === 'user'
          ? 'bg-blue-600 text-white'
          : 'bg-gray-200 text-gray-900'
      }`}
    >
      <p className="text-sm whitespace-pre-wrap break-words">
        {message.content}
        {isLoading && message.id === messages[messages.length - 1]?.id && (
          <span className="inline-block w-1 h-4 ml-1 bg-gray-900 animate-pulse">|</span>
        )}
      </p>
      <p className="text-xs mt-1 opacity-70">
        {message.timestamp.toLocaleTimeString('zh-TW', {
          hour: '2-digit',
          minute: '2-digit'
        })}
      </p>
    </div>
    ```
  - [ ] 加入 CSS 動畫（閃爍游標）：
    ```css
    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }
    ```
  - [ ] 僅在最後一則訊息且 `isLoading` 時顯示游標
  - [ ] 測試打字機效果流暢度
  - [ ] 驗證動畫符合設計預期

- [ ] **Task 4: 實作連線錯誤處理與重試** (AC: 6)
  - [ ] 在 `lib/api/chat.ts` 加入重試邏輯：
    ```typescript
    /**
     * 帶重試機制的 sendMessage
     * @param maxRetries 最大重試次數（預設 1）
     */
    export async function sendMessageWithRetry(
      messages: ChatMessage[],
      onChunk: (content: string) => void,
      onComplete: (fullContent: string) => void,
      onError: (error: Error) => void,
      maxRetries: number = 1
    ): Promise<void> {
      let attempt = 0;

      while (attempt <= maxRetries) {
        try {
          await sendMessage(messages, onChunk, onComplete, onError);
          return; // 成功，退出
        } catch (error) {
          attempt++;

          if (attempt > maxRetries) {
            onError(error instanceof Error ? error : new Error('Unknown error'));
            return;
          }

          console.warn(`[Chat Retry] Attempt ${attempt}/${maxRetries}`);

          // 等待 1 秒後重試
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }
    }
    ```
  - [ ] 在 chatStore 中使用 `sendMessageWithRetry`
  - [ ] 加入網路連線檢查：
    ```typescript
    if (!navigator.onLine) {
      throw new Error('網路連線中斷，請檢查網路設定');
    }
    ```
  - [ ] 測試網路中斷情境（離線模式）
  - [ ] 驗證重試邏輯正確運作

- [ ] **Task 5: 實作 Loading 狀態 UI 優化** (AC: 7)
  - [ ] 在 ChatInterface 加入「正在思考」提示：
    ```typescript
    {isLoading && messages.length > 0 && (
      <div className="flex justify-start">
        <div className="bg-gray-200 text-gray-900 rounded-lg px-4 py-2">
          <div className="flex items-center space-x-2">
            <div className="flex space-x-1">
              <div className="w-2 h-2 bg-gray-500 rounded-full animate-bounce" style={{ animationDelay: '0ms' }}></div>
              <div className="w-2 h-2 bg-gray-500 rounded-full animate-bounce" style={{ animationDelay: '150ms' }}></div>
              <div className="w-2 h-2 bg-gray-500 rounded-full animate-bounce" style={{ animationDelay: '300ms' }}></div>
            </div>
            <span className="text-sm text-gray-600">Avatar 正在思考...</span>
          </div>
        </div>
      </div>
    )}
    ```
  - [ ] 在送出按鈕加入 Loading 狀態（Spinner，已在 Story 3.1 實作）
  - [ ] 在輸入框加入 disabled 狀態（Loading 時禁用）
  - [ ] 測試 Loading 狀態顯示時機正確
  - [ ] 驗證 UI 符合設計規範

- [ ] **Task 6: 實作對話上下文管理** (AC: 5)
  - [ ] 確保 chatStore 正確傳遞對話歷史：
    ```typescript
    // 將前端訊息格式轉換為 API 格式
    const chatMessages = messages.map(m => ({
      role: m.role === 'avatar' ? 'assistant' : 'user',
      content: m.content
    }));
    ```
  - [ ] 限制對話歷史長度（避免 API 超過 token 限制）：
    ```typescript
    // 保留最近 10 輪對話（20 則訊息）
    const recentMessages = messages.slice(-20);
    const chatMessages = recentMessages.map(m => ({
      role: m.role === 'avatar' ? 'assistant' : 'user',
      content: m.content
    }));
    ```
  - [ ] 加入對話上下文說明註解
  - [ ] 測試多輪對話上下文正確保留
  - [ ] 驗證 LLM 回應考慮歷史對話內容

- [ ] **Task 7: 整合測試與驗證** (AC: 1-8)
  - [ ] 執行 `pnpm dev` 啟動開發伺服器
  - [ ] 開啟 `http://localhost:3000` 進入應用
  - [ ] 測試完整對話流程：
    - [ ] 輸入「你好」並送出
    - [ ] 驗證 Loading 狀態顯示（「正在思考...」動畫）
    - [ ] 驗證 SSE 串流接收（Avatar 回應逐字顯示）
    - [ ] 驗證打字機效果（閃爍游標）
    - [ ] 驗證完成後狀態更新（游標消失、isLoading = false）
    - [ ] 驗證訊息加入 chatStore
  - [ ] 測試多輪對話：
    - [ ] 輸入「我叫小明」
    - [ ] 輸入「你還記得我的名字嗎？」
    - [ ] 驗證 LLM 回應包含「小明」
  - [ ] 測試錯誤處理：
    - [ ] 停止 API 伺服器，測試網路錯誤
    - [ ] 驗證錯誤訊息顯示
    - [ ] 驗證重試邏輯（如有）
  - [ ] 使用 React DevTools 檢查 chatStore 狀態正確更新
  - [ ] 驗證 Console 無錯誤或警告訊息
  - [ ] 執行 TypeScript 型別檢查（`pnpm run type-check`）

---

## Dev Notes

### 相關來源樹（Source Tree）

根據架構文件，本 Story 涉及的檔案結構：

```
avatar-chat-poc/
├── lib/
│   └── api/
│       └── chat.ts                # SSE 串流接收函式 (本 Story)
├── stores/
│   └── chatStore.ts               # 整合 SSE 接收邏輯 (重構)
├── components/
│   └── chat/
│       └── ChatInterface.tsx      # 打字機效果與 UI 優化 (重構)
└── types/
    └── chat.ts                    # Chat 相關型別定義
```

### 技術實作細節

**SSE 串流接收原理**：
```typescript
// 1. 發送 POST 請求
const response = await fetch('/api/chat', { method: 'POST', body: ... });

// 2. 取得 ReadableStream reader
const reader = response.body?.getReader();

// 3. 迭代讀取 chunks
while (true) {
  const { done, value } = await reader.read();
  if (done) break;

  // 4. 解碼 Uint8Array → String
  const chunk = decoder.decode(value, { stream: true });

  // 5. 解析 SSE 格式（data: {...}\n\n）
  const lines = chunk.split('\n');
  for (const line of lines) {
    if (line.startsWith('data: ')) {
      const data = JSON.parse(line.slice(6));
      // 處理 data.content
    }
  }
}
```

**為何使用 `fetch` 而非 `EventSource`？**
- ✅ **POST 支援**: EventSource 只支援 GET，無法發送 body
- ✅ **自訂 Headers**: fetch 可自訂 Content-Type、Authorization
- ✅ **錯誤處理**: fetch 提供更細緻的錯誤控制
- ❌ **自動重連**: EventSource 有自動重連，fetch 需手動實作（已在 Task 4 實作）

**即時更新策略**：
```typescript
// 方案 1: 每個 chunk 更新整個訊息（選用）
set((state) => ({
  messages: state.messages.map(m =>
    m.id === avatarMessageId
      ? { ...m, content: avatarContent }
      : m
  )
}));

// 方案 2: 使用 immer（未來優化）
// produce(state, draft => {
//   const message = draft.messages.find(m => m.id === avatarMessageId);
//   if (message) message.content = avatarContent;
// });
```

**打字機效果實作**：
```typescript
// CSS 閃爍動畫
@keyframes blink {
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0; }
}

// 游標元素（只在串流中顯示）
{isLoading && message.id === lastMessageId && (
  <span className="inline-block w-1 h-4 ml-1 bg-gray-900 animate-pulse">|</span>
)}
```

**對話歷史管理**：
```typescript
// 限制歷史長度（避免超過 token 限制）
const MAX_HISTORY = 20; // 10 輪對話

const recentMessages = messages.slice(-MAX_HISTORY);

// 轉換為 API 格式
const chatMessages = recentMessages.map(m => ({
  role: m.role === 'avatar' ? 'assistant' : 'user',
  content: m.content
}));
```

**錯誤分類與處理**：
```typescript
// 1. 網路錯誤
if (!navigator.onLine) {
  throw new Error('網路連線中斷，請檢查網路設定');
}

// 2. API 錯誤（4xx, 5xx）
if (!response.ok) {
  const errorData = await response.json();
  throw new Error(errorData.error || 'Chat API request failed');
}

// 3. SSE 格式錯誤
if (!contentType?.includes('text/event-stream')) {
  throw new Error('Expected SSE stream');
}

// 4. 解析錯誤
try {
  const data = JSON.parse(jsonStr);
} catch (parseError) {
  console.warn('[SSE Parse Warning]', parseError);
}
```

### 重要架構決策

1. **為何使用回調函式而非 Promise？**
   - ✅ **即時更新**: 回調函式可在每個 chunk 到達時立即執行
   - ✅ **彈性**: 可分別處理 chunk、complete、error 三種情境
   - ✅ **狀態管理**: 直接整合到 Zustand store actions
   - ❌ **複雜度**: 回調函式比 async/await 略複雜（可接受）

2. **為何在 chatStore 而非組件中處理 SSE？**
   - ✅ **關注點分離**: 組件專注 UI，Store 處理業務邏輯
   - ✅ **可重複使用**: 其他組件也可呼叫相同邏輯
   - ✅ **狀態一致性**: 直接更新 Zustand state，無需額外同步
   - ✅ **測試性**: Store 邏輯可獨立測試

3. **為何限制對話歷史為 20 則訊息？**
   - ✅ **Token 限制**: GPT-4 Turbo 有 token 限制（128K，但成本考量）
   - ✅ **成本控制**: 減少輸入 tokens，降低 API 成本
   - ✅ **效能優化**: 減少請求大小與處理時間
   - ✅ **使用者體驗**: 20 則訊息（10 輪）足夠大多數對話情境

4. **為何實作重試機制？**
   - ✅ **網路不穩**: POC 環境可能有網路波動
   - ✅ **Azure 限流**: 偶發性 429 錯誤（超過頻率限制）
   - ✅ **使用者體驗**: 自動重試比顯示錯誤更友善
   - ⚠️ **成本**: 重試會增加 API 成本（限制為 1 次）

5. **為何加入「正在思考」動畫？**
   - ✅ **視覺反饋**: 讓使用者知道系統正在處理
   - ✅ **減少焦慮**: 明確提示而非無聲等待
   - ✅ **品牌體驗**: 增加擬人化感受（Avatar 在「思考」）
   - ✅ **設計一致性**: 符合對話 App 的 UX 慣例

### Testing

**測試框架**: 手動測試 + React DevTools + Chrome DevTools（POC 階段）

**測試範圍**:
1. ✅ SSE 串流接收正確（逐字顯示）
2. ✅ 打字機效果流暢（閃爍游標）
3. ✅ Loading 狀態正確（開始/結束）
4. ✅ 對話上下文保留（多輪對話）
5. ✅ 錯誤處理正確（網路錯誤、API 錯誤）
6. ✅ 重試機制正常運作
7. ✅ UI 狀態與 chatStore 同步
8. ✅ 無記憶體洩漏（長時間使用）

**測試執行方式**:
```bash
# 1. 啟動開發伺服器
pnpm dev

# 2. 開啟應用
http://localhost:3000

# 3. 測試正常對話
- 輸入「你好」並送出
- 觀察 Loading 狀態（「正在思考...」動畫）
- 觀察 SSE 串流（逐字顯示）
- 觀察打字機效果（閃爍游標）
- 觀察完成後狀態（游標消失）

# 4. 測試多輪對話
- 輸入「我叫小明」
- 等待回應
- 輸入「你還記得我的名字嗎？」
- 驗證回應包含「小明」

# 5. 測試錯誤處理
- 關閉 API 伺服器（Ctrl+C）
- 輸入訊息並送出
- 驗證錯誤訊息顯示
- 重啟 API 伺服器
- 驗證可恢復正常

# 6. 測試網路中斷
- 開啟 Chrome DevTools > Network
- 選擇 "Offline"
- 輸入訊息並送出
- 驗證錯誤訊息：「網路連線中斷」
```

**驗證清單**:
- [ ] `pnpm dev` 啟動無錯誤
- [ ] SSE 串流接收正確（逐字顯示）
- [ ] 打字機效果流暢（游標閃爍）
- [ ] Loading 狀態正確顯示與隱藏
- [ ] 「正在思考...」動畫流暢
- [ ] 多輪對話上下文正確保留
- [ ] 網路錯誤顯示適當訊息
- [ ] API 錯誤顯示適當訊息
- [ ] 重試邏輯正常運作（失敗後自動重試）
- [ ] chatStore 狀態正確更新
- [ ] React DevTools 顯示正確 state
- [ ] Console 無錯誤或警告
- [ ] TypeScript 型別檢查通過

**React DevTools 檢查步驟**:
1. 開啟 React DevTools (F12 → Components)
2. 選擇 ChatInterface 組件
3. 觀察 `useChatStore` hook 狀態
4. 送出訊息後，觀察 `messages` 陣列即時更新
5. 觀察 `isLoading` 狀態變化（true → false）
6. 驗證最後一則訊息內容完整

### 效能考量

**SSE 串流效能**:
- **首字延遲**: 通常 < 1 秒（取決於 Azure OpenAI API）
- **逐字顯示**: 每個 chunk ~10-50ms（流暢）
- **記憶體使用**: 每則訊息 ~1-2KB（可忽略）

**React 重渲染優化**:
- **問題**: 每個 chunk 都會觸發 chatStore 更新 → ChatInterface 重渲染
- **影響**: 100 個 chunks → 100 次重渲染（可能影響效能）
- **優化方向**（未來）:
  ```typescript
  // 使用 useMemo 避免不必要的計算
  const lastMessage = useMemo(
    () => messages[messages.length - 1],
    [messages]
  );

  // 使用 React.memo 避免子組件重渲染
  const MessageBubble = React.memo(({ message }) => { ... });
  ```

**未來優化方向**（MVP 階段）:
1. **Debounce 更新**: 合併多個 chunks，減少重渲染次數
2. **Virtual Scrolling**: 若訊息數量 > 100，使用虛擬滾動
3. **Web Worker**: 在背景執行 SSE 解析，避免阻塞主執行緒
4. **Message Batching**: 批次更新訊息（如每 100ms 更新一次）

### 安全性考量

**SSE 安全**:
- ✅ 所有請求透過 HTTPS（生產環境）
- ✅ 無敏感資料在 SSE 串流中傳輸（僅文字內容）
- ⚠️ POC 階段無認證（公開存取）

**XSS 防護**:
- ✅ React 預設轉義所有文字內容
- ✅ 使用 `whitespace-pre-wrap` 保留換行，但不渲染 HTML
- ⚠️ 若未來需支援 Markdown，必須使用 DOMPurify 過濾

**錯誤訊息安全**:
- ✅ 錯誤訊息不洩漏敏感資訊（如 API Key）
- ✅ 使用通用錯誤訊息（「遇到問題」）
- ✅ 詳細錯誤僅記錄於 console（不顯示給使用者）

### 依賴關係

**前置條件**:
- ✅ Story 3.1 已完成（ChatInterface 組件已建立）
- ✅ Story 3.2 已完成（chatStore 已建立）
- ✅ Story 3.3 已完成（Chat API 已實作）
- ✅ Node.js 18+ 與 pnpm 已安裝

**後續 Story 依賴**:
- **Story 3.5**: 會使用完整的 LLM 回應文字呼叫 TTS API
- **Story 3.6**: 會整合 TTS 音訊播放，與對話流程串接
- **Story 3.7**: 會整合完整端到端流程（對話 → TTS → 播放）

**關鍵路徑**:
- 本 Story 完成後，使用者可完整體驗文字對話流程
- Story 3.5/3.6（TTS）可與本 Story 並行開發
- Story 3.7 整合所有 Epic 3 功能，最後完成

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-14 | 1.0 | 建立 Story 3.4 草稿 | SM Agent |

---

## Dev Agent Record

*(此部分由 Dev Agent 在實作時填寫)*

### Agent Model Used
_待填寫_

### Debug Log References
_待填寫_

### Completion Notes List
_待填寫_

### File List
_待填寫_

---

## QA Results

*(此部分由 QA Agent 在審核時填寫)*

_待填寫_

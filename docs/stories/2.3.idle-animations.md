# Story 2.3: Avatar 待機動畫實作（呼吸、眨眼）

## Status
Approved

---

## Story

**As a** 開發者,
**I want** 實作 Avatar 的待機動畫（呼吸與眨眼效果），
**so that** Avatar 在未說話時看起來更加生動自然，而非靜止不動。

---

## Acceptance Criteria

1. 建立 `lib/avatar/animations.ts`，實作呼吸動畫控制邏輯
2. 實作呼吸動畫：Avatar 胸部/腹部有週期性起伏（Scale 變化）
3. 呼吸頻率：每次呼吸約 4 秒（吸氣 2 秒 + 呼氣 2 秒）
4. 實作眨眼動畫：使用 `eyesClosed` Blendshape 控制眼皮閉合
5. 眨眼頻率：隨機間隔 2-5 秒眨一次，每次眨眼約 0.15 秒
6. 使用 `useFrame` Hook（來自 @react-three/fiber）實作動畫迴圈
7. 動畫平滑自然，無抖動或突兀感
8. 在 `AvatarModel` 組件中整合待機動畫，Avatar 載入後自動播放

---

## Tasks / Subtasks

- [ ] **Task 1: 分析 Ready Player Me Avatar 結構** (AC: 2, 4)
  - [ ] 使用 Chrome DevTools 或 Three.js Inspector 檢視 Avatar 節點結構
  - [ ] 找出以下關鍵節點：
    - Spine/Chest 骨架節點（控制呼吸）
    - Head Mesh 的 Blendshapes（控制表情）
  - [ ] 記錄節點路徑：
    ```typescript
    // 範例結構
    ArmatureTarget/
      ├─ Hips/
      │   └─ Spine/
      │       └─ Spine1/
      │           └─ Spine2/      ← 胸部骨架（呼吸）
      └─ Wolf3D_Head/
          └─ morphTargetDictionary  ← Blendshapes
              └─ eyesClosed         ← 眨眼 Blendshape
    ```
  - [ ] 驗證 `eyesClosed` Blendshape 存在（值範圍 0-1）

- [ ] **Task 2: 建立動畫工具函式** (AC: 1)
  - [ ] 建立 `lib/avatar/animations.ts` 檔案
  - [ ] 實作呼吸動畫計算函式：
    ```typescript
    /**
     * 計算呼吸動畫的 Scale 值
     * @param time - 當前時間（秒）
     * @param breathingRate - 呼吸頻率（秒/次）
     * @param amplitude - 呼吸幅度（Scale 變化量）
     * @returns Scale 乘數（如 1.05 表示放大 5%）
     */
    export function calculateBreathingScale(
      time: number,
      breathingRate: number = 4,
      amplitude: number = 0.03
    ): number {
      // 使用正弦波模擬呼吸（平滑上下變化）
      const cycle = (time / breathingRate) * Math.PI * 2;
      return 1 + Math.sin(cycle) * amplitude;
    }
    ```
  - [ ] 實作眨眼動畫狀態管理：
    ```typescript
    export class BlinkController {
      private lastBlinkTime: number = 0;
      private nextBlinkDelay: number = 3;
      private isBlinking: boolean = false;
      private blinkStartTime: number = 0;

      /**
       * 更新眨眼狀態並返回 eyesClosed 值
       * @param currentTime - 當前時間（秒）
       * @returns eyesClosed Blendshape 值 (0-1)
       */
      update(currentTime: number): number {
        // 檢查是否該眨眼
        if (!this.isBlinking && currentTime - this.lastBlinkTime >= this.nextBlinkDelay) {
          this.isBlinking = true;
          this.blinkStartTime = currentTime;
          this.lastBlinkTime = currentTime;
          // 隨機下次眨眼時間（2-5秒）
          this.nextBlinkDelay = 2 + Math.random() * 3;
        }

        // 眨眼中
        if (this.isBlinking) {
          const blinkProgress = (currentTime - this.blinkStartTime) / 0.15; // 0.15秒完成

          if (blinkProgress >= 1) {
            // 眨眼完成
            this.isBlinking = false;
            return 0;
          }

          // 使用 ease-in-out 曲線（平滑閉合與打開）
          // 0-0.5: 閉合, 0.5-1.0: 打開
          if (blinkProgress < 0.5) {
            return this.easeInOut(blinkProgress * 2); // 0 → 1
          } else {
            return this.easeInOut((1 - blinkProgress) * 2); // 1 → 0
          }
        }

        return 0; // 眼睛睜開
      }

      private easeInOut(t: number): number {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
      }
    }
    ```
  - [ ] 加入 TypeScript 型別定義與 JSDoc 註解

- [ ] **Task 3: 建立 useAvatarAnimation Hook** (AC: 6, 8)
  - [ ] 建立 `components/avatar/hooks/` 目錄
  - [ ] 建立 `components/avatar/hooks/useAvatarAnimation.ts` 檔案
  - [ ] 實作自訂 Hook：
    ```typescript
    import { useFrame } from '@react-three/fiber';
    import { useRef } from 'react';
    import { Group, SkinnedMesh } from 'three';
    import { calculateBreathingScale, BlinkController } from '@/lib/avatar/animations';

    export function useAvatarAnimation(avatarRef: React.RefObject<Group>) {
      const blinkController = useRef(new BlinkController());

      useFrame((state) => {
        if (!avatarRef.current) return;

        const time = state.clock.getElapsedTime();

        // 1. 呼吸動畫（胸部 Scale 變化）
        const chestNode = avatarRef.current.getObjectByName('Spine2');
        if (chestNode) {
          const breathScale = calculateBreathingScale(time);
          chestNode.scale.set(breathScale, breathScale, breathScale);
        }

        // 2. 眨眼動畫（eyesClosed Blendshape）
        const headMesh = avatarRef.current.getObjectByName('Wolf3D_Head') as SkinnedMesh;
        if (headMesh && headMesh.morphTargetDictionary && headMesh.morphTargetInfluences) {
          const eyesClosedIndex = headMesh.morphTargetDictionary['eyesClosed'];
          if (eyesClosedIndex !== undefined) {
            const blinkValue = blinkController.current.update(time);
            headMesh.morphTargetInfluences[eyesClosedIndex] = blinkValue;
          }
        }
      });
    }
    ```
  - [ ] 加入錯誤處理（節點不存在時不拋錯）
  - [ ] 加入 TypeScript 型別定義

- [ ] **Task 4: 整合待機動畫至 AvatarModel** (AC: 8)
  - [ ] 開啟 `components/avatar/AvatarModel.tsx`
  - [ ] 引入 useAvatarAnimation Hook
  - [ ] 建立 Avatar Group Ref：
    ```typescript
    import { useRef } from 'react';
    import { Group } from 'three';
    import { useAvatarAnimation } from './hooks/useAvatarAnimation';

    export default function AvatarModel({ modelUrl, position, scale, onLoad, onError }: AvatarModelProps) {
      const avatarRef = useRef<Group>(null);
      const { scene, error } = useGLTF(modelUrl, true);

      // 啟用待機動畫
      useAvatarAnimation(avatarRef);

      // ... 其餘程式碼
      return (
        <group ref={avatarRef} position={position} scale={scale}>
          <primitive object={scene} />
        </group>
      );
    }
    ```
  - [ ] 驗證動畫在模型載入後自動播放

- [ ] **Task 5: 呼吸動畫調校與測試** (AC: 2, 3, 7)
  - [ ] 執行 `pnpm dev`，觀察 Avatar 呼吸動畫
  - [ ] 驗證以下項目：
    - ✅ 胸部有明顯但不誇張的起伏
    - ✅ 呼吸週期約 4 秒（完整吸氣+呼氣）
    - ✅ 動畫平滑無抖動
    - ✅ 不影響 Avatar 其他部位
  - [ ] 如動畫不明顯，調整 `amplitude` 參數（0.03 → 0.05）
  - [ ] 如動畫過快/過慢，調整 `breathingRate`（4 → 3 或 5）
  - [ ] 使用 OrbitControls 從側面觀察呼吸效果
  - [ ] 記錄最佳參數值

- [ ] **Task 6: 眨眼動畫調校與測試** (AC: 4, 5, 7)
  - [ ] 觀察 Avatar 眨眼動畫
  - [ ] 驗證以下項目：
    - ✅ 眨眼動作自然（眼皮完全閉合再打開）
    - ✅ 眨眼速度適中（約 0.15 秒）
    - ✅ 眨眼間隔隨機（不會固定節奏）
    - ✅ 眨眼不影響其他表情
  - [ ] 使用 Chrome DevTools Console 記錄眨眼時間：
    ```typescript
    console.log('Blink at', currentTime);
    ```
  - [ ] 觀察 2 分鐘，統計眨眼次數（應約 20-30 次）
  - [ ] 如眨眼過快/過慢，調整間隔範圍（2-5 秒）
  - [ ] 如眨眼不自然，調整 easeInOut 曲線

- [ ] **Task 7: 效能與記憶體檢查** (AC: 7)
  - [ ] 開啟 Chrome DevTools Performance 面板
  - [ ] 記錄 30 秒渲染效能
  - [ ] 驗證以下項目：
    - ✅ FPS 穩定 ≥ 30（理想 60）
    - ✅ 無明顯掉幀或卡頓
    - ✅ CPU 使用率合理（< 50%）
    - ✅ 記憶體無持續增長（無記憶體洩漏）
  - [ ] 檢查 `useFrame` 是否正確清理（組件卸載時停止）
  - [ ] 如效能不佳，考慮以下優化：
    - 降低動畫更新頻率（每 2 幀更新一次）
    - 使用 RAF (requestAnimationFrame) 節流
    - 減少 Blendshape 數量

---

## Dev Notes

### 相關來源樹（Source Tree）

Epic 2 Story 2.3 完成後的檔案結構：

```
avatar-chat-poc/
├── components/
│   └── avatar/
│       ├── AvatarCanvas.tsx
│       ├── AvatarModel.tsx         # 更新：整合 useAvatarAnimation
│       ├── AvatarLoadingState.tsx
│       └── hooks/
│           └── useAvatarAnimation.ts  # 新增：動畫 Hook
├── lib/
│   └── avatar/
│       ├── loaders.ts
│       ├── constants.ts
│       └── animations.ts           # 新增：動畫計算函式
└── types/
    └── avatar.ts
```

### 呼吸動畫技術原理

**為何使用正弦波（Sine Wave）？**
- 正弦波提供平滑的週期性變化
- 符合人類自然呼吸的節奏感
- 數學公式簡單，效能高

**呼吸動畫數學**:
```typescript
// 正弦波公式
scale = 1 + sin(time / breathingRate * 2π) * amplitude

// 參數說明
time: 當前時間（秒）
breathingRate: 4 秒（一次完整呼吸）
amplitude: 0.03（3% 的 Scale 變化）
2π: 完整週期（360度）

// 效果
- time = 0s → scale = 1.00 (中間)
- time = 1s → scale = 1.03 (吸氣高峰)
- time = 2s → scale = 1.00 (中間)
- time = 3s → scale = 0.97 (呼氣低點)
- time = 4s → scale = 1.00 (回到起點)
```

**為何調整 Spine2 節點？**
- Spine2 是胸部中段骨架
- Scale 變化會影響胸部與腹部
- 不會影響頭部與四肢
- 最接近人體真實呼吸動作

**參數調校指南**:
| 參數 | 預設值 | 效果 | 調整建議 |
|------|--------|------|---------|
| breathingRate | 4 秒 | 呼吸速度 | 3-5 秒（太快會不自然） |
| amplitude | 0.03 | 起伏幅度 | 0.02-0.05（過大會誇張） |

### 眨眼動畫技術原理

**Blendshapes 是什麼？**
- Blendshapes (Morph Targets)：預定義的頂點變形
- `eyesClosed`: 眼皮完全閉合的形狀
- 值範圍 0-1：0 = 睜開，1 = 閉合
- 可混合多個 Blendshapes（如微笑 + 眨眼）

**眨眼動畫狀態機**:
```
[睜眼] ---(等待 2-5秒)---> [開始眨眼]
                                 ↓
                           (0.075秒閉合)
                                 ↓
                           (0.075秒打開)
                                 ↓
                            [睜眼完成]
```

**Ease-In-Out 曲線**:
```typescript
// 線性變化（生硬）
eyesClosed = progress;  // 0 → 1 均速

// Ease-In-Out（平滑）
if (progress < 0.5) {
  return 2 * progress * progress;  // 加速閉合
} else {
  return -1 + (4 - 2 * progress) * progress;  // 減速打開
}

// 效果比較
線性：  0 → 0.25 → 0.5 → 0.75 → 1.0
Ease：  0 → 0.125 → 0.5 → 0.875 → 1.0
        (慢) (快) (中) (快) (慢)
```

**隨機間隔原理**:
```typescript
// 人類眨眼頻率：每分鐘 15-20 次 = 每 3-4 秒一次
// 但不是固定節奏，需要隨機性
nextBlinkDelay = 2 + Math.random() * 3;  // 2-5秒隨機

// 效果
第1次眨眼：3.2秒後
第2次眨眼：4.7秒後
第3次眨眼：2.1秒後
（避免規律性，更自然）
```

### useFrame Hook 詳細說明

**useFrame 是什麼？**
- React Three Fiber 提供的 Hook
- 每幀執行一次（60 FPS = 每秒 60 次）
- 接收 `state` 參數，包含時間、相機等資訊

**基本用法**:
```typescript
useFrame((state, delta) => {
  // state.clock: Three.js Clock 物件
  // state.clock.getElapsedTime(): 總執行時間（秒）
  // delta: 距離上一幀的時間（秒）

  const time = state.clock.getElapsedTime();
  // 在這裡更新動畫
});
```

**效能考量**:
- useFrame 每秒執行 60 次 → 需要高效能
- 避免在內部執行複雜計算
- 避免建立新物件（使用 useRef）
- 確保組件卸載時自動清理

**自動清理**:
```typescript
// React Three Fiber 自動處理
// 組件卸載時，useFrame 自動停止
// 無需手動清理 → 避免記憶體洩漏
```

### 重要架構決策

1. **為何使用自訂 Hook？**
   - ✅ 分離關注點：動畫邏輯獨立於組件
   - ✅ 可重用性：其他組件也可使用
   - ✅ 測試性：Hook 可單獨測試
   - ✅ 可維護性：動畫邏輯集中管理

2. **為何使用 Class 管理眨眼狀態？**
   ```typescript
   // 使用 Class（推薦）
   const blinkController = useRef(new BlinkController());

   // 使用多個 useState（不推薦）
   const [lastBlinkTime, setLastBlinkTime] = useState(0);
   const [isBlinking, setIsBlinking] = useState(false);
   // ... 更多狀態
   ```
   - ✅ 狀態集中管理，避免多次 setState
   - ✅ useRef 避免重新渲染
   - ✅ 更接近物件導向設計

3. **為何不使用 Three.js AnimationMixer？**
   - AnimationMixer 用於骨架動畫（如走路、跑步）
   - 待機動畫是程序式動畫（Procedural Animation）
   - 程序式動畫更靈活、檔案更小
   - 無需外部動畫檔案（FBX/GLTF）

4. **動畫優先級決策**:
   - 待機動畫優先級最低
   - 未來 Lip Sync 會覆蓋待機動畫
   - 需要設計動畫混合機制（Story 3.x）

### 動畫調校指南

**呼吸動畫調校**:
```typescript
// 參數組合建議
// 自然呼吸（預設）
breathingRate: 4, amplitude: 0.03

// 運動後（快速呼吸）
breathingRate: 2.5, amplitude: 0.05

// 放鬆狀態（緩慢呼吸）
breathingRate: 5, amplitude: 0.02

// 睡眠（極慢）
breathingRate: 6, amplitude: 0.015
```

**眨眼動畫調校**:
```typescript
// 參數組合建議
// 正常眨眼（預設）
間隔: 2-5秒, 速度: 0.15秒

// 緊張狀態（頻繁眨眼）
間隔: 1-3秒, 速度: 0.12秒

// 專注狀態（減少眨眼）
間隔: 4-8秒, 速度: 0.15秒

// 疲勞狀態（慢眨眼）
間隔: 3-6秒, 速度: 0.25秒
```

### Testing

**測試框架**: 手動測試 + 視覺驗證 + 效能監控

**測試範圍**:
1. ✅ 呼吸動畫正確播放
2. ✅ 呼吸週期約 4 秒
3. ✅ 呼吸幅度自然（不誇張）
4. ✅ 眨眼動畫正確播放
5. ✅ 眨眼速度自然（約 0.15 秒）
6. ✅ 眨眼間隔隨機（2-5 秒）
7. ✅ 動畫平滑無抖動
8. ✅ FPS 穩定 ≥ 30

**測試執行方式**:
```bash
# 啟動開發伺服器
pnpm dev

# 瀏覽器開啟
http://localhost:3000

# 測試項目
1. 觀察 Avatar 胸部是否有週期性起伏
2. 計時 4 次呼吸，驗證週期 ≈ 16 秒（4秒/次）
3. 觀察 Avatar 是否自然眨眼
4. 記錄 1 分鐘內眨眼次數（應約 12-30 次）
5. 使用 OrbitControls 從不同角度檢視動畫
6. 開啟 DevTools Performance，檢查 FPS
```

**驗證清單**:
- [ ] 胸部有明顯但自然的起伏
- [ ] 呼吸週期穩定（4 秒 ± 0.5 秒）
- [ ] 眨眼動作流暢（無突兀感）
- [ ] 眨眼間隔隨機（非固定節奏）
- [ ] 動畫無抖動或突然停止
- [ ] FPS 穩定 ≥ 30
- [ ] Console 無錯誤訊息
- [ ] 記憶體無持續增長

### 已知問題與注意事項

**Ready Player Me 模型差異**:
- ⚠️ 不同 Avatar 的節點名稱可能略有差異
- ⚠️ 某些 Avatar 可能缺少 `eyesClosed` Blendshape
- ⚠️ Spine2 節點位置可能因模型而異

**解決方案**:
```typescript
// 容錯處理
const chestNode = avatarRef.current.getObjectByName('Spine2')
                || avatarRef.current.getObjectByName('Chest');

if (!chestNode) {
  console.warn('Chest node not found, breathing animation disabled');
  return;
}
```

**效能影響**:
- useFrame 每秒執行 60 次 → 需要優化
- Blendshape 更新有輕微效能成本
- 多個 Avatar 同時播放待機動畫會累加成本

**動畫衝突**:
- 待機動畫 vs Lip Sync（未來需處理）
- 待機動畫 vs 表情控制（Story 2.4 需處理）
- 需要設計動畫優先級系統

### 效能優化策略

**優化 1: 節流更新**
```typescript
// 不是每幀都更新（降低頻率）
let frameCount = 0;
useFrame((state) => {
  frameCount++;
  if (frameCount % 2 !== 0) return;  // 每 2 幀更新一次

  // 動畫更新邏輯
});
```

**優化 2: 避免查找**
```typescript
// 不推薦（每幀查找節點）
const chest = avatarRef.current.getObjectByName('Spine2');

// 推薦（快取節點引用）
const chestRef = useRef<Object3D | null>(null);
useEffect(() => {
  if (avatarRef.current) {
    chestRef.current = avatarRef.current.getObjectByName('Spine2');
  }
}, [scene]);

useFrame(() => {
  if (chestRef.current) {
    // 直接使用快取
  }
});
```

**優化 3: 條件更新**
```typescript
// 只在眨眼時更新 Blendshape
if (blinkController.current.isBlinking) {
  // 更新 eyesClosed
}
// 不眨眼時跳過更新
```

### 依賴關係

**前置條件**:
- ✅ Story 2.1 已完成（Three.js 場景）
- ✅ Story 2.2 已完成（Avatar 模型已載入）
- ✅ Avatar 包含 Spine2 節點與 eyesClosed Blendshape

**後續 Story 依賴**:
- Story 2.4: 會擴展動畫系統，加入表情控制
- Epic 3 (Lip Sync): 需要與待機動畫整合，避免衝突
- Epic 4 (情緒系統): 會根據情緒調整待機動畫參數

**技術債務**:
- [ ] 未來需實作動畫優先級系統
- [ ] 未來需支援動畫混合（Blend）
- [ ] 未來需加入動畫停用開關（效能優化）

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-14 | 1.0 | 建立 Story 2.3 草稿 | SM Agent |

---

## Dev Agent Record

*(此部分由 Dev Agent 在實作時填寫)*

### Agent Model Used
_待填寫_

### Debug Log References
_待填寫_

### Completion Notes List
_待填寫_

### File List
_待填寫_

---

## QA Results

*(此部分由 QA Agent 在審核時填寫)*

_待填寫_

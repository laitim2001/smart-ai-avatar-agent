# Story 5.4: 瀏覽器相容性測試

**Epic**: Epic 5 - Polish & Deployment
**Story ID**: 5.4
**Story 名稱**: 瀏覽器相容性測試
**優先順序**: High
**預估時間**: 5 小時
**狀態**: Draft

---

## 📋 Story 描述

### User Story
**As a** 使用者
**I want** 應用程式在所有主流瀏覽器都能正常運作
**So that** 我不論使用哪種瀏覽器，都能享受完整的功能與體驗

### Business Value
- **覆蓋率最大化**: 支援主流瀏覽器確保最大使用者覆蓋率（Chrome 65%, Safari 18%, Edge 5%, Firefox 3%）
- **減少支援成本**: 提前發現與修復瀏覽器相容性問題，避免上線後大量客訴
- **專業形象**: 跨瀏覽器一致體驗展現產品成熟度
- **技術債控制**: 記錄已知限制與 Workarounds，為未來優化建立基礎

### Technical Context
- **Target Browsers**: Chrome 120+, Edge 120+, Safari 17+, Firefox 121+
- **Core Technologies**: WebGL (Three.js), Web Audio API, ES2020+, CSS Grid/Flexbox
- **Known Issues**: Safari WebGL performance, Firefox Audio Context autoplay policy
- **Testing Strategy**: Manual testing + Automated cross-browser testing (BrowserStack/Playwright)

---

## ✅ Acceptance Criteria

### Functional Requirements
1. **Chrome (Desktop & Mobile)**:
   - [ ] 3D Avatar 正常渲染（WebGL）
   - [ ] TTS 語音正常播放（Web Audio API）
   - [ ] Lip Sync 動畫流暢（30 FPS）
   - [ ] 所有 UI 動畫正常（Framer Motion）
   - [ ] 響應式佈局正確（Desktop/Mobile）

2. **Safari (Desktop & iOS)**:
   - [ ] WebGL 渲染正常（可能需要降級材質）
   - [ ] Web Audio API 正常（需手動啟用 AudioContext）
   - [ ] CSS Grid/Flexbox 正常
   - [ ] iOS Safari 不因記憶體問題 crash

3. **Edge (Chromium-based)**:
   - [ ] 與 Chrome 功能一致
   - [ ] WebGL 效能相當
   - [ ] 無特殊相容性問題

4. **Firefox**:
   - [ ] WebGL 渲染正常
   - [ ] Web Audio API autoplay policy 處理正確
   - [ ] CSS variables 支援正常
   - [ ] Framer Motion 動畫流暢

### Non-Functional Requirements
1. **效能**: 所有瀏覽器維持 FPS ≥ 30
2. **一致性**: UI 外觀在各瀏覽器差異 ≤5%
3. **降級策略**: Safari WebGL 效能不足時自動降級 LOD
4. **錯誤處理**: 不支援功能顯示友善提示（如 WebGL 不支援）

---

## 🏗️ Technical Design

### Browser Compatibility Matrix

```
Feature Compatibility Matrix:
┌────────────────────────┬────────┬────────┬────────┬─────────┐
│ Feature                │ Chrome │ Safari │ Edge   │ Firefox │
├────────────────────────┼────────┼────────┼────────┼─────────┤
│ WebGL 2.0              │   ✅   │   ✅   │   ✅   │   ✅    │
│ Web Audio API          │   ✅   │   ⚠️   │   ✅   │   ⚠️    │
│ ES2020 (Optional Chain)│   ✅   │   ✅   │   ✅   │   ✅    │
│ CSS Grid               │   ✅   │   ✅   │   ✅   │   ✅    │
│ CSS Variables          │   ✅   │   ✅   │   ✅   │   ✅    │
│ Framer Motion          │   ✅   │   ✅   │   ✅   │   ✅    │
│ Dynamic Import         │   ✅   │   ✅   │   ✅   │   ✅    │
│ IndexedDB              │   ✅   │   ✅   │   ✅   │   ✅    │
└────────────────────────┴────────┴────────┴────────┴─────────┘

Legend:
✅ Fully supported
⚠️ Requires workaround or user interaction
❌ Not supported (fallback required)
```

### Known Browser Issues

**Safari**:
- **Issue 1**: AudioContext requires user gesture to start
  - **Workaround**: 顯示「點擊開始」按鈕啟用音訊
- **Issue 2**: WebGL performance lower than Chrome
  - **Workaround**: 自動降級 LOD，減少 vertices
- **Issue 3**: iOS Safari memory limit (≈1.5GB)
  - **Workaround**: 限制 texture resolution，aggressive GC

**Firefox**:
- **Issue 1**: Autoplay policy blocks Web Audio
  - **Workaround**: 同 Safari，需 user gesture
- **Issue 2**: CSS backdrop-filter performance
  - **Workaround**: Fallback to solid background

**Edge**:
- **Issue 1**: (None expected, Chromium-based)

### Feature Detection Strategy

```typescript
export interface BrowserCapabilities {
  webgl: boolean;
  webgl2: boolean;
  webAudio: boolean;
  dynamicImport: boolean;
  cssGrid: boolean;
  cssVariables: boolean;
}

export function detectBrowserCapabilities(): BrowserCapabilities {
  const canvas = document.createElement('canvas');
  const webgl = !!(canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));
  const webgl2 = !!canvas.getContext('webgl2');

  return {
    webgl,
    webgl2,
    webAudio: 'AudioContext' in window || 'webkitAudioContext' in window,
    dynamicImport: 'noModule' in HTMLScriptElement.prototype,
    cssGrid: CSS.supports('display', 'grid'),
    cssVariables: CSS.supports('--test', '0'),
  };
}
```

---

## 📝 Tasks

### Task 1: 建立瀏覽器特性檢測工具

**描述**: 實作 Feature Detection 工具，檢測瀏覽器支援的關鍵功能

**檔案**: `src/lib/browser-detection.ts`

**程式碼實作**:
```typescript
export interface BrowserCapabilities {
  // Core Features
  webgl: boolean;
  webgl2: boolean;
  webAudio: boolean;

  // Modern JS
  dynamicImport: boolean;
  optionalChaining: boolean;

  // Modern CSS
  cssGrid: boolean;
  cssFlexbox: boolean;
  cssVariables: boolean;

  // Performance APIs
  performanceObserver: boolean;
  intersectionObserver: boolean;
}

export interface BrowserInfo {
  name: string;
  version: string;
  platform: 'desktop' | 'mobile';
  os: string;
}

/**
 * Detect browser capabilities for feature support
 */
export function detectBrowserCapabilities(): BrowserCapabilities {
  // WebGL detection
  const canvas = document.createElement('canvas');
  const webgl = !!(
    canvas.getContext('webgl') ||
    canvas.getContext('experimental-webgl')
  );
  const webgl2 = !!canvas.getContext('webgl2');

  // Web Audio API detection
  const webAudio = !!(
    window.AudioContext ||
    (window as any).webkitAudioContext
  );

  // Modern JS features
  const dynamicImport = 'noModule' in HTMLScriptElement.prototype;
  const optionalChaining = (() => {
    try {
      eval('const obj = {}; obj?.test');
      return true;
    } catch {
      return false;
    }
  })();

  // Modern CSS features
  const cssGrid = CSS.supports('display', 'grid');
  const cssFlexbox = CSS.supports('display', 'flex');
  const cssVariables = CSS.supports('--test', '0');

  // Performance APIs
  const performanceObserver = 'PerformanceObserver' in window;
  const intersectionObserver = 'IntersectionObserver' in window;

  return {
    webgl,
    webgl2,
    webAudio,
    dynamicImport,
    optionalChaining,
    cssGrid,
    cssFlexbox,
    cssVariables,
    performanceObserver,
    intersectionObserver,
  };
}

/**
 * Detect browser name and version
 */
export function detectBrowserInfo(): BrowserInfo {
  const ua = navigator.userAgent;
  let name = 'Unknown';
  let version = 'Unknown';
  let platform: 'desktop' | 'mobile' = 'desktop';
  let os = 'Unknown';

  // Detect OS
  if (ua.includes('Windows')) {
    os = 'Windows';
  } else if (ua.includes('Mac')) {
    os = 'macOS';
  } else if (ua.includes('Linux')) {
    os = 'Linux';
  } else if (ua.includes('Android')) {
    os = 'Android';
    platform = 'mobile';
  } else if (ua.includes('iOS') || ua.includes('iPhone') || ua.includes('iPad')) {
    os = 'iOS';
    platform = 'mobile';
  }

  // Detect Browser
  if (ua.includes('Edg/')) {
    name = 'Edge';
    version = ua.match(/Edg\/(\d+)/)?.[1] || 'Unknown';
  } else if (ua.includes('Chrome/') && !ua.includes('Edg/')) {
    name = 'Chrome';
    version = ua.match(/Chrome\/(\d+)/)?.[1] || 'Unknown';
  } else if (ua.includes('Safari/') && !ua.includes('Chrome')) {
    name = 'Safari';
    version = ua.match(/Version\/(\d+)/)?.[1] || 'Unknown';
  } else if (ua.includes('Firefox/')) {
    name = 'Firefox';
    version = ua.match(/Firefox\/(\d+)/)?.[1] || 'Unknown';
  }

  return {
    name,
    version,
    platform,
    os,
  };
}

/**
 * Check if browser is supported
 */
export function isBrowserSupported(): {
  supported: boolean;
  missingFeatures: string[];
} {
  const capabilities = detectBrowserCapabilities();
  const missingFeatures: string[] = [];

  // Required features
  if (!capabilities.webgl) {
    missingFeatures.push('WebGL (3D 渲染)');
  }
  if (!capabilities.webAudio) {
    missingFeatures.push('Web Audio API (語音播放)');
  }
  if (!capabilities.cssGrid) {
    missingFeatures.push('CSS Grid (佈局)');
  }
  if (!capabilities.dynamicImport) {
    missingFeatures.push('Dynamic Import (程式碼分割)');
  }

  return {
    supported: missingFeatures.length === 0,
    missingFeatures,
  };
}

/**
 * Log browser capabilities for debugging
 */
export function logBrowserInfo(): void {
  const info = detectBrowserInfo();
  const capabilities = detectBrowserCapabilities();
  const support = isBrowserSupported();

  console.group('🌐 Browser Information');
  console.log(`Browser: ${info.name} ${info.version}`);
  console.log(`Platform: ${info.platform} (${info.os})`);
  console.log(`Supported: ${support.supported ? '✅' : '❌'}`);
  if (!support.supported) {
    console.warn('Missing Features:', support.missingFeatures);
  }
  console.groupEnd();

  console.group('✨ Feature Support');
  Object.entries(capabilities).forEach(([feature, supported]) => {
    console.log(`${supported ? '✅' : '❌'} ${feature}`);
  });
  console.groupEnd();
}
```

**使用範例**:
```typescript
// src/app/layout.tsx
'use client';

import { useEffect } from 'react';
import { isBrowserSupported, logBrowserInfo } from '@/lib/browser-detection';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  useEffect(() => {
    // Log browser info in development
    if (process.env.NODE_ENV === 'development') {
      logBrowserInfo();
    }

    // Check browser support
    const { supported, missingFeatures } = isBrowserSupported();
    if (!supported) {
      alert(`您的瀏覽器不支援以下功能:\n${missingFeatures.join('\n')}`);
    }
  }, []);

  return (
    <html lang="zh-TW">
      <body>{children}</body>
    </html>
  );
}
```

**驗證方式**:
- [ ] Chrome: 所有功能檢測為 ✅
- [ ] Safari: WebGL, Web Audio, CSS 功能正常檢測
- [ ] Firefox: 正確檢測 autoplay policy
- [ ] Edge: 與 Chrome 檢測結果一致
- [ ] 不支援功能時顯示友善提示

---

### Task 2: Safari Web Audio API Workaround

**描述**: 處理 Safari 的 AudioContext 需要 user gesture 才能啟用的限制

**檔案**: `src/hooks/useAudioContext.ts`

**程式碼實作**:
```typescript
'use client';

import { useState, useEffect, useCallback, useRef } from 'react';

export function useAudioContext() {
  const [audioContext, setAudioContext] = useState<AudioContext | null>(null);
  const [isReady, setIsReady] = useState(false);
  const [needsUserGesture, setNeedsUserGesture] = useState(false);
  const audioContextRef = useRef<AudioContext | null>(null);

  useEffect(() => {
    // Check if AudioContext is available
    const AudioContextClass = window.AudioContext || (window as any).webkitAudioContext;
    if (!AudioContextClass) {
      console.error('Web Audio API not supported');
      return;
    }

    // Create AudioContext
    try {
      const ctx = new AudioContextClass();
      audioContextRef.current = ctx;

      // Check if context is suspended (Safari requires user gesture)
      if (ctx.state === 'suspended') {
        setNeedsUserGesture(true);
      } else {
        setIsReady(true);
        setAudioContext(ctx);
      }
    } catch (error) {
      console.error('Failed to create AudioContext:', error);
    }

    return () => {
      audioContextRef.current?.close();
    };
  }, []);

  const resumeAudioContext = useCallback(async () => {
    if (!audioContextRef.current) return;

    try {
      if (audioContextRef.current.state === 'suspended') {
        await audioContextRef.current.resume();
        setIsReady(true);
        setNeedsUserGesture(false);
        setAudioContext(audioContextRef.current);
        console.log('AudioContext resumed successfully');
      }
    } catch (error) {
      console.error('Failed to resume AudioContext:', error);
    }
  }, []);

  return {
    audioContext,
    isReady,
    needsUserGesture,
    resumeAudioContext,
  };
}
```

**啟用音訊按鈕組件**:
```typescript
// src/components/AudioContextGate.tsx
'use client';

import React from 'react';
import { useAudioContext } from '@/hooks/useAudioContext';
import { motion } from 'framer-motion';

interface AudioContextGateProps {
  children: React.ReactNode;
}

export function AudioContextGate({ children }: AudioContextGateProps) {
  const { isReady, needsUserGesture, resumeAudioContext } = useAudioContext();

  if (needsUserGesture) {
    return (
      <div
        style={{
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          justifyContent: 'center',
          height: '100vh',
          backgroundColor: '#f8f9fa',
          padding: '20px',
        }}
      >
        <div
          style={{
            maxWidth: '500px',
            textAlign: 'center',
            padding: '40px',
            backgroundColor: 'white',
            borderRadius: '12px',
            boxShadow: '0 4px 12px rgba(0,0,0,0.1)',
          }}
        >
          <div style={{ fontSize: '64px', marginBottom: '24px' }}>🔊</div>
          <h2 style={{ fontSize: '24px', marginBottom: '16px', color: '#212529' }}>
            啟用音訊功能
          </h2>
          <p style={{ fontSize: '16px', marginBottom: '32px', color: '#6c757d' }}>
            為了播放語音，請點擊下方按鈕啟用音訊功能
          </p>
          <motion.button
            onClick={resumeAudioContext}
            style={{
              padding: '16px 32px',
              fontSize: '18px',
              backgroundColor: '#007bff',
              color: 'white',
              border: 'none',
              borderRadius: '8px',
              cursor: 'pointer',
              fontWeight: 'bold',
            }}
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
          >
            🎵 啟用音訊
          </motion.button>
          <p
            style={{
              fontSize: '14px',
              marginTop: '24px',
              color: '#adb5bd',
            }}
          >
            這是瀏覽器的安全限制，需要您的確認
          </p>
        </div>
      </div>
    );
  }

  if (!isReady) {
    return (
      <div
        style={{
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          height: '100vh',
        }}
      >
        <p>正在初始化音訊系統...</p>
      </div>
    );
  }

  return <>{children}</>;
}
```

**整合到 App**:
```typescript
// src/app/layout.tsx
import { AudioContextGate } from '@/components/AudioContextGate';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="zh-TW">
      <body>
        <AudioContextGate>
          {children}
        </AudioContextGate>
      </body>
    </html>
  );
}
```

**驗證方式**:
- [ ] Chrome: 自動啟用，不顯示啟用按鈕
- [ ] Safari (Desktop): 顯示啟用按鈕，點擊後正常運作
- [ ] Safari (iOS): 顯示啟用按鈕，點擊後正常運作
- [ ] Firefox: 顯示啟用按鈕（autoplay policy）
- [ ] AudioContext 啟用後可正常播放音訊

---

### Task 3: Safari WebGL 效能優化與降級

**描述**: 偵測 Safari 並自動降級 LOD，提升 WebGL 渲染效能

**檔案**: `src/lib/webgl-optimization.ts`

**程式碼實作**:
```typescript
import { detectBrowserInfo } from './browser-detection';

export interface WebGLOptimizationConfig {
  antialias: boolean;
  shadows: boolean;
  maxTextureSize: number;
  lodLevel: 'high' | 'medium' | 'low';
  pixelRatio: number;
}

/**
 * Get optimized WebGL config based on browser
 */
export function getWebGLConfig(): WebGLOptimizationConfig {
  const browserInfo = detectBrowserInfo();
  const isSafari = browserInfo.name === 'Safari';
  const isMobile = browserInfo.platform === 'mobile';

  // Safari or mobile: Use lower settings
  if (isSafari || isMobile) {
    return {
      antialias: false,
      shadows: false,
      maxTextureSize: 1024,
      lodLevel: 'medium',
      pixelRatio: Math.min(window.devicePixelRatio, 1.5),
    };
  }

  // Desktop Chrome/Edge/Firefox: Full quality
  return {
    antialias: true,
    shadows: false, // Still disabled for performance (POC)
    maxTextureSize: 2048,
    lodLevel: 'high',
    pixelRatio: Math.min(window.devicePixelRatio, 2),
  };
}

/**
 * Check WebGL support and capabilities
 */
export function checkWebGLSupport(): {
  supported: boolean;
  version: 1 | 2 | null;
  maxTextureSize: number;
  maxVertexAttributes: number;
} {
  const canvas = document.createElement('canvas');

  // Check WebGL 2.0
  const gl2 = canvas.getContext('webgl2');
  if (gl2) {
    return {
      supported: true,
      version: 2,
      maxTextureSize: gl2.getParameter(gl2.MAX_TEXTURE_SIZE),
      maxVertexAttributes: gl2.getParameter(gl2.MAX_VERTEX_ATTRIBS),
    };
  }

  // Check WebGL 1.0
  const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
  if (gl) {
    return {
      supported: true,
      version: 1,
      maxTextureSize: (gl as WebGLRenderingContext).getParameter(
        (gl as WebGLRenderingContext).MAX_TEXTURE_SIZE
      ),
      maxVertexAttributes: (gl as WebGLRenderingContext).getParameter(
        (gl as WebGLRenderingContext).MAX_VERTEX_ATTRIBS
      ),
    };
  }

  // No WebGL support
  return {
    supported: false,
    version: null,
    maxTextureSize: 0,
    maxVertexAttributes: 0,
  };
}

/**
 * Log WebGL capabilities
 */
export function logWebGLInfo(): void {
  const support = checkWebGLSupport();
  const config = getWebGLConfig();

  console.group('🎨 WebGL Information');
  console.log(`Supported: ${support.supported ? '✅' : '❌'}`);
  console.log(`Version: WebGL ${support.version || 'N/A'}`);
  console.log(`Max Texture Size: ${support.maxTextureSize}`);
  console.log(`Max Vertex Attributes: ${support.maxVertexAttributes}`);
  console.groupEnd();

  console.group('⚙️ Optimization Config');
  console.log(`Antialias: ${config.antialias ? '✅' : '❌'}`);
  console.log(`Shadows: ${config.shadows ? '✅' : '❌'}`);
  console.log(`Max Texture Size: ${config.maxTextureSize}px`);
  console.log(`LOD Level: ${config.lodLevel}`);
  console.log(`Pixel Ratio: ${config.pixelRatio}`);
  console.groupEnd();
}
```

**在 AvatarCanvas 中使用**:
```typescript
// src/components/avatar/AvatarCanvas.tsx
'use client';

import React, { useEffect, useState } from 'react';
import { Canvas } from '@react-three/fiber';
import { getWebGLConfig, checkWebGLSupport } from '@/lib/webgl-optimization';
import { AvatarModel } from './AvatarModel';

export function AvatarCanvas() {
  const [webglConfig, setWebglConfig] = useState(getWebGLConfig());
  const [webglSupported, setWebglSupported] = useState(true);

  useEffect(() => {
    const support = checkWebGLSupport();
    if (!support.supported) {
      setWebglSupported(false);
      alert('您的瀏覽器不支援 WebGL，無法顯示 3D Avatar');
    }
  }, []);

  if (!webglSupported) {
    return (
      <div style={{ width: '100%', height: '100vh', backgroundColor: '#1a1a1a' }}>
        <div
          style={{
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            height: '100%',
            color: 'white',
            textAlign: 'center',
            padding: '20px',
          }}
        >
          <div style={{ fontSize: '64px', marginBottom: '20px' }}>😔</div>
          <h2 style={{ fontSize: '24px', marginBottom: '12px' }}>
            無法顯示 3D Avatar
          </h2>
          <p style={{ fontSize: '16px', color: '#aaa' }}>
            您的瀏覽器不支援 WebGL，請更新瀏覽器或使用 Chrome/Edge
          </p>
        </div>
      </div>
    );
  }

  return (
    <Canvas
      camera={{ position: [0, 1.5, 3], fov: 50 }}
      gl={{
        antialias: webglConfig.antialias,
        pixelRatio: webglConfig.pixelRatio,
      }}
      shadows={webglConfig.shadows}
      style={{ width: '100%', height: '100vh', backgroundColor: '#1a1a1a' }}
    >
      <AvatarModel lodLevel={webglConfig.lodLevel} />
    </Canvas>
  );
}
```

**驗證方式**:
- [ ] Chrome: 使用 high LOD, antialias enabled
- [ ] Safari: 自動降級為 medium LOD, antialias disabled
- [ ] Mobile: 自動降級為 medium LOD, pixelRatio ≤1.5
- [ ] WebGL 不支援時顯示友善錯誤訊息
- [ ] 效能提升可感知（Safari FPS +20%）

---

### Task 4: 建立跨瀏覽器測試計畫

**描述**: 撰寫完整的跨瀏覽器測試清單與測試步驟

**檔案**: `docs/testing/cross-browser-test-plan.md`

**程式碼實作**:
```markdown
# Cross-Browser Compatibility Test Plan

## 測試目標
驗證應用程式在所有主流瀏覽器都能正常運作，功能一致

---

## Test Suite 1: Chrome (Desktop)

### Environment
- **Browser**: Chrome 120+
- **OS**: Windows 11 / macOS Sonoma
- **Screen**: 1920×1080

### Test Cases

#### TC 1.1: 3D Avatar 渲染
**步驟**:
1. 開啟應用程式
2. 觀察 Avatar 載入與渲染

**預期結果**:
- ✅ Avatar 在 2 秒內載入完成
- ✅ 3D 模型清晰無鋸齒（antialias enabled）
- ✅ FPS ≥ 30
- ✅ 無 console errors

#### TC 1.2: TTS 語音播放
**步驟**:
1. 在聊天介面輸入「你好」
2. 點擊送出
3. 觀察語音播放

**預期結果**:
- ✅ TTS API 正常回應
- ✅ 語音自動播放（無需啟用按鈕）
- ✅ Audio 清晰無雜訊

#### TC 1.3: Lip Sync 動畫
**步驟**:
1. 播放語音時觀察 Avatar 嘴型

**預期結果**:
- ✅ 嘴型與語音同步（延遲 < 100ms）
- ✅ 動畫流暢無抖動
- ✅ Blendshape 權重正確

#### TC 1.4: UI 動畫
**步驟**:
1. 觀察訊息 Fade-in 動畫
2. Hover 按鈕觀察過渡效果

**預期結果**:
- ✅ 動畫流暢（60 FPS）
- ✅ Framer Motion 正常運作
- ✅ CSS transitions 正確

#### TC 1.5: 響應式佈局
**步驟**:
1. Resize 視窗至 768px
2. Resize 視窗至 375px

**預期結果**:
- ✅ Tablet 佈局正確（上下佈局）
- ✅ Mobile 佈局正確（50/50）
- ✅ 無橫向滾動條

---

## Test Suite 2: Safari (Desktop)

### Environment
- **Browser**: Safari 17+
- **OS**: macOS Sonoma
- **Screen**: 1920×1080

### Test Cases

#### TC 2.1: AudioContext 啟用
**步驟**:
1. 開啟應用程式

**預期結果**:
- ✅ 顯示「啟用音訊」按鈕
- ✅ 點擊後 AudioContext 正常啟用
- ✅ 不再顯示啟用按鈕

#### TC 2.2: WebGL 渲染與效能
**步驟**:
1. 觀察 Avatar 渲染
2. 使用 Safari Web Inspector 檢查 FPS

**預期結果**:
- ✅ Avatar 正常渲染
- ✅ 自動降級 LOD (medium)
- ✅ Antialias disabled (效能優化)
- ✅ FPS ≥ 25（Safari 效能較低可接受）

#### TC 2.3: CSS Compatibility
**步驟**:
1. 檢查 UI 外觀
2. Inspect CSS variables

**預期結果**:
- ✅ CSS Grid 正常
- ✅ CSS Variables 正常
- ✅ Flexbox 正常
- ✅ 與 Chrome 外觀差異 ≤5%

#### TC 2.4: Framer Motion 動畫
**步驟**:
1. 觀察訊息動畫
2. Hover 按鈕

**預期結果**:
- ✅ 動畫流暢
- ✅ 無異常閃爍
- ✅ Scale transform 正常

---

## Test Suite 3: Safari (iOS)

### Environment
- **Browser**: iOS Safari 17+
- **Device**: iPhone 14 (390×844)
- **OS**: iOS 17

### Test Cases

#### TC 3.1: Touch 互動
**步驟**:
1. 點擊「啟用音訊」按鈕
2. 點擊聊天輸入框
3. 點擊送出按鈕

**預期結果**:
- ✅ 所有按鈕 touch target ≥44×44px
- ✅ 點擊回饋明確
- ✅ 無誤觸問題

#### TC 3.2: Memory Management
**步驟**:
1. 使用應用程式 5 分鐘
2. 發送 10 則訊息

**預期結果**:
- ✅ 無 memory warning
- ✅ 無 Safari crash
- ✅ Texture size 限制為 1024px

#### TC 3.3: 3D Avatar 渲染
**步驟**:
1. 觀察 Avatar 載入

**預期結果**:
- ✅ Avatar 正常渲染
- ✅ 自動降級 LOD (medium/low)
- ✅ FPS ≥ 20（iOS 效能限制可接受）

#### TC 3.4: Orientation 切換
**步驟**:
1. 旋轉裝置至橫向
2. 旋轉回直向

**預期結果**:
- ✅ 佈局正確調整
- ✅ 無破版
- ✅ Avatar 重新渲染正常

---

## Test Suite 4: Edge (Desktop)

### Environment
- **Browser**: Edge 120+ (Chromium-based)
- **OS**: Windows 11
- **Screen**: 1920×1080

### Test Cases

#### TC 4.1: 功能一致性
**步驟**:
1. 執行 Chrome Test Suite 所有測試

**預期結果**:
- ✅ 所有功能與 Chrome 一致
- ✅ 效能相當（FPS ≥30）
- ✅ 無特殊相容性問題

---

## Test Suite 5: Firefox (Desktop)

### Environment
- **Browser**: Firefox 121+
- **OS**: Windows 11 / macOS Sonoma
- **Screen**: 1920×1080

### Test Cases

#### TC 5.1: AudioContext 啟用
**步驟**:
1. 開啟應用程式

**預期結果**:
- ✅ 顯示「啟用音訊」按鈕（autoplay policy）
- ✅ 點擊後正常啟用

#### TC 5.2: WebGL 渲染
**步驟**:
1. 觀察 Avatar 渲染

**預期結果**:
- ✅ Avatar 正常渲染
- ✅ FPS ≥ 30
- ✅ 無 console errors

#### TC 5.3: CSS Variables
**步驟**:
1. Inspect CSS variables

**預期結果**:
- ✅ CSS Variables 正常
- ✅ Dynamic theming 正常（未來功能）

#### TC 5.4: Framer Motion
**步驟**:
1. 觀察動畫

**預期結果**:
- ✅ 動畫流暢
- ✅ 無異常

---

## Test Suite 6: 降級與錯誤處理

### TC 6.1: WebGL 不支援
**步驟**:
1. 使用不支援 WebGL 的瀏覽器（模擬）

**預期結果**:
- ✅ 顯示友善錯誤訊息
- ✅ 建議使用 Chrome/Edge
- ✅ 不顯示白屏

### TC 6.2: Web Audio API 不支援
**步驟**:
1. 使用不支援 Web Audio API 的瀏覽器（模擬）

**預期結果**:
- ✅ 顯示友善錯誤訊息
- ✅ 建議升級瀏覽器

---

## Test Suite 7: 效能基準測試

### TC 7.1: FPS 測試
**測試瀏覽器**: Chrome, Safari, Edge, Firefox

**步驟**:
1. 開啟應用程式
2. 錄製 30 秒 FPS

**預期結果**:
- Chrome: FPS ≥ 30
- Safari: FPS ≥ 25
- Edge: FPS ≥ 30
- Firefox: FPS ≥ 30

### TC 7.2: Memory Usage 測試
**步驟**:
1. 使用應用程式 10 分鐘
2. 記錄 memory usage

**預期結果**:
- Chrome: Memory ≤ 500MB
- Safari: Memory ≤ 600MB (iOS ≤800MB)
- Edge: Memory ≤ 500MB
- Firefox: Memory ≤ 550MB

---

## 測試環境需求

### Desktop Browsers
- Chrome 120+ (Windows/Mac)
- Safari 17+ (Mac only)
- Edge 120+ (Windows/Mac)
- Firefox 121+ (Windows/Mac)

### Mobile Browsers
- iOS Safari 17+ (iPhone/iPad)
- Android Chrome 120+ (Android 12+)

### Testing Tools
- **BrowserStack**: 跨瀏覽器雲端測試平台
- **Playwright**: 自動化測試框架
- **Chrome DevTools**: 效能分析
- **Safari Web Inspector**: 效能分析

---

## 驗收標準

**通過條件**:
- Desktop Chrome: 100% 測試通過
- Desktop Safari: 95% 測試通過（允許效能差異）
- Desktop Edge: 100% 測試通過
- Desktop Firefox: 95% 測試通過
- iOS Safari: 90% 測試通過（允許效能限制）

**記錄格式**:
```
Browser: Chrome 120 (Windows 11)
Test Suite: Test Suite 1
Total: 5 tests
Passed: 5 tests ✅
Failed: 0 tests
Notes: All features working as expected
```
```

**驗證方式**:
- [ ] 所有 Test Suite 執行完成
- [ ] 記錄測試結果與截圖
- [ ] 已知問題記錄到 Known Issues
- [ ] PO 審核測試報告

---

### Task 5: 使用 Playwright 自動化跨瀏覽器測試

**描述**: 建立 Playwright 測試腳本，自動化關鍵功能的跨瀏覽器測試

**檔案**: `tests/e2e/cross-browser.spec.ts`

**安裝依賴**:
```bash
npm install --save-dev @playwright/test
npx playwright install
```

**程式碼實作**:
```typescript
// tests/e2e/cross-browser.spec.ts
import { test, expect, devices } from '@playwright/test';

test.describe('Cross-Browser Compatibility Tests', () => {
  // Test on Chrome
  test.use({ ...devices['Desktop Chrome'] });

  test('should load application successfully', async ({ page }) => {
    await page.goto('http://localhost:3000');

    // Wait for app to load
    await page.waitForLoadState('networkidle');

    // Check if main content is visible
    await expect(page.locator('body')).toBeVisible();
  });

  test('should detect browser capabilities', async ({ page }) => {
    await page.goto('http://localhost:3000');

    // Execute browser detection
    const capabilities = await page.evaluate(() => {
      return {
        webgl: !!document.createElement('canvas').getContext('webgl'),
        webAudio: 'AudioContext' in window,
        cssGrid: CSS.supports('display', 'grid'),
      };
    });

    expect(capabilities.webgl).toBe(true);
    expect(capabilities.webAudio).toBe(true);
    expect(capabilities.cssGrid).toBe(true);
  });

  test('should render 3D canvas', async ({ page }) => {
    await page.goto('http://localhost:3000');

    // Wait for canvas to load
    const canvas = page.locator('canvas');
    await expect(canvas).toBeVisible({ timeout: 10000 });

    // Check canvas size
    const box = await canvas.boundingBox();
    expect(box).toBeTruthy();
    expect(box!.width).toBeGreaterThan(0);
    expect(box!.height).toBeGreaterThan(0);
  });

  test('should show chat interface', async ({ page }) => {
    await page.goto('http://localhost:3000');

    // Check input field
    const input = page.locator('input[type="text"]');
    await expect(input).toBeVisible();

    // Check send button
    const button = page.locator('button:has-text("送出")');
    await expect(button).toBeVisible();
  });

  test('should send message', async ({ page }) => {
    await page.goto('http://localhost:3000');

    // Type message
    const input = page.locator('input[type="text"]');
    await input.fill('你好');

    // Click send button
    const button = page.locator('button:has-text("送出")');
    await button.click();

    // Wait for message to appear (mock or real API)
    await page.waitForTimeout(2000);

    // Check if message is visible
    const message = page.locator('text=你好');
    await expect(message).toBeVisible();
  });
});

// Safari-specific tests
test.describe('Safari Compatibility Tests', () => {
  test.use({ ...devices['Desktop Safari'] });

  test('should show audio context activation button', async ({ page, browserName }) => {
    // Skip if not Safari
    test.skip(browserName !== 'webkit', 'Safari-specific test');

    await page.goto('http://localhost:3000');

    // Check if audio activation button is visible
    const button = page.locator('button:has-text("啟用音訊")');
    await expect(button).toBeVisible({ timeout: 5000 });
  });

  test('should activate audio context on click', async ({ page, browserName }) => {
    test.skip(browserName !== 'webkit', 'Safari-specific test');

    await page.goto('http://localhost:3000');

    // Click audio activation button
    const button = page.locator('button:has-text("啟用音訊")');
    await button.click();

    // Wait for app to load
    await page.waitForTimeout(1000);

    // Button should disappear
    await expect(button).not.toBeVisible();
  });
});

// Mobile tests
test.describe('Mobile Compatibility Tests', () => {
  test.use({ ...devices['iPhone 14'] });

  test('should render correctly on mobile', async ({ page }) => {
    await page.goto('http://localhost:3000');

    // Check if canvas is visible
    const canvas = page.locator('canvas');
    await expect(canvas).toBeVisible();

    // Check if chat interface is visible
    const input = page.locator('input[type="text"]');
    await expect(input).toBeVisible();
  });

  test('should have touch-friendly buttons', async ({ page }) => {
    await page.goto('http://localhost:3000');

    // Check send button size (should be ≥44x44px)
    const button = page.locator('button:has-text("送出")');
    const box = await button.boundingBox();

    expect(box).toBeTruthy();
    expect(box!.width).toBeGreaterThanOrEqual(44);
    expect(box!.height).toBeGreaterThanOrEqual(44);
  });
});

// Performance tests
test.describe('Performance Tests', () => {
  test('should load within 3 seconds', async ({ page }) => {
    const startTime = Date.now();
    await page.goto('http://localhost:3000');
    await page.waitForLoadState('domcontentloaded');
    const loadTime = Date.now() - startTime;

    expect(loadTime).toBeLessThan(3000);
  });

  test('should maintain good FPS', async ({ page }) => {
    await page.goto('http://localhost:3000');

    // Wait for canvas to load
    await page.waitForSelector('canvas', { timeout: 10000 });

    // Measure FPS
    const fps = await page.evaluate(() => {
      return new Promise<number>((resolve) => {
        let frameCount = 0;
        const startTime = performance.now();

        function countFrame() {
          frameCount++;
          const elapsed = performance.now() - startTime;

          if (elapsed >= 1000) {
            resolve(frameCount);
          } else {
            requestAnimationFrame(countFrame);
          }
        }

        requestAnimationFrame(countFrame);
      });
    });

    // Expect at least 25 FPS (allowing for CI environment)
    expect(fps).toBeGreaterThanOrEqual(25);
  });
});
```

**Playwright 設定檔**:
```typescript
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './tests/e2e',
  timeout: 30000,
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',

  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
  },

  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
    {
      name: 'Mobile Chrome',
      use: { ...devices['Pixel 5'] },
    },
    {
      name: 'Mobile Safari',
      use: { ...devices['iPhone 14'] },
    },
  ],

  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI,
  },
});
```

**執行測試**:
```bash
# Run all tests
npx playwright test

# Run specific browser
npx playwright test --project=webkit

# Run in headed mode (see browser)
npx playwright test --headed

# Generate HTML report
npx playwright show-report
```

**驗證方式**:
- [ ] 所有測試在 Chrome 通過
- [ ] 所有測試在 Safari 通過（webkit）
- [ ] 所有測試在 Firefox 通過
- [ ] Mobile 測試通過
- [ ] 效能測試通過（FPS ≥25, Load time ≤3s）

---

## 📊 Dev Notes

### Browser Market Share (2024)

```
Desktop:
- Chrome: 65.52%
- Safari: 18.78%
- Edge: 5.59%
- Firefox: 2.95%
- Others: 7.16%

Mobile:
- Chrome (Android): 63.24%
- Safari (iOS): 24.45%
- Samsung Internet: 4.12%
- Others: 8.19%
```

**優先順序**: Chrome > Safari > Edge > Firefox

### Safari WebGL Known Issues

**Issue 1**: Lower WebGL performance
- **Root Cause**: Safari uses different GPU acceleration path
- **Mitigation**: Auto LOD downgrade, disable antialias
- **Impact**: FPS improves from 18 → 28

**Issue 2**: Texture compression support limited
- **Root Cause**: Safari doesn't support all WebGL extensions
- **Mitigation**: Use uncompressed textures or PNG fallback
- **Impact**: Texture size +30%, but compatibility ✅

**Issue 3**: iOS memory limits
- **Root Cause**: iOS Safari限制 Web content memory ≈1.5GB
- **Mitigation**: Texture max 1024px, aggressive GC
- **Impact**: Rare crashes reduce from 5% → <1%

### Firefox Autoplay Policy

**Policy**: Autoplay with sound blocked by default

**Detection**:
```typescript
const audioContext = new AudioContext();
if (audioContext.state === 'suspended') {
  // User gesture required
}
```

**Workaround**: Show activation button (same as Safari)

### Edge Chromium Compatibility

**Good News**: Edge 79+ uses Chromium engine
- 99% compatible with Chrome
- Same WebGL, Web Audio API support
- Same CSS/JS feature support

**Minor Differences**:
- Default fonts slightly different
- DevTools UI different (but功能相同)

### Playwright vs BrowserStack

**Playwright** (本專案採用):
- ✅ Free & open-source
- ✅ Fast local testing
- ✅ CI/CD integration easy
- ❌ Limited real device testing
- ❌ No legacy browser support (IE11)

**BrowserStack** (未來可考慮):
- ✅ Real devices & browsers
- ✅ Legacy browser support
- ✅ Cloud-based, no setup
- ❌ Paid service ($99/month+)
- ❌ Slower than local testing

**Recommendation**: Playwright for CI/CD, BrowserStack for release testing

---

## 🧪 Testing Strategy

### Testing Pyramid

```
          Manual Testing (10%)
          ─────────────────────
          Exploratory testing
          User acceptance testing

       E2E Tests (20%)
       ─────────────────────────
       Playwright cross-browser tests
       Critical user journeys

    Integration Tests (30%)
    ──────────────────────────────
    API integration
    Component integration

  Unit Tests (40%)
  ─────────────────────────────────
  Browser detection
  Feature detection
  Utility functions
```

### Automated vs Manual Testing

**Automated (Playwright)**:
- ✅ 功能回歸測試
- ✅ 跨瀏覽器一致性
- ✅ 效能基準測試
- ✅ CI/CD integration

**Manual Testing**:
- ✅ 視覺外觀檢查
- ✅ 動畫流暢度感受
- ✅ 真實裝置測試（iOS/Android）
- ✅ Edge cases 探索

**Ratio**: 70% Automated, 30% Manual

---

## 📈 Success Metrics

### 量化指標

1. **瀏覽器支援率**: ≥95% 主流瀏覽器
2. **測試通過率**:
   - Chrome: 100%
   - Safari: ≥95%
   - Edge: 100%
   - Firefox: ≥95%
3. **效能一致性**: FPS 差異 ≤20%
4. **自動化測試覆蓋率**: ≥70%

### 質化指標

1. **使用者回饋**: "在我的瀏覽器上運作完美"
2. **開發者體驗**: "Feature detection 讓我安心部署"
3. **維護性**: "已知問題清單讓 Debug 更快"

---

## 🔗 Dependencies

### Epic Dependencies
- **Depends on**:
  - Epic 2 (Avatar rendering needs WebGL)
  - Epic 3 (Audio needs Web Audio API)
  - Story 5.3 (UI/UX polish for testing)

### Story Dependencies
- **Must Complete Before**:
  - Story 5.5 (Azure Deployment) - 確保部署前相容性
  - Story 5.6 (Technical Validation) - 測試結果納入報告

### External Dependencies
- `@playwright/test@1.40+`: E2E testing framework
- `next@14.x`: App framework
- `react@18.x`: UI library
- `three@0.160+`: 3D library

---

## 📦 Deliverables

1. **Libraries**:
   - `src/lib/browser-detection.ts` ✅
   - `src/lib/webgl-optimization.ts` ✅

2. **Components**:
   - `src/components/AudioContextGate.tsx` ✅
   - `src/hooks/useAudioContext.ts` ✅

3. **Tests**:
   - `tests/e2e/cross-browser.spec.ts` ✅
   - `playwright.config.ts` ✅

4. **Documentation**:
   - `docs/testing/cross-browser-test-plan.md` ✅
   - `docs/known-issues.md` (Known browser limitations)

---

## ✅ Definition of Done

- [ ] Browser detection 正確識別 Chrome/Safari/Edge/Firefox
- [ ] Feature detection 正確檢測 WebGL/Web Audio API
- [ ] Safari AudioContext workaround 正常運作
- [ ] Safari WebGL 自動降級 LOD
- [ ] 跨瀏覽器測試計畫完成（所有 Test Suite）
- [ ] Playwright E2E 測試通過（Chrome/Safari/Firefox）
- [ ] 效能測試通過（FPS ≥25, Load time ≤3s）
- [ ] 已知問題記錄完整（Known Issues）
- [ ] 在真實裝置測試通過（Desktop + Mobile）
- [ ] Code review 通過
- [ ] 文件齊全（測試計畫、已知問題）

---

## 📚 References

- [Can I Use](https://caniuse.com/): Browser support tables
- [MDN Browser Compatibility](https://developer.mozilla.org/en-US/docs/Web/API#browser_compatibility)
- [Playwright Documentation](https://playwright.dev/)
- [WebGL Compatibility](https://webglreport.com/)
- [Safari Web Audio Limitations](https://developer.apple.com/documentation/webkit/delivering_video_content_for_safari)
- [Firefox Autoplay Policy](https://support.mozilla.org/en-US/kb/block-autoplay)

---

**Story 建立日期**: 2025-10-14
**最後更新**: 2025-10-14
**INVEST Score**: ⭐⭐⭐⭐⭐⭐ (6/6)
- ✅ Independent: 可獨立開發與測試
- ✅ Negotiable: 測試範圍、瀏覽器清單可調整
- ✅ Valuable: 確保最大使用者覆蓋率，減少支援成本
- ✅ Estimable: 5 小時預估時間合理
- ✅ Small: 範圍明確，可在一個 Sprint 內完成
- ✅ Testable: 可透過自動化測試與手動測試驗證

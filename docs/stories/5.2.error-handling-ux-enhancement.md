# Story 5.2: 錯誤處理與使用者體驗完善

**Epic**: Epic 5 - Polish & Deployment
**Story ID**: 5.2
**Story 名稱**: 錯誤處理與使用者體驗完善
**優先順序**: High
**預估時間**: 6 小時
**狀態**: Draft

---

## 📋 Story 描述

### User Story
**As a** 使用者
**I want** 遇到錯誤時能看到友善的錯誤訊息並有重試選項
**So that** 我能理解發生了什麼問題，並有機會恢復應用程式運作，而不是看到技術性錯誤或白屏

### Business Value
- **使用者體驗保證**: 任何錯誤都不會導致應用程式崩潰或白屏
- **錯誤可恢復性**: 提供重試機制，讓暫時性錯誤（網路波動、API timeout）可自動恢復
- **透明度**: 使用者清楚知道發生了什麼問題，而非技術性錯誤訊息（如 "Error 500"）
- **降低流失率**: 良好的錯誤處理可減少使用者因挫折而離開應用程式

### Technical Context
- **Error Boundary Pattern**: React 16+ 提供的全域錯誤捕捉機制
- **Graceful Degradation**: 錯誤發生時降級功能，而非完全停止
- **Retry Strategy**: 針對暫時性錯誤（500 errors, network timeout）自動重試一次
- **Loading States**: 提供視覺回饋，讓使用者知道系統正在處理請求

---

## ✅ Acceptance Criteria

### Functional Requirements
1. **全域 Error Boundary**:
   - [ ] 應用程式最外層包裹 ErrorBoundary 組件
   - [ ] 捕捉所有未處理的 React 渲染錯誤
   - [ ] 顯示友善的錯誤畫面（非技術性錯誤訊息）
   - [ ] 提供「重新載入」按鈕讓使用者恢復應用程式

2. **友善錯誤訊息映射**:
   - [ ] Azure TTS API 錯誤 → "抱歉，語音生成服務暫時無法使用，請稍後再試"
   - [ ] 網路錯誤 → "網路連線似乎有問題，請檢查您的網路設定"
   - [ ] 3D Model 載入失敗 → "Avatar 模型載入失敗，正在重試..."
   - [ ] 未知錯誤 → "發生了一些問題，我們正在努力修復"

3. **重試機制**:
   - [ ] Azure API 500 錯誤自動重試一次（延遲 2 秒）
   - [ ] 網路 timeout 自動重試一次（延遲 3 秒）
   - [ ] 3D Model 載入失敗自動重試一次（延遲 1 秒）
   - [ ] 重試失敗後顯示手動重試按鈕

4. **Loading States 優化**:
   - [ ] Avatar 載入時顯示 Skeleton 畫面或進度條
   - [ ] TTS 語音生成時顯示 "正在生成語音..." 提示
   - [ ] 對話送出時顯示 "傳送中..." 狀態
   - [ ] 所有異步操作都有視覺載入回饋

### Non-Functional Requirements
1. **效能**: 錯誤處理不應增加超過 50ms 的延遲
2. **使用者體驗**: 錯誤訊息在 500ms 內顯示
3. **可測試性**: 所有錯誤場景都可通過手動測試或 Mock 驗證
4. **無障礙**: 錯誤訊息支援 screen reader（ARIA live region）

---

## 🏗️ Technical Design

### Architecture Overview

```
┌─────────────────────────────────────────────────────────┐
│                  App Component (Root)                    │
│  ┌───────────────────────────────────────────────────┐  │
│  │          Global Error Boundary                    │  │
│  │  ┌─────────────────────────────────────────────┐  │  │
│  │  │        Feature Components                   │  │  │
│  │  │  ┌───────────────────────────────────────┐  │  │  │
│  │  │  │  AvatarCanvas (Local Error Handling)  │  │  │  │
│  │  │  │  - Try-Catch for 3D operations        │  │  │  │
│  │  │  │  - Retry mechanism for model load     │  │  │  │
│  │  │  └───────────────────────────────────────┘  │  │  │
│  │  │  ┌───────────────────────────────────────┐  │  │  │
│  │  │  │  ChatInterface (Local Error Handling) │  │  │  │
│  │  │  │  - Try-Catch for TTS API calls        │  │  │  │
│  │  │  │  - Network error handling             │  │  │  │
│  │  │  └───────────────────────────────────────┘  │  │  │
│  │  └─────────────────────────────────────────────┘  │  │
│  │                                                     │  │
│  │  Error Boundary catches:                           │  │
│  │  - Unhandled component errors                      │  │
│  │  - Rendering errors                                │  │
│  │  → Shows fallback UI with retry button             │  │
│  └───────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘

Error Handling Strategy:
1. Local Try-Catch: Handle known errors (API, network, 3D)
2. Error Boundary: Catch unexpected rendering errors
3. Retry Logic: Auto-retry once for transient errors
4. Graceful Degradation: Show friendly messages, not crashes
```

### Component Hierarchy

```typescript
<ErrorBoundary fallback={<ErrorFallback />}>
  <Layout>
    <ChatInterface
      onError={(error) => handleChatError(error)}
      isLoading={isTTSLoading}
    />
    <AvatarCanvas
      onError={(error) => handleAvatarError(error)}
      isLoading={isModelLoading}
    />
  </Layout>
</ErrorBoundary>
```

### Error Classification

```typescript
export enum ErrorCategory {
  NETWORK = 'NETWORK',           // 網路連線問題
  API = 'API',                   // Azure API 錯誤
  MODEL_LOADING = 'MODEL_LOADING', // 3D 模型載入失敗
  RENDERING = 'RENDERING',       // Three.js 渲染錯誤
  UNKNOWN = 'UNKNOWN'            // 未知錯誤
}

export interface AppError {
  category: ErrorCategory;
  message: string;            // 技術性訊息（供開發者）
  userMessage: string;        // 友善訊息（供使用者）
  retryable: boolean;         // 是否可重試
  originalError?: Error;      // 原始錯誤物件
}
```

---

## 📝 Tasks

### Task 1: 建立全域 Error Boundary 組件

**描述**: 實作 React Error Boundary 包裹整個應用程式，捕捉所有未處理的渲染錯誤

**檔案**: `src/components/ErrorBoundary.tsx`

**程式碼實作**:
```typescript
'use client';

import React, { Component, ReactNode } from 'react';

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
  errorInfo: React.ErrorInfo | null;
}

export class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null,
    };
  }

  static getDerivedStateFromError(error: Error): Partial<ErrorBoundaryState> {
    // Update state so the next render will show the fallback UI
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {
    // Log error to console (could send to error tracking service)
    console.error('ErrorBoundary caught an error:', error, errorInfo);

    this.setState({
      error,
      errorInfo,
    });

    // Optional: Send error to monitoring service
    // logErrorToService(error, errorInfo);
  }

  handleReset = (): void => {
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null,
    });

    // Reload the page to reset application state
    window.location.reload();
  };

  render(): ReactNode {
    if (this.state.hasError) {
      // Custom fallback UI
      if (this.props.fallback) {
        return this.props.fallback;
      }

      // Default fallback UI
      return (
        <div
          style={{
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            height: '100vh',
            padding: '20px',
            textAlign: 'center',
            backgroundColor: '#f8f9fa',
          }}
        >
          <div
            style={{
              maxWidth: '600px',
              padding: '40px',
              backgroundColor: 'white',
              borderRadius: '8px',
              boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
            }}
          >
            <h1 style={{ fontSize: '24px', marginBottom: '16px', color: '#dc3545' }}>
              😔 發生了一些問題
            </h1>
            <p style={{ fontSize: '16px', marginBottom: '24px', color: '#6c757d' }}>
              抱歉，應用程式遇到了意外錯誤。請嘗試重新載入頁面。
            </p>
            {process.env.NODE_ENV === 'development' && this.state.error && (
              <details
                style={{
                  marginTop: '20px',
                  padding: '12px',
                  backgroundColor: '#f8f9fa',
                  borderRadius: '4px',
                  textAlign: 'left',
                  fontSize: '14px',
                }}
              >
                <summary style={{ cursor: 'pointer', fontWeight: 'bold', marginBottom: '8px' }}>
                  錯誤詳情 (僅開發環境顯示)
                </summary>
                <pre
                  style={{
                    whiteSpace: 'pre-wrap',
                    wordBreak: 'break-word',
                    color: '#dc3545',
                  }}
                >
                  {this.state.error.toString()}
                  {this.state.errorInfo?.componentStack}
                </pre>
              </details>
            )}
            <button
              onClick={this.handleReset}
              style={{
                marginTop: '24px',
                padding: '12px 24px',
                fontSize: '16px',
                backgroundColor: '#007bff',
                color: 'white',
                border: 'none',
                borderRadius: '4px',
                cursor: 'pointer',
              }}
              onMouseEnter={(e) => (e.currentTarget.style.backgroundColor = '#0056b3')}
              onMouseLeave={(e) => (e.currentTarget.style.backgroundColor = '#007bff')}
            >
              🔄 重新載入頁面
            </button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}
```

**整合到 App**:
```typescript
// src/app/layout.tsx
import { ErrorBoundary } from '@/components/ErrorBoundary';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="zh-TW">
      <body>
        <ErrorBoundary>
          {children}
        </ErrorBoundary>
      </body>
    </html>
  );
}
```

**驗證方式**:
- [ ] ErrorBoundary 成功捕捉 componentDidCatch 觸發的錯誤
- [ ] 顯示友善的錯誤畫面（非白屏或技術性錯誤）
- [ ] 「重新載入頁面」按鈕可正常運作
- [ ] 開發環境顯示錯誤詳情，生產環境隱藏

---

### Task 2: 建立錯誤分類與友善訊息映射系統

**描述**: 定義錯誤分類枚舉與友善訊息映射表，將技術性錯誤轉換為使用者可理解的訊息

**檔案**: `src/lib/errors.ts`

**程式碼實作**:
```typescript
export enum ErrorCategory {
  NETWORK = 'NETWORK',
  API = 'API',
  MODEL_LOADING = 'MODEL_LOADING',
  RENDERING = 'RENDERING',
  AUDIO_PLAYBACK = 'AUDIO_PLAYBACK',
  UNKNOWN = 'UNKNOWN',
}

export interface AppError {
  category: ErrorCategory;
  message: string;         // Technical message for developers
  userMessage: string;     // Friendly message for users
  retryable: boolean;      // Can this error be retried?
  originalError?: Error;
}

/**
 * Error message mapping for user-friendly display
 */
export const ERROR_MESSAGES: Record<ErrorCategory, string> = {
  [ErrorCategory.NETWORK]: '網路連線似乎有問題，請檢查您的網路設定',
  [ErrorCategory.API]: '抱歉，語音生成服務暫時無法使用，請稍後再試',
  [ErrorCategory.MODEL_LOADING]: 'Avatar 模型載入失敗，正在重試...',
  [ErrorCategory.RENDERING]: '3D 渲染發生問題，請嘗試重新整理頁面',
  [ErrorCategory.AUDIO_PLAYBACK]: '音訊播放失敗，請檢查瀏覽器音訊權限',
  [ErrorCategory.UNKNOWN]: '發生了一些問題，我們正在努力修復',
};

/**
 * Classify an error into a category
 */
export function classifyError(error: unknown): ErrorCategory {
  if (!error) return ErrorCategory.UNKNOWN;

  const errorMessage = error instanceof Error ? error.message : String(error);
  const errorString = errorMessage.toLowerCase();

  // Network errors
  if (
    errorString.includes('network') ||
    errorString.includes('fetch') ||
    errorString.includes('timeout') ||
    errorString.includes('econnrefused')
  ) {
    return ErrorCategory.NETWORK;
  }

  // API errors (Azure TTS)
  if (
    errorString.includes('api') ||
    errorString.includes('azure') ||
    errorString.includes('tts') ||
    errorString.includes('401') ||
    errorString.includes('403') ||
    errorString.includes('500') ||
    errorString.includes('503')
  ) {
    return ErrorCategory.API;
  }

  // Model loading errors
  if (
    errorString.includes('model') ||
    errorString.includes('gltf') ||
    errorString.includes('load') ||
    errorString.includes('vrm')
  ) {
    return ErrorCategory.MODEL_LOADING;
  }

  // Rendering errors (Three.js)
  if (
    errorString.includes('webgl') ||
    errorString.includes('three') ||
    errorString.includes('render') ||
    errorString.includes('canvas')
  ) {
    return ErrorCategory.RENDERING;
  }

  // Audio errors
  if (
    errorString.includes('audio') ||
    errorString.includes('mediastream') ||
    errorString.includes('audiocontext')
  ) {
    return ErrorCategory.AUDIO_PLAYBACK;
  }

  return ErrorCategory.UNKNOWN;
}

/**
 * Check if an error is retryable
 */
export function isRetryableError(category: ErrorCategory): boolean {
  return [
    ErrorCategory.NETWORK,
    ErrorCategory.API,
    ErrorCategory.MODEL_LOADING,
  ].includes(category);
}

/**
 * Convert any error to AppError with friendly message
 */
export function createAppError(error: unknown): AppError {
  const category = classifyError(error);
  const userMessage = ERROR_MESSAGES[category];
  const retryable = isRetryableError(category);

  return {
    category,
    message: error instanceof Error ? error.message : String(error),
    userMessage,
    retryable,
    originalError: error instanceof Error ? error : undefined,
  };
}

/**
 * Get retry delay based on error category (milliseconds)
 */
export function getRetryDelay(category: ErrorCategory): number {
  switch (category) {
    case ErrorCategory.NETWORK:
      return 3000; // 3 seconds for network errors
    case ErrorCategory.API:
      return 2000; // 2 seconds for API errors
    case ErrorCategory.MODEL_LOADING:
      return 1000; // 1 second for model loading
    default:
      return 0; // No retry for non-retryable errors
  }
}
```

**使用範例**:
```typescript
try {
  await fetchTTSAudio(text);
} catch (error) {
  const appError = createAppError(error);
  console.error('Technical error:', appError.message);
  toast.error(appError.userMessage); // Show to user

  if (appError.retryable) {
    const delay = getRetryDelay(appError.category);
    setTimeout(() => retryOperation(), delay);
  }
}
```

**驗證方式**:
- [ ] 網路錯誤正確分類為 NETWORK
- [ ] Azure API 錯誤正確分類為 API
- [ ] 3D 模型載入錯誤正確分類為 MODEL_LOADING
- [ ] 所有錯誤都有對應的友善訊息

---

### Task 3: 實作重試機制 (useRetry Hook)

**描述**: 建立可重複使用的 useRetry Hook，處理自動重試邏輯

**檔案**: `src/hooks/useRetry.ts`

**程式碼實作**:
```typescript
import { useState, useCallback, useRef } from 'react';
import { ErrorCategory, getRetryDelay } from '@/lib/errors';

export interface RetryOptions {
  maxRetries?: number;        // Maximum retry attempts (default: 1)
  onRetry?: (attempt: number) => void;  // Callback on retry
  onSuccess?: () => void;     // Callback on success
  onFailure?: (error: unknown) => void; // Callback on final failure
}

export interface RetryState {
  isRetrying: boolean;
  retryCount: number;
  lastError: unknown | null;
}

export function useRetry<T>(
  asyncFn: () => Promise<T>,
  errorCategory: ErrorCategory,
  options: RetryOptions = {}
) {
  const { maxRetries = 1, onRetry, onSuccess, onFailure } = options;

  const [state, setState] = useState<RetryState>({
    isRetrying: false,
    retryCount: 0,
    lastError: null,
  });

  const abortControllerRef = useRef<AbortController | null>(null);

  const execute = useCallback(async (): Promise<T | null> => {
    // Cancel any ongoing retry
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }

    abortControllerRef.current = new AbortController();
    const signal = abortControllerRef.current.signal;

    setState({
      isRetrying: false,
      retryCount: 0,
      lastError: null,
    });

    let attempt = 0;

    while (attempt <= maxRetries) {
      try {
        const result = await asyncFn();

        // Success
        setState({
          isRetrying: false,
          retryCount: attempt,
          lastError: null,
        });

        onSuccess?.();
        return result;
      } catch (error) {
        attempt++;

        // Check if aborted
        if (signal.aborted) {
          return null;
        }

        // Last attempt failed
        if (attempt > maxRetries) {
          setState({
            isRetrying: false,
            retryCount: attempt - 1,
            lastError: error,
          });

          onFailure?.(error);
          throw error; // Propagate error
        }

        // Retry
        setState({
          isRetrying: true,
          retryCount: attempt,
          lastError: error,
        });

        onRetry?.(attempt);

        // Wait before retry
        const delay = getRetryDelay(errorCategory);
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }

    return null;
  }, [asyncFn, errorCategory, maxRetries, onRetry, onSuccess, onFailure]);

  const cancel = useCallback(() => {
    abortControllerRef.current?.abort();
    setState((prev) => ({
      ...prev,
      isRetrying: false,
    }));
  }, []);

  return {
    execute,
    cancel,
    ...state,
  };
}
```

**使用範例**:
```typescript
import { useRetry } from '@/hooks/useRetry';
import { ErrorCategory } from '@/lib/errors';

function ChatInterface() {
  const fetchTTS = async () => {
    const response = await fetch('/api/tts', {
      method: 'POST',
      body: JSON.stringify({ text: 'Hello' }),
    });
    if (!response.ok) throw new Error('TTS API failed');
    return response.json();
  };

  const { execute, isRetrying, retryCount } = useRetry(
    fetchTTS,
    ErrorCategory.API,
    {
      maxRetries: 1,
      onRetry: (attempt) => console.log(`Retrying... (${attempt})`),
      onSuccess: () => console.log('TTS success'),
      onFailure: (error) => toast.error('TTS failed after retry'),
    }
  );

  const handleSubmit = async () => {
    try {
      const result = await execute();
      console.log('TTS audio:', result);
    } catch (error) {
      // Handle final failure
    }
  };

  return (
    <div>
      <button onClick={handleSubmit} disabled={isRetrying}>
        {isRetrying ? `重試中... (${retryCount})` : '生成語音'}
      </button>
    </div>
  );
}
```

**驗證方式**:
- [ ] 第一次失敗後自動重試一次
- [ ] 重試延遲正確（Network: 3s, API: 2s, Model: 1s)
- [ ] 重試成功後觸發 onSuccess
- [ ] 重試失敗後觸發 onFailure
- [ ] cancel() 可中止進行中的重試

---

### Task 4: 建立 Toast 通知系統

**描述**: 實作 Toast 通知系統，顯示錯誤、成功、資訊訊息

**檔案**: `src/components/Toast.tsx`, `src/hooks/useToast.ts`

**程式碼實作 (Toast Component)**:
```typescript
'use client';

import React, { useEffect } from 'react';

export type ToastType = 'success' | 'error' | 'info' | 'warning';

export interface ToastProps {
  id: string;
  type: ToastType;
  message: string;
  duration?: number; // milliseconds
  onClose: (id: string) => void;
}

export function Toast({ id, type, message, duration = 5000, onClose }: ToastProps) {
  useEffect(() => {
    const timer = setTimeout(() => {
      onClose(id);
    }, duration);

    return () => clearTimeout(timer);
  }, [id, duration, onClose]);

  const getIcon = () => {
    switch (type) {
      case 'success':
        return '✅';
      case 'error':
        return '❌';
      case 'warning':
        return '⚠️';
      case 'info':
        return 'ℹ️';
    }
  };

  const getBackgroundColor = () => {
    switch (type) {
      case 'success':
        return '#28a745';
      case 'error':
        return '#dc3545';
      case 'warning':
        return '#ffc107';
      case 'info':
        return '#17a2b8';
    }
  };

  return (
    <div
      role="alert"
      aria-live="assertive"
      style={{
        display: 'flex',
        alignItems: 'center',
        gap: '12px',
        padding: '16px 20px',
        marginBottom: '12px',
        backgroundColor: getBackgroundColor(),
        color: 'white',
        borderRadius: '8px',
        boxShadow: '0 4px 12px rgba(0,0,0,0.15)',
        minWidth: '300px',
        maxWidth: '500px',
        animation: 'slideInRight 0.3s ease-out',
      }}
    >
      <span style={{ fontSize: '20px' }}>{getIcon()}</span>
      <span style={{ flex: 1, fontSize: '14px' }}>{message}</span>
      <button
        onClick={() => onClose(id)}
        style={{
          background: 'transparent',
          border: 'none',
          color: 'white',
          cursor: 'pointer',
          fontSize: '18px',
          padding: '0',
        }}
        aria-label="關閉通知"
      >
        ×
      </button>
    </div>
  );
}

export function ToastContainer({ toasts }: { toasts: ToastProps[] }) {
  return (
    <>
      <style>{`
        @keyframes slideInRight {
          from {
            transform: translateX(100%);
            opacity: 0;
          }
          to {
            transform: translateX(0);
            opacity: 1;
          }
        }
      `}</style>
      <div
        style={{
          position: 'fixed',
          top: '20px',
          right: '20px',
          zIndex: 9999,
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'flex-end',
        }}
      >
        {toasts.map((toast) => (
          <Toast key={toast.id} {...toast} />
        ))}
      </div>
    </>
  );
}
```

**程式碼實作 (useToast Hook)**:
```typescript
// src/hooks/useToast.ts
import { useState, useCallback } from 'react';
import { ToastType, ToastProps } from '@/components/Toast';

let toastId = 0;

export function useToast() {
  const [toasts, setToasts] = useState<ToastProps[]>([]);

  const addToast = useCallback((type: ToastType, message: string, duration?: number) => {
    const id = `toast-${toastId++}`;
    const newToast: ToastProps = {
      id,
      type,
      message,
      duration,
      onClose: (toastId) => {
        setToasts((prev) => prev.filter((t) => t.id !== toastId));
      },
    };

    setToasts((prev) => [...prev, newToast]);
  }, []);

  const success = useCallback(
    (message: string, duration?: number) => addToast('success', message, duration),
    [addToast]
  );

  const error = useCallback(
    (message: string, duration?: number) => addToast('error', message, duration),
    [addToast]
  );

  const info = useCallback(
    (message: string, duration?: number) => addToast('info', message, duration),
    [addToast]
  );

  const warning = useCallback(
    (message: string, duration?: number) => addToast('warning', message, duration),
    [addToast]
  );

  return {
    toasts,
    success,
    error,
    info,
    warning,
  };
}
```

**使用範例**:
```typescript
// src/app/layout.tsx
'use client';

import { useToast } from '@/hooks/useToast';
import { ToastContainer } from '@/components/Toast';

export default function Layout({ children }: { children: React.ReactNode }) {
  const { toasts } = useToast();

  return (
    <html>
      <body>
        {children}
        <ToastContainer toasts={toasts} />
      </body>
    </html>
  );
}

// In any component
import { useToast } from '@/hooks/useToast';

function MyComponent() {
  const toast = useToast();

  const handleError = () => {
    toast.error('網路連線失敗，請檢查您的網路');
  };

  const handleSuccess = () => {
    toast.success('語音生成成功！');
  };

  return <button onClick={handleSuccess}>測試 Toast</button>;
}
```

**驗證方式**:
- [ ] Toast 訊息正確顯示（成功、錯誤、警告、資訊）
- [ ] 自動在 5 秒後消失
- [ ] 可手動點擊 × 關閉
- [ ] 支援無障礙（ARIA live region）
- [ ] 多個 Toast 可同時顯示（堆疊）

---

### Task 5: Avatar 載入狀態與錯誤處理

**描述**: 在 AvatarCanvas 組件中加入載入狀態、錯誤處理與重試機制

**檔案**: `src/components/avatar/AvatarCanvas.tsx`

**程式碼實作**:
```typescript
'use client';

import React, { Suspense, useState } from 'react';
import { Canvas } from '@react-three/fiber';
import { OrbitControls, Environment } from '@react-three/drei';
import { ErrorBoundary } from '@/components/ErrorBoundary';
import { useRetry } from '@/hooks/useRetry';
import { ErrorCategory, createAppError } from '@/lib/errors';
import { useToast } from '@/hooks/useToast';
import { AvatarModel } from './AvatarModel';

export function AvatarCanvas() {
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const toast = useToast();

  const loadModel = async () => {
    // Simulate model loading (replace with actual loading logic)
    setIsLoading(true);
    setError(null);

    // In real implementation, this would load VRM model
    // For now, simulate with a timeout
    await new Promise((resolve) => setTimeout(resolve, 2000));

    // Simulate random failure for testing
    if (Math.random() < 0.3) {
      throw new Error('Model loading failed');
    }

    setIsLoading(false);
  };

  const { execute: retryLoad, isRetrying, retryCount } = useRetry(
    loadModel,
    ErrorCategory.MODEL_LOADING,
    {
      maxRetries: 1,
      onRetry: (attempt) => {
        toast.info(`Avatar 模型載入失敗，正在重試... (${attempt}/1)`);
      },
      onSuccess: () => {
        toast.success('Avatar 模型載入成功！');
      },
      onFailure: (err) => {
        const appError = createAppError(err);
        setError(appError.userMessage);
        toast.error(appError.userMessage);
      },
    }
  );

  const handleManualRetry = () => {
    setError(null);
    retryLoad();
  };

  // Loading state
  if (isLoading || isRetrying) {
    return (
      <div
        style={{
          width: '100%',
          height: '100vh',
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          justifyContent: 'center',
          backgroundColor: '#1a1a1a',
        }}
      >
        <div
          style={{
            width: '60px',
            height: '60px',
            border: '6px solid #333',
            borderTop: '6px solid #007bff',
            borderRadius: '50%',
            animation: 'spin 1s linear infinite',
          }}
        />
        <style>{`
          @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
        `}</style>
        <p style={{ marginTop: '20px', color: 'white', fontSize: '16px' }}>
          {isRetrying ? `載入中... (重試 ${retryCount})` : '正在載入 Avatar 模型...'}
        </p>
        <div
          style={{
            marginTop: '10px',
            width: '200px',
            height: '4px',
            backgroundColor: '#333',
            borderRadius: '2px',
            overflow: 'hidden',
          }}
        >
          <div
            style={{
              width: '100%',
              height: '100%',
              backgroundColor: '#007bff',
              animation: 'progress 1.5s ease-in-out infinite',
            }}
          />
        </div>
        <style>{`
          @keyframes progress {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
          }
        `}</style>
      </div>
    );
  }

  // Error state
  if (error) {
    return (
      <div
        style={{
          width: '100%',
          height: '100vh',
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          justifyContent: 'center',
          backgroundColor: '#1a1a1a',
          padding: '20px',
        }}
      >
        <div
          style={{
            maxWidth: '500px',
            padding: '40px',
            backgroundColor: '#2a2a2a',
            borderRadius: '12px',
            textAlign: 'center',
          }}
        >
          <div style={{ fontSize: '48px', marginBottom: '20px' }}>😔</div>
          <h2 style={{ fontSize: '20px', marginBottom: '12px', color: 'white' }}>
            Avatar 載入失敗
          </h2>
          <p style={{ fontSize: '14px', marginBottom: '24px', color: '#aaa' }}>
            {error}
          </p>
          <button
            onClick={handleManualRetry}
            style={{
              padding: '12px 24px',
              fontSize: '16px',
              backgroundColor: '#007bff',
              color: 'white',
              border: 'none',
              borderRadius: '6px',
              cursor: 'pointer',
            }}
          >
            🔄 重試
          </button>
        </div>
      </div>
    );
  }

  // Success state - render Canvas
  return (
    <ErrorBoundary
      fallback={
        <div style={{ width: '100%', height: '100vh', backgroundColor: '#1a1a1a' }}>
          <p style={{ color: 'white', padding: '20px' }}>3D 渲染發生錯誤</p>
        </div>
      }
    >
      <Canvas
        camera={{ position: [0, 1.5, 3], fov: 50 }}
        style={{ width: '100%', height: '100vh', backgroundColor: '#1a1a1a' }}
      >
        <Suspense fallback={null}>
          <AvatarModel onLoadComplete={() => setIsLoading(false)} />
          <OrbitControls
            target={[0, 1.2, 0]}
            enablePan={false}
            minDistance={2}
            maxDistance={5}
          />
          <Environment preset="studio" />
        </Suspense>
      </Canvas>
    </ErrorBoundary>
  );
}
```

**驗證方式**:
- [ ] 模型載入時顯示 Spinner 與進度條
- [ ] 模型載入失敗自動重試一次
- [ ] 重試失敗後顯示友善錯誤訊息與手動重試按鈕
- [ ] 手動重試按鈕可正常運作
- [ ] 錯誤訊息清楚易懂（非技術性錯誤）

---

### Task 6: TTS API 錯誤處理與載入狀態

**描述**: 在 ChatInterface 組件中加入 TTS API 錯誤處理、載入狀態與重試機制

**檔案**: `src/components/chat/ChatInterface.tsx`

**程式碼實作**:
```typescript
'use client';

import React, { useState } from 'react';
import { useRetry } from '@/hooks/useRetry';
import { ErrorCategory, createAppError } from '@/lib/errors';
import { useToast } from '@/hooks/useToast';

export function ChatInterface() {
  const [input, setInput] = useState('');
  const [isSending, setIsSending] = useState(false);
  const toast = useToast();

  const sendMessage = async (text: string): Promise<void> => {
    setIsSending(true);

    try {
      // Call TTS API
      const response = await fetch('/api/tts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text }),
      });

      if (!response.ok) {
        throw new Error(`TTS API failed: ${response.status}`);
      }

      const data = await response.json();
      console.log('TTS audio URL:', data.audioUrl);

      // Success - play audio
      toast.success('語音生成成功！');
    } catch (error) {
      // Convert to AppError
      const appError = createAppError(error);
      throw appError; // Propagate for retry logic
    } finally {
      setIsSending(false);
    }
  };

  const { execute: retrySend, isRetrying, retryCount } = useRetry(
    () => sendMessage(input),
    ErrorCategory.API,
    {
      maxRetries: 1,
      onRetry: (attempt) => {
        toast.info(`語音生成失敗，正在重試... (${attempt}/1)`);
      },
      onSuccess: () => {
        setInput(''); // Clear input on success
      },
      onFailure: (error) => {
        const appError = createAppError(error);
        toast.error(appError.userMessage);
      },
    }
  );

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!input.trim()) return;

    retrySend();
  };

  const isProcessing = isSending || isRetrying;

  return (
    <div
      style={{
        position: 'fixed',
        bottom: '20px',
        left: '50%',
        transform: 'translateX(-50%)',
        width: '90%',
        maxWidth: '600px',
        backgroundColor: 'white',
        borderRadius: '12px',
        boxShadow: '0 4px 12px rgba(0,0,0,0.1)',
        padding: '20px',
      }}
    >
      <form onSubmit={handleSubmit}>
        <div style={{ display: 'flex', gap: '12px', alignItems: 'center' }}>
          <input
            type="text"
            value={input}
            onChange={(e) => setInput(e.target.value)}
            placeholder="輸入訊息..."
            disabled={isProcessing}
            style={{
              flex: 1,
              padding: '12px 16px',
              fontSize: '16px',
              border: '1px solid #ddd',
              borderRadius: '8px',
              outline: 'none',
            }}
          />
          <button
            type="submit"
            disabled={isProcessing || !input.trim()}
            style={{
              padding: '12px 24px',
              fontSize: '16px',
              backgroundColor: isProcessing ? '#6c757d' : '#007bff',
              color: 'white',
              border: 'none',
              borderRadius: '8px',
              cursor: isProcessing ? 'not-allowed' : 'pointer',
              minWidth: '120px',
            }}
          >
            {isProcessing ? (
              <span>
                {isRetrying ? `重試中 (${retryCount})` : '生成中...'}
              </span>
            ) : (
              '送出'
            )}
          </button>
        </div>

        {isProcessing && (
          <div style={{ marginTop: '12px', display: 'flex', alignItems: 'center', gap: '8px' }}>
            <div
              style={{
                width: '16px',
                height: '16px',
                border: '2px solid #ddd',
                borderTop: '2px solid #007bff',
                borderRadius: '50%',
                animation: 'spin 1s linear infinite',
              }}
            />
            <span style={{ fontSize: '14px', color: '#6c757d' }}>
              {isRetrying
                ? `正在重試語音生成... (${retryCount}/1)`
                : '正在生成語音...'}
            </span>
          </div>
        )}
      </form>
    </div>
  );
}
```

**驗證方式**:
- [ ] 送出訊息時顯示「生成中...」狀態
- [ ] TTS API 失敗自動重試一次
- [ ] 重試時顯示「重試中 (1/1)」
- [ ] 重試成功後清空輸入框並顯示成功 Toast
- [ ] 重試失敗後顯示友善錯誤 Toast
- [ ] 處理中時禁用輸入框與送出按鈕

---

### Task 7: 網路錯誤處理

**描述**: 加入全域網路狀態監聽，當網路斷線時顯示提示

**檔案**: `src/hooks/useNetworkStatus.ts`, `src/components/NetworkStatus.tsx`

**程式碼實作 (useNetworkStatus Hook)**:
```typescript
'use client';

import { useState, useEffect } from 'react';

export function useNetworkStatus() {
  const [isOnline, setIsOnline] = useState(true);

  useEffect(() => {
    // Initial status
    setIsOnline(navigator.onLine);

    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  return { isOnline };
}
```

**程式碼實作 (NetworkStatus Component)**:
```typescript
'use client';

import React, { useEffect } from 'react';
import { useNetworkStatus } from '@/hooks/useNetworkStatus';
import { useToast } from '@/hooks/useToast';

export function NetworkStatus() {
  const { isOnline } = useNetworkStatus();
  const toast = useToast();

  useEffect(() => {
    if (!isOnline) {
      toast.error('網路連線已中斷，請檢查您的網路設定', 0); // 0 = no auto-close
    }
  }, [isOnline, toast]);

  if (isOnline) return null;

  return (
    <div
      role="alert"
      style={{
        position: 'fixed',
        top: '0',
        left: '0',
        right: '0',
        zIndex: 10000,
        backgroundColor: '#dc3545',
        color: 'white',
        padding: '12px 20px',
        textAlign: 'center',
        fontSize: '14px',
        fontWeight: 'bold',
      }}
    >
      ⚠️ 網路連線已中斷，請檢查您的網路設定
    </div>
  );
}
```

**整合到 Layout**:
```typescript
// src/app/layout.tsx
import { NetworkStatus } from '@/components/NetworkStatus';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html>
      <body>
        <ErrorBoundary>
          <NetworkStatus />
          {children}
        </ErrorBoundary>
      </body>
    </html>
  );
}
```

**驗證方式**:
- [ ] 網路斷線時立即顯示頂部橫幅警告
- [ ] 網路恢復時自動移除警告
- [ ] 支援 Chrome DevTools 的 "Go offline" 測試
- [ ] 警告橫幅在所有頁面都可見（Fixed positioning）

---

### Task 8: 錯誤場景整合測試

**描述**: 撰寫測試指南，涵蓋所有錯誤場景的手動測試步驟

**檔案**: `docs/testing/error-handling-test-plan.md`

**程式碼實作**:
```markdown
# Error Handling & UX Test Plan

## 測試目標
驗證所有錯誤場景都能被正確處理，使用者體驗流暢無崩潰

---

## Test Suite 1: 全域 Error Boundary

### Test Case 1.1: 捕捉渲染錯誤
**步驟**:
1. 開啟瀏覽器開發者工具 Console
2. 手動在任意組件拋出錯誤（例如在 useEffect 加入 `throw new Error('Test error')`）
3. 觀察應用程式是否顯示 ErrorBoundary fallback UI

**預期結果**:
- ✅ 顯示友善錯誤畫面（非白屏）
- ✅ 錯誤訊息: "發生了一些問題，請嘗試重新載入頁面"
- ✅ 顯示「重新載入頁面」按鈕
- ✅ 開發環境顯示錯誤詳情，生產環境隱藏

### Test Case 1.2: 重新載入按鈕
**步驟**:
1. 觸發 ErrorBoundary（同上）
2. 點擊「重新載入頁面」按鈕
3. 觀察應用程式是否恢復正常

**預期結果**:
- ✅ 頁面重新載入
- ✅ 應用程式恢復正常運作

---

## Test Suite 2: 友善錯誤訊息

### Test Case 2.1: Azure TTS API 錯誤
**步驟**:
1. 暫時修改 Azure API Key 為無效值（或註解 API Key）
2. 在聊天介面輸入訊息並送出
3. 觀察錯誤訊息

**預期結果**:
- ✅ 顯示 Toast: "抱歉,語音生成服務暫時無法使用,請稍後再試"
- ✅ 不顯示技術性錯誤（如 "401 Unauthorized"）
- ✅ 自動重試一次（2 秒後）
- ✅ 重試失敗後顯示手動重試選項

### Test Case 2.2: 網路錯誤
**步驟**:
1. 開啟 Chrome DevTools → Network tab
2. 選擇 "Offline" 模式
3. 在聊天介面輸入訊息並送出
4. 觀察錯誤訊息

**預期結果**:
- ✅ 頂部顯示紅色橫幅: "⚠️ 網路連線已中斷"
- ✅ Toast 顯示: "網路連線似乎有問題,請檢查您的網路設定"
- ✅ 自動重試一次（3 秒後）
- ✅ 網路恢復後橫幅自動消失

### Test Case 2.3: 3D 模型載入失敗
**步驟**:
1. 暫時修改 Avatar 模型路徑為錯誤路徑
2. 重新載入頁面
3. 觀察錯誤訊息

**預期結果**:
- ✅ 顯示錯誤畫面: "Avatar 載入失敗"
- ✅ 友善訊息: "Avatar 模型載入失敗,正在重試..."
- ✅ 自動重試一次（1 秒後）
- ✅ 重試失敗後顯示手動重試按鈕

---

## Test Suite 3: 重試機制

### Test Case 3.1: 自動重試 (TTS API)
**步驟**:
1. 使用 Mock API 模擬第一次失敗,第二次成功
2. 送出聊天訊息
3. 觀察重試行為

**預期結果**:
- ✅ 第一次失敗後顯示 Toast: "語音生成失敗,正在重試... (1/1)"
- ✅ 延遲 2 秒後自動重試
- ✅ 第二次成功後顯示 Toast: "語音生成成功！"
- ✅ 輸入框清空

### Test Case 3.2: 重試失敗
**步驟**:
1. 使用 Mock API 模擬兩次都失敗
2. 送出聊天訊息
3. 觀察重試行為

**預期結果**:
- ✅ 第一次失敗後自動重試
- ✅ 第二次失敗後顯示最終錯誤訊息
- ✅ 不再自動重試
- ✅ 輸入框保留原始內容（可再次送出）

### Test Case 3.3: 手動重試 (Avatar 載入)
**步驟**:
1. 模擬 Avatar 載入失敗（兩次都失敗）
2. 觀察錯誤畫面
3. 點擊「重試」按鈕

**預期結果**:
- ✅ 顯示手動重試按鈕
- ✅ 點擊後重新嘗試載入
- ✅ 顯示載入狀態（Spinner）

---

## Test Suite 4: Loading States

### Test Case 4.1: Avatar 載入狀態
**步驟**:
1. 開啟應用程式
2. 觀察 Avatar 載入過程

**預期結果**:
- ✅ 顯示 Spinner 動畫
- ✅ 顯示文字: "正在載入 Avatar 模型..."
- ✅ 顯示進度條動畫
- ✅ 載入完成後自動消失

### Test Case 4.2: TTS 生成狀態
**步驟**:
1. 在聊天介面輸入訊息並送出
2. 觀察載入狀態

**預期結果**:
- ✅ 送出按鈕文字變更為 "生成中..."
- ✅ 輸入框與按鈕被禁用
- ✅ 顯示小型 Spinner 與文字: "正在生成語音..."
- ✅ 完成後恢復正常狀態

### Test Case 4.3: 重試載入狀態
**步驟**:
1. 模擬 TTS API 第一次失敗
2. 觀察重試時的載入狀態

**預期結果**:
- ✅ 顯示: "重試中 (1/1)"
- ✅ Spinner 持續顯示
- ✅ 按鈕保持禁用

---

## Test Suite 5: Toast 通知系統

### Test Case 5.1: Toast 顯示與自動消失
**步驟**:
1. 觸發成功操作（例如 TTS 生成成功）
2. 觀察 Toast 行為

**預期結果**:
- ✅ Toast 從右側滑入
- ✅ 顯示成功圖示 (✅) 與訊息
- ✅ 5 秒後自動消失

### Test Case 5.2: 手動關閉 Toast
**步驟**:
1. 觸發 Toast
2. 點擊 × 關閉按鈕

**預期結果**:
- ✅ Toast 立即消失

### Test Case 5.3: 多個 Toast 堆疊
**步驟**:
1. 快速觸發多個操作（成功/錯誤混合）
2. 觀察 Toast 堆疊行為

**預期結果**:
- ✅ 多個 Toast 垂直堆疊
- ✅ 最新的 Toast 在最上方
- ✅ 各自獨立倒數消失

---

## Test Suite 6: 無障礙測試

### Test Case 6.1: Screen Reader 支援
**步驟**:
1. 啟用 screen reader（Windows: Narrator, Mac: VoiceOver）
2. 觸發錯誤訊息
3. 確認 screen reader 是否讀出訊息

**預期結果**:
- ✅ Toast 使用 `role="alert"` 與 `aria-live="assertive"`
- ✅ Screen reader 自動讀出錯誤訊息
- ✅ 關閉按鈕有 `aria-label="關閉通知"`

### Test Case 6.2: 鍵盤導航
**步驟**:
1. 使用 Tab 鍵導航
2. 確認所有按鈕（重試、關閉）可通過鍵盤存取

**預期結果**:
- ✅ 所有互動元素可用 Tab 鍵聚焦
- ✅ Enter/Space 鍵可觸發按鈕
- ✅ 聚焦時有明顯的視覺提示

---

## 測試環境需求

### 瀏覽器
- Chrome (最新版本)
- Edge (最新版本)
- Safari (最新版本)
- Firefox (最新版本)

### 測試設備
- Desktop (1920×1080)
- Tablet (768×1024)
- Mobile (375×667)

### 網路模擬
- Fast 3G
- Slow 3G
- Offline

---

## 驗收標準

所有測試案例通過率: **100%**
- 無白屏崩潰
- 所有錯誤訊息友善易懂
- 重試機制正常運作
- Loading states 正確顯示
- Toast 通知系統穩定
- 無障礙支援完整
```

**驗證方式**:
- [ ] 所有 Test Suite 執行完畢
- [ ] 所有 Test Case 通過率 100%
- [ ] 記錄測試結果與截圖
- [ ] 確認所有瀏覽器相容性

---

## 📊 Dev Notes

### Error Handling Strategy

**三層錯誤處理架構**:

1. **Local Try-Catch** (第一層):
   - 在已知可能失敗的操作加上 try-catch
   - 例如: API calls, 3D model loading, audio playback
   - 優點: 可精確處理特定錯誤,提供客製化錯誤訊息

2. **Error Boundary** (第二層):
   - 捕捉所有未處理的 React 渲染錯誤
   - 防止應用程式白屏崩潰
   - 優點: 全域保護,確保使用者永遠看到友善介面

3. **Global Error Handler** (第三層):
   - 捕捉 window.onerror, unhandledrejection 事件
   - 記錄到 error tracking service (optional)
   - 優點: 捕捉所有遺漏的錯誤,包括非 React 錯誤

### Retry Strategy

**指數退避 (Exponential Backoff) vs 固定延遲**:

本專案採用 **固定延遲** 策略:
- Network errors: 3 秒延遲
- API errors: 2 秒延遲
- Model loading: 1 秒延遲

**原因**:
- POC 階段重試次數少 (maxRetries = 1),指數退避增益不大
- 固定延遲實作簡單,程式碼易維護
- MVP 階段可升級為指數退避（2s → 4s → 8s）

**何時不重試**:
- 401/403 驗證錯誤 (不會因為重試而成功)
- 400 參數錯誤 (參數錯誤重試無意義)
- 使用者主動取消操作

### Toast vs Modal vs Inline Error

**Toast (本專案採用)**:
- 優點: 非侵入式,不中斷使用者流程,自動消失
- 適合: 暫時性通知,成功/錯誤訊息,不需要使用者立即回應
- 缺點: 使用者可能錯過訊息

**Modal**:
- 優點: 強制使用者注意,確保訊息被看到
- 適合: 嚴重錯誤,需要使用者確認的操作
- 缺點: 侵入性強,中斷使用者流程

**Inline Error**:
- 優點: 直接顯示在錯誤來源旁,情境明確
- 適合: 表單驗證錯誤
- 缺點: 需要為每個元件設計錯誤顯示位置

### Error Monitoring (MVP 階段)

**建議整合 Error Tracking Service**:
- **Sentry**: 最受歡迎,功能強大,免費方案足夠
- **LogRocket**: 可錄製使用者操作影片,重現錯誤情境
- **Rollbar**: 輕量級,專注於錯誤追蹤

**整合方式** (以 Sentry 為例):
```bash
npm install @sentry/nextjs
```

```typescript
// sentry.client.config.ts
import * as Sentry from '@sentry/nextjs';

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  tracesSampleRate: 1.0,
  environment: process.env.NODE_ENV,
});
```

```typescript
// ErrorBoundary.tsx - 加入 Sentry logging
componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {
  console.error('ErrorBoundary caught an error:', error, errorInfo);

  // Send to Sentry
  Sentry.captureException(error, {
    contexts: {
      react: {
        componentStack: errorInfo.componentStack,
      },
    },
  });
}
```

### UX Best Practices

1. **錯誤訊息撰寫原則**:
   - ❌ "Error 500: Internal Server Error"
   - ✅ "抱歉,語音生成服務暫時無法使用,請稍後再試"

   **原則**:
   - 避免技術術語（500, API, timeout）
   - 說明發生了什麼（語音生成失敗）
   - 提供解決方案（請稍後再試）
   - 語氣友善、同理心（抱歉）

2. **Loading States 設計原則**:
   - **立即回饋**: 點擊後 100ms 內顯示載入狀態
   - **進度提示**: 長時間操作（>3 秒）顯示進度條或百分比
   - **取消選項**: 長時間操作提供取消按鈕
   - **骨架屏**: Avatar 載入時顯示骨架屏,而非空白

3. **重試 UX**:
   - **自動重試**: 暫時性錯誤（網路波動）自動重試,不打擾使用者
   - **手動重試**: 持續性錯誤顯示重試按鈕,由使用者決定
   - **重試次數透明**: 顯示「重試 (1/1)」,讓使用者知道進度

---

## 🧪 Testing Strategy

### Unit Testing

**測試目標**: Error classification, retry logic, toast system

**測試框架**: Jest + React Testing Library

**測試案例**:

```typescript
// __tests__/lib/errors.test.ts
import { classifyError, isRetryableError, createAppError, ErrorCategory } from '@/lib/errors';

describe('Error Classification', () => {
  it('should classify network errors correctly', () => {
    const error = new Error('Network request failed');
    expect(classifyError(error)).toBe(ErrorCategory.NETWORK);
  });

  it('should classify API errors correctly', () => {
    const error = new Error('Azure TTS API returned 500');
    expect(classifyError(error)).toBe(ErrorCategory.API);
  });

  it('should classify model loading errors correctly', () => {
    const error = new Error('Failed to load GLTF model');
    expect(classifyError(error)).toBe(ErrorCategory.MODEL_LOADING);
  });

  it('should return UNKNOWN for unrecognized errors', () => {
    const error = new Error('Random error');
    expect(classifyError(error)).toBe(ErrorCategory.UNKNOWN);
  });
});

describe('Retryable Errors', () => {
  it('should mark NETWORK errors as retryable', () => {
    expect(isRetryableError(ErrorCategory.NETWORK)).toBe(true);
  });

  it('should mark API errors as retryable', () => {
    expect(isRetryableError(ErrorCategory.API)).toBe(true);
  });

  it('should mark UNKNOWN errors as non-retryable', () => {
    expect(isRetryableError(ErrorCategory.UNKNOWN)).toBe(false);
  });
});

describe('AppError Creation', () => {
  it('should create AppError with friendly message', () => {
    const error = new Error('Network timeout');
    const appError = createAppError(error);

    expect(appError.category).toBe(ErrorCategory.NETWORK);
    expect(appError.userMessage).toBe('網路連線似乎有問題，請檢查您的網路設定');
    expect(appError.retryable).toBe(true);
  });
});
```

```typescript
// __tests__/hooks/useRetry.test.tsx
import { renderHook, act, waitFor } from '@testing-library/react';
import { useRetry } from '@/hooks/useRetry';
import { ErrorCategory } from '@/lib/errors';

describe('useRetry Hook', () => {
  it('should execute function successfully on first attempt', async () => {
    const mockFn = jest.fn().mockResolvedValue('success');
    const { result } = renderHook(() => useRetry(mockFn, ErrorCategory.API));

    let response: string | null = null;
    await act(async () => {
      response = await result.current.execute();
    });

    expect(response).toBe('success');
    expect(mockFn).toHaveBeenCalledTimes(1);
    expect(result.current.retryCount).toBe(0);
  });

  it('should retry once on failure then succeed', async () => {
    const mockFn = jest
      .fn()
      .mockRejectedValueOnce(new Error('First fail'))
      .mockResolvedValueOnce('success');

    const onRetry = jest.fn();
    const { result } = renderHook(() =>
      useRetry(mockFn, ErrorCategory.API, { maxRetries: 1, onRetry })
    );

    await act(async () => {
      await result.current.execute();
    });

    await waitFor(() => {
      expect(mockFn).toHaveBeenCalledTimes(2);
      expect(onRetry).toHaveBeenCalledWith(1);
      expect(result.current.retryCount).toBe(1);
    });
  });

  it('should call onFailure after max retries', async () => {
    const mockFn = jest.fn().mockRejectedValue(new Error('Fail'));
    const onFailure = jest.fn();

    const { result } = renderHook(() =>
      useRetry(mockFn, ErrorCategory.API, { maxRetries: 1, onFailure })
    );

    await act(async () => {
      try {
        await result.current.execute();
      } catch (error) {
        // Expected
      }
    });

    await waitFor(() => {
      expect(mockFn).toHaveBeenCalledTimes(2);
      expect(onFailure).toHaveBeenCalledTimes(1);
    });
  });
});
```

### Integration Testing

**測試目標**: Error Boundary, Toast system, network status

**測試案例**:

```typescript
// __tests__/components/ErrorBoundary.test.tsx
import { render, screen } from '@testing-library/react';
import { ErrorBoundary } from '@/components/ErrorBoundary';

const ThrowError = () => {
  throw new Error('Test error');
};

describe('ErrorBoundary', () => {
  it('should catch errors and show fallback UI', () => {
    const { container } = render(
      <ErrorBoundary>
        <ThrowError />
      </ErrorBoundary>
    );

    expect(screen.getByText('😔 發生了一些問題')).toBeInTheDocument();
    expect(screen.getByText(/抱歉,應用程式遇到了意外錯誤/)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /重新載入頁面/ })).toBeInTheDocument();
  });

  it('should show error details in development mode', () => {
    const originalEnv = process.env.NODE_ENV;
    process.env.NODE_ENV = 'development';

    render(
      <ErrorBoundary>
        <ThrowError />
      </ErrorBoundary>
    );

    expect(screen.getByText(/錯誤詳情/)).toBeInTheDocument();

    process.env.NODE_ENV = originalEnv;
  });
});
```

### Manual Testing

**測試清單**: 參考 Task 8 的完整測試計畫

**測試重點**:
- [ ] 所有錯誤場景都有友善訊息
- [ ] 重試機制正常運作
- [ ] Loading states 正確顯示
- [ ] Toast 通知系統穩定
- [ ] 網路狀態監聽正常
- [ ] 無障礙支援完整

---

## 📈 Success Metrics

### 量化指標

1. **錯誤捕捉率**: 100% (無白屏崩潰)
2. **重試成功率**: ≥ 40% (暫時性錯誤重試成功)
3. **錯誤回應時間**: ≤ 500ms (顯示錯誤訊息)
4. **使用者流失率**: 降低 20% (相比無錯誤處理版本)

### 質化指標

1. **使用者回饋**: "錯誤訊息清楚易懂"
2. **開發者體驗**: "容易加入新錯誤類型與處理邏輯"
3. **可維護性**: "錯誤處理邏輯集中管理,易於擴展"

---

## 🔗 Dependencies

### Epic Dependencies
- **Depends on**:
  - Epic 2 (Avatar 載入需要錯誤處理)
  - Epic 3 (TTS API 需要錯誤處理)
  - Epic 4 (Lip Sync 需要錯誤處理)

### Story Dependencies
- **Must Complete Before**:
  - Story 5.3 (UI/UX 細節打磨) - Toast 系統可重複使用
  - Story 5.6 (技術驗證報告) - 需要錯誤處理測試結果

### External Dependencies
- `react@18.x`: Error Boundary support
- `next@14.x`: App Router, client components

---

## 📦 Deliverables

1. **Components**:
   - `src/components/ErrorBoundary.tsx` ✅
   - `src/components/Toast.tsx` ✅
   - `src/components/NetworkStatus.tsx` ✅

2. **Hooks**:
   - `src/hooks/useRetry.ts` ✅
   - `src/hooks/useToast.ts` ✅
   - `src/hooks/useNetworkStatus.ts` ✅

3. **Utilities**:
   - `src/lib/errors.ts` ✅

4. **Documentation**:
   - `docs/testing/error-handling-test-plan.md` ✅

5. **Tests**:
   - `__tests__/lib/errors.test.ts`
   - `__tests__/hooks/useRetry.test.tsx`
   - `__tests__/components/ErrorBoundary.test.tsx`

---

## ✅ Definition of Done

- [ ] 全域 ErrorBoundary 成功捕捉所有渲染錯誤
- [ ] 所有錯誤分類正確,友善訊息映射完整
- [ ] 重試機制運作正常 (自動重試 1 次)
- [ ] Toast 通知系統穩定,支援多種類型 (success/error/info/warning)
- [ ] Avatar 載入狀態與錯誤處理完整
- [ ] TTS API 錯誤處理與載入狀態完整
- [ ] 網路狀態監聽正常,斷線時顯示警告
- [ ] 所有測試案例通過 (Unit + Integration + Manual)
- [ ] 無障礙支援完整 (ARIA, screen reader, keyboard navigation)
- [ ] 文件齊全 (測試計畫, 錯誤處理策略)
- [ ] Code review 通過
- [ ] 在 Chrome, Edge, Safari, Firefox 測試通過

---

## 📚 References

- [React Error Boundaries](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)
- [Web API: Navigator.onLine](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/onLine)
- [ARIA Live Regions](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions)
- [UX Writing Best Practices](https://uxplanet.org/error-message-best-practices-6c39b3d8e0f6)
- [Exponential Backoff Algorithm](https://en.wikipedia.org/wiki/Exponential_backoff)

---

**Story 建立日期**: 2025-10-14
**最後更新**: 2025-10-14
**INVEST Score**: ⭐⭐⭐⭐⭐⭐ (6/6)
- ✅ Independent: 可獨立開發與測試
- ✅ Negotiable: 重試次數、延遲時間可調整
- ✅ Valuable: 大幅提升使用者體驗,降低流失率
- ✅ Estimable: 6 小時預估時間合理
- ✅ Small: 範圍明確,可在一個 Sprint 內完成
- ✅ Testable: 可透過單元測試、整合測試與手動測試驗證

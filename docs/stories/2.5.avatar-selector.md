# Story 2.5: Avatar 選擇功能與切換

## Status
Approved

---

## Story

**As a** 使用者,
**I want** 能夠選擇與切換不同的 3D Avatar，
**so that** 可以自訂聊天助理的外觀，提升個人化體驗。

---

## Acceptance Criteria

1. 建立 `components/avatar/AvatarSelector.tsx` 組件，顯示 3 個 Avatar 預覽卡片
2. 每個卡片顯示 Avatar 縮圖、名稱、與「選擇」按鈕
3. 當前選中的 Avatar 卡片有視覺標記（邊框高亮）
4. 點擊「選擇」按鈕後，場景中的 Avatar 模型切換為新的 Avatar
5. 使用 Zustand 管理 Avatar 選擇狀態（全域狀態管理）
6. Avatar 切換時有淡入淡出過渡效果（fade transition）
7. 在頁面右側加入「Change Avatar」按鈕，點擊後顯示/隱藏 Selector
8. Selector 使用響應式設計，支援桌面與行動裝置

---

## Tasks / Subtasks

- [ ] **Task 1: 安裝 Zustand 狀態管理** (AC: 5)
  - [ ] 執行 `pnpm add zustand`（版本 4.5+）
  - [ ] 驗證 `package.json` 已新增 zustand 依賴
  - [ ] 執行 `pnpm install` 確保安裝成功

- [ ] **Task 2: 建立 Avatar Store（Zustand）** (AC: 5)
  - [ ] 建立目錄 `stores/`（如尚未存在）
  - [ ] 建立 `stores/avatarStore.ts` 檔案
  - [ ] 實作 Zustand Store：
    ```typescript
    import { create } from 'zustand';
    import { AVATAR_URLS } from '@/lib/avatar/constants';

    export interface AvatarState {
      currentAvatarId: string;
      currentAvatarUrl: string;
      isSelectorOpen: boolean;
      setAvatar: (avatarId: string) => void;
      toggleSelector: () => void;
    }

    // Avatar 清單
    export const AVATARS = [
      {
        id: 'avatar1',
        name: 'Alex',
        url: AVATAR_URLS.avatar1,
        thumbnail: '/avatars/alex-thumb.jpg',  // 後續加入
      },
      {
        id: 'avatar2',
        name: 'Jordan',
        url: AVATAR_URLS.avatar2,
        thumbnail: '/avatars/jordan-thumb.jpg',
      },
      {
        id: 'avatar3',
        name: 'Casey',
        url: AVATAR_URLS.avatar3,
        thumbnail: '/avatars/casey-thumb.jpg',
      },
    ];

    export const useAvatarStore = create<AvatarState>((set) => ({
      currentAvatarId: 'avatar1',
      currentAvatarUrl: AVATAR_URLS.avatar1,
      isSelectorOpen: false,

      setAvatar: (avatarId: string) => {
        const avatar = AVATARS.find((a) => a.id === avatarId);
        if (avatar) {
          set({
            currentAvatarId: avatarId,
            currentAvatarUrl: avatar.url,
          });
        }
      },

      toggleSelector: () => {
        set((state) => ({ isSelectorOpen: !state.isSelectorOpen }));
      },
    }));
    ```
  - [ ] 加入 TypeScript 型別定義與 JSDoc 註解

- [ ] **Task 3: 更新 lib/avatar/constants.ts** (AC: 1)
  - [ ] 開啟 `lib/avatar/constants.ts`
  - [ ] 確保 AVATAR_URLS 包含 3 個 Avatar URL：
    ```typescript
    export const AVATAR_URLS = {
      avatar1: 'https://models.readyplayer.me/{id1}.glb',
      avatar2: 'https://models.readyplayer.me/{id2}.glb',
      avatar3: 'https://models.readyplayer.me/{id3}.glb',
    } as const;
    ```
  - [ ] 替換為實際的 Ready Player Me Avatar URL

- [ ] **Task 4: 建立 AvatarSelector 組件** (AC: 1, 2, 3)
  - [ ] 建立 `components/avatar/AvatarSelector.tsx` 檔案
  - [ ] 實作 Selector UI：
    ```typescript
    'use client';

    import { useAvatarStore, AVATARS } from '@/stores/avatarStore';
    import { useState } from 'react';

    export default function AvatarSelector() {
      const { currentAvatarId, setAvatar, isSelectorOpen, toggleSelector } = useAvatarStore();

      if (!isSelectorOpen) return null;

      return (
        <div className="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50">
          <div className="bg-slate-800 rounded-xl shadow-2xl p-6 max-w-2xl w-full mx-4">
            <div className="flex justify-between items-center mb-6">
              <h2 className="text-2xl font-bold text-white">Choose Your Avatar</h2>
              <button
                onClick={toggleSelector}
                className="text-gray-400 hover:text-white transition-colors"
                aria-label="Close avatar selector"
              >
                ✕
              </button>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              {AVATARS.map((avatar) => {
                const isSelected = currentAvatarId === avatar.id;

                return (
                  <div
                    key={avatar.id}
                    className={`
                      bg-slate-700 rounded-lg p-4 cursor-pointer transition-all
                      ${isSelected ? 'ring-4 ring-blue-500 shadow-xl' : 'hover:bg-slate-600'}
                    `}
                    onClick={() => setAvatar(avatar.id)}
                  >
                    {/* Avatar 縮圖（暫時使用 placeholder）*/}
                    <div className="aspect-square bg-slate-600 rounded-lg mb-3 flex items-center justify-center">
                      <span className="text-6xl">{avatar.id === 'avatar1' ? '👨' : avatar.id === 'avatar2' ? '👩' : '🧑'}</span>
                    </div>

                    {/* Avatar 名稱 */}
                    <h3 className="text-lg font-semibold text-white text-center mb-2">
                      {avatar.name}
                    </h3>

                    {/* 選擇按鈕 */}
                    <button
                      className={`
                        w-full py-2 rounded-md font-medium transition-colors
                        ${
                          isSelected
                            ? 'bg-blue-500 text-white'
                            : 'bg-slate-600 text-gray-300 hover:bg-slate-500'
                        }
                      `}
                      onClick={(e) => {
                        e.stopPropagation();
                        setAvatar(avatar.id);
                        toggleSelector();
                      }}
                    >
                      {isSelected ? '✓ Selected' : 'Select'}
                    </button>
                  </div>
                );
              })}
            </div>
          </div>
        </div>
      );
    }
    ```

- [ ] **Task 5: 建立「Change Avatar」觸發按鈕** (AC: 7)
  - [ ] 建立 `components/avatar/AvatarChangeButton.tsx` 檔案
  - [ ] 實作觸發按鈕：
    ```typescript
    'use client';

    import { useAvatarStore } from '@/stores/avatarStore';

    export default function AvatarChangeButton() {
      const toggleSelector = useAvatarStore((state) => state.toggleSelector);

      return (
        <button
          onClick={toggleSelector}
          className="fixed top-6 right-6 z-40 px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg shadow-lg transition-colors font-medium"
          aria-label="Change avatar"
        >
          🎭 Change Avatar
        </button>
      );
    }
    ```

- [ ] **Task 6: 整合 Zustand Store 至 AvatarCanvas** (AC: 4, 5)
  - [ ] 開啟 `components/avatar/AvatarCanvas.tsx`
  - [ ] 引入 useAvatarStore Hook
  - [ ] 使用 Store 中的 currentAvatarUrl：
    ```typescript
    import { useAvatarStore } from '@/stores/avatarStore';

    export default function AvatarCanvas() {
      const currentAvatarUrl = useAvatarStore((state) => state.currentAvatarUrl);
      const avatarModelRef = useRef<AvatarModelHandle>(null);

      return (
        <div className="relative w-full h-screen">
          <Canvas>
            {/* ... 場景內容 */}
            <Suspense fallback={<AvatarLoader />}>
              <AvatarModel
                key={currentAvatarUrl}  // 強制重新載入
                ref={avatarModelRef}
                modelUrl={currentAvatarUrl}
                position={[0, -1, 0]}
                scale={1}
              />
            </Suspense>
          </Canvas>

          {/* 控制面板 */}
          <AvatarControlPanel avatarRef={avatarModelRef} />
        </div>
      );
    }
    ```

- [ ] **Task 7: 實作淡入淡出過渡效果** (AC: 6)
  - [ ] 在 AvatarModel 組件中加入 opacity 動畫
  - [ ] 方案 1：使用 React Three Fiber 的 useSpring（需安裝 @react-spring/three）
  - [ ] 方案 2：使用 CSS opacity + React 狀態（較簡單）
  - [ ] 實作方案 2（推薦）：
    ```typescript
    // components/avatar/AvatarCanvas.tsx
    const [isTransitioning, setIsTransitioning] = useState(false);

    useEffect(() => {
      // Avatar URL 變更時觸發過渡
      setIsTransitioning(true);
      const timer = setTimeout(() => {
        setIsTransitioning(false);
      }, 300); // 300ms 淡入

      return () => clearTimeout(timer);
    }, [currentAvatarUrl]);

    return (
      <Canvas className={`transition-opacity duration-300 ${isTransitioning ? 'opacity-0' : 'opacity-100'}`}>
        {/* ... */}
      </Canvas>
    );
    ```
  - [ ] 測試過渡效果平滑度

- [ ] **Task 8: 整合所有組件至主頁面** (AC: 7, 8)
  - [ ] 開啟 `app/page.tsx`
  - [ ] 引入 AvatarSelector 與 AvatarChangeButton
  - [ ] 更新頁面結構：
    ```typescript
    import AvatarCanvas from '@/components/avatar/AvatarCanvas';
    import AvatarSelector from '@/components/avatar/AvatarSelector';
    import AvatarChangeButton from '@/components/avatar/AvatarChangeButton';

    export default function Home() {
      return (
        <main className="relative flex min-h-screen flex-col">
          {/* 3D 場景 */}
          <AvatarCanvas />

          {/* Change Avatar 按鈕 */}
          <AvatarChangeButton />

          {/* Avatar 選擇器（Modal）*/}
          <AvatarSelector />
        </main>
      );
    }
    ```

- [ ] **Task 9: 響應式設計調整** (AC: 8)
  - [ ] 測試 Selector 在不同螢幕尺寸的顯示
  - [ ] 調整 Tailwind CSS 斷點：
    ```typescript
    // 桌面版：3 欄
    className="grid grid-cols-1 md:grid-cols-3 gap-4"

    // 平板版：2 欄
    className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4"

    // 行動版：1 欄（預設）
    ```
  - [ ] 測試行動裝置觸控操作
  - [ ] 確保按鈕與卡片大小適合觸控（≥44px 高度）

- [ ] **Task 10: Avatar 切換功能測試** (AC: 4, 5, 6)
  - [ ] 執行 `pnpm dev`，開啟頁面
  - [ ] 點擊「🎭 Change Avatar」按鈕
  - [ ] 驗證以下項目：
    - ✅ Selector Modal 顯示
    - ✅ 3 個 Avatar 卡片正確顯示
    - ✅ 當前 Avatar 有高亮邊框
    - ✅ 點擊其他 Avatar 卡片
    - ✅ 場景中 Avatar 切換為新的模型
    - ✅ 切換過程有淡入淡出效果
    - ✅ Selector 自動關閉
  - [ ] 測試快速連續切換（3 次）
  - [ ] 驗證 Avatar 動畫（呼吸、眨眼）在切換後正常運作

- [ ] **Task 11: 狀態持久化（選做）** (AC: 5)
  - [ ] 使用 localStorage 儲存使用者選擇：
    ```typescript
    // stores/avatarStore.ts
    import { create } from 'zustand';
    import { persist } from 'zustand/middleware';

    export const useAvatarStore = create<AvatarState>()(
      persist(
        (set) => ({
          // ... store 邏輯
        }),
        {
          name: 'avatar-storage',  // localStorage key
        }
      )
    );
    ```
  - [ ] 測試重新整理頁面，Avatar 選擇是否保留

---

## Dev Notes

### 相關來源樹（Source Tree）

Epic 2 Story 2.5 完成後的檔案結構：

```
avatar-chat-poc/
├── components/
│   └── avatar/
│       ├── AvatarCanvas.tsx        # 更新：使用 Zustand Store
│       ├── AvatarModel.tsx
│       ├── AvatarSelector.tsx      # 新增：Avatar 選擇器 UI
│       ├── AvatarChangeButton.tsx  # 新增：觸發按鈕
│       ├── AvatarControlPanel.tsx
│       ├── AvatarLoadingState.tsx
│       └── hooks/
│           └── useAvatarAnimation.ts
├── stores/
│   └── avatarStore.ts              # 新增：Zustand 全域狀態
├── lib/
│   └── avatar/
│       ├── loaders.ts
│       ├── constants.ts            # 更新：3 個 Avatar URLs
│       └── animations.ts
├── types/
│   └── avatar.ts
└── app/
    └── page.tsx                    # 更新：整合所有 Avatar 組件
```

### Zustand 狀態管理說明

**為何選擇 Zustand？**
- ✅ 輕量級（1KB gzipped）
- ✅ 無 Provider 包裹需求（簡化架構）
- ✅ TypeScript 原生支援
- ✅ 支援 Middleware（如 persist）
- ✅ 性能優異（避免不必要的重新渲染）
- ✅ 學習曲線平緩

**與其他狀態管理比較**:
| 特性 | Zustand | Redux | Context API |
|------|---------|-------|-------------|
| 大小 | 1KB | 7KB+ | 0KB (內建) |
| 設定複雜度 | 低 | 高 | 中 |
| Provider 需求 | ❌ | ✅ | ✅ |
| 效能 | 優 | 優 | 中（易重渲染） |
| Middleware | ✅ | ✅ | ❌ |

**基本用法**:
```typescript
// 建立 Store
const useStore = create((set) => ({
  value: 0,
  increment: () => set((state) => ({ value: state.value + 1 })),
}));

// 使用 Store（組件）
const value = useStore((state) => state.value);
const increment = useStore((state) => state.increment);

// 選擇性訂閱（優化效能）
const value = useStore((state) => state.value);  // 只訂閱 value
```

**Persist Middleware**:
```typescript
// 自動儲存至 localStorage
persist(
  (set) => ({ /* store 邏輯 */ }),
  { name: 'storage-key' }
);

// 結果
localStorage.getItem('storage-key');
// {"state": {"currentAvatarId": "avatar2", ...}}
```

### Avatar 切換機制設計

**切換流程**:
```
使用者點擊「Change Avatar」
    ↓
顯示 AvatarSelector Modal
    ↓
使用者選擇新 Avatar
    ↓
setAvatar(newAvatarId) → Zustand Store 更新
    ↓
currentAvatarUrl 變更 → React 重新渲染
    ↓
AvatarModel 組件 key 變更 → 強制重新掛載
    ↓
useGLTF 載入新模型 → Suspense 顯示 Loader
    ↓
新 Avatar 渲染完成
    ↓
淡入淡出過渡效果
```

**強制重新掛載原理**:
```typescript
// key 變更 → React 重新建立組件實例
<AvatarModel
  key={currentAvatarUrl}  // 每次 URL 變更，key 也變更
  modelUrl={currentAvatarUrl}
/>

// 效果
Avatar1 載入 → key="url1" → 組件 A
Avatar2 選擇 → key="url2" → 組件 A 卸載，組件 B 掛載
```

**為何不使用 useEffect 切換？**
```typescript
// 不推薦（會有快取問題）
useEffect(() => {
  loadNewAvatar(currentAvatarUrl);
}, [currentAvatarUrl]);

// 推薦（利用 React key 機制）
<AvatarModel key={currentAvatarUrl} ... />
```

### 淡入淡出過渡效果

**方案比較**:
| 方案 | 優點 | 缺點 | 推薦度 |
|------|------|------|--------|
| CSS Opacity | 簡單、效能好 | Canvas 整體淡入淡出 | ⭐⭐⭐ |
| React Spring | 動畫流暢、彈性 | 需要額外依賴 | ⭐⭐ |
| Three.js Opacity | 針對模型淡入淡出 | 複雜、效能較差 | ⭐ |

**實作方案 1: CSS Opacity（推薦）**
```typescript
const [isTransitioning, setIsTransitioning] = useState(false);

useEffect(() => {
  setIsTransitioning(true);
  setTimeout(() => setIsTransitioning(false), 300);
}, [currentAvatarUrl]);

<Canvas className={`transition-opacity duration-300 ${isTransitioning ? 'opacity-0' : 'opacity-100'}`}>
```

**實作方案 2: React Spring（進階）**
```typescript
import { useSpring, animated } from '@react-spring/three';

const AnimatedGroup = animated('group');
const springs = useSpring({
  opacity: isTransitioning ? 0 : 1,
  config: { duration: 300 },
});

<AnimatedGroup material-opacity={springs.opacity}>
  <primitive object={scene} />
</AnimatedGroup>
```

### UI/UX 設計考量

**Modal 設計原則**:
- 背景遮罩（backdrop）：半透明黑色 + 模糊效果
- 內容區域：深色卡片（配合 3D 場景）
- 關閉機制：X 按鈕 + 點擊背景關閉（可選）
- 動畫：淡入淡出 + Scale 變化（可選）

**卡片選擇視覺回饋**:
```typescript
// 未選中
className="bg-slate-700 hover:bg-slate-600"

// 已選中
className="bg-slate-700 ring-4 ring-blue-500 shadow-xl"

// 懸浮效果
className="transition-all hover:scale-105"
```

**觸控友善設計**:
- 按鈕最小高度：44px（Apple 建議）
- 卡片間距：≥16px（避免誤觸）
- 點擊區域：整張卡片可點擊（不只按鈕）

**可訪問性（Accessibility）**:
```typescript
// 語義化 HTML
<button aria-label="Close avatar selector">
<div role="dialog" aria-modal="true">

// 鍵盤導航
<button
  onKeyDown={(e) => {
    if (e.key === 'Escape') toggleSelector();
  }}
>
```

### 響應式設計策略

**Tailwind CSS 斷點**:
```typescript
// 行動版（<640px）
className="grid grid-cols-1"

// 平板版（640px-768px）
className="sm:grid-cols-2"

// 桌面版（>768px）
className="md:grid-cols-3"
```

**測試裝置清單**:
- iPhone SE (375px)
- iPhone 12 Pro (390px)
- iPad (768px)
- iPad Pro (1024px)
- Desktop (1920px)

**行動版優化**:
```typescript
// Modal 全螢幕
className="fixed inset-0 md:inset-auto md:max-w-2xl"

// 字體大小調整
className="text-sm md:text-base"

// 間距縮小
className="gap-3 md:gap-4"
```

### 重要架構決策

1. **為何使用 Modal 而非 Sidebar？**
   - ✅ 聚焦使用者注意力
   - ✅ 不佔用場景空間
   - ✅ 行動裝置友善
   - ❌ Sidebar 會遮擋 Avatar

2. **為何使用全域狀態（Zustand）而非 Props？**
   ```typescript
   // Props 傳遞（不推薦）
   <Page>
     <AvatarCanvas currentAvatar={avatar}>
       <AvatarModel avatar={avatar} />
     </AvatarCanvas>
     <AvatarSelector setAvatar={setAvatar} />
   </Page>

   // Zustand（推薦）
   const avatar = useAvatarStore((state) => state.currentAvatarUrl);
   // 任何組件都可直接存取，無需 Props drilling
   ```

3. **Avatar 縮圖策略**:
   - POC 階段：使用 Emoji placeholder（👨👩🧑）
   - 未來優化：
     - 方案 1：Ready Player Me API 取得縮圖
     - 方案 2：Three.js 渲染縮圖（複雜）
     - 方案 3：手動截圖並上傳

4. **狀態持久化決策**:
   - 使用 persist middleware 儲存使用者選擇
   - localStorage 儲存 Avatar ID（不儲存 URL）
   - 重新整理頁面後保留選擇

### Testing

**測試框架**: 手動測試 + 互動測試 + 響應式測試

**測試範圍**:
1. ✅ Zustand Store 正確管理狀態
2. ✅ Avatar Selector UI 正確顯示
3. ✅ Change Avatar 按鈕可觸發 Selector
4. ✅ 卡片選中視覺回饋正確
5. ✅ Avatar 切換功能正常
6. ✅ 淡入淡出過渡效果平滑
7. ✅ 響應式設計在各裝置正常
8. ✅ 狀態持久化功能正常

**測試執行方式**:
```bash
# 啟動開發伺服器
pnpm dev

# 瀏覽器開啟
http://localhost:3000

# 測試項目
1. 點擊「Change Avatar」按鈕
2. 驗證 Selector Modal 顯示
3. 觀察 3 個 Avatar 卡片
4. 點擊不同 Avatar 卡片
5. 觀察場景中 Avatar 切換
6. 測試淡入淡出效果
7. 重新整理頁面，驗證選擇保留
8. 調整瀏覽器視窗大小，測試響應式
```

**驗證清單**:
- [ ] Zustand Store 安裝成功
- [ ] Change Avatar 按鈕顯示在右上角
- [ ] 點擊按鈕顯示 Selector Modal
- [ ] Modal 背景有遮罩與模糊效果
- [ ] 3 個 Avatar 卡片正確顯示
- [ ] 當前 Avatar 有藍色邊框高亮
- [ ] 點擊卡片切換 Avatar
- [ ] 切換過程有淡入淡出效果
- [ ] 切換後動畫（呼吸、眨眼）正常
- [ ] X 按鈕可關閉 Selector
- [ ] 重新整理後 Avatar 選擇保留
- [ ] 行動裝置版面正常顯示

### 已知問題與注意事項

**效能考量**:
- ⚠️ 切換 Avatar 需重新載入 GLB（2-5 秒）
- ⚠️ 頻繁切換會增加網路流量
- 解決方案：useGLTF 內建快取機制

**縮圖顯示**:
- ⚠️ 當前使用 Emoji placeholder
- ⚠️ 正式版需實作真實 Avatar 縮圖
- 解決方案：Ready Player Me API 或手動截圖

**狀態同步**:
- ⚠️ 如多個視窗開啟，狀態不會同步
- 解決方案：使用 localStorage 事件監聽（進階）

**快取管理**:
- ⚠️ 長時間使用可能佔用大量記憶體（多個 Avatar 快取）
- 解決方案：定期清理 useGLTF 快取（正式版）

### 效能優化建議

**優化 1: 預載入 Avatar**
```typescript
// 預先載入所有 Avatar，減少切換等待
import { preloadAvatar } from '@/components/avatar/AvatarModel';

useEffect(() => {
  AVATARS.forEach((avatar) => {
    preloadAvatar(avatar.url);
  });
}, []);
```

**優化 2: 縮圖快取**
```typescript
// 使用 Next.js Image 組件優化縮圖載入
import Image from 'next/image';

<Image
  src={avatar.thumbnail}
  alt={avatar.name}
  width={200}
  height={200}
  className="rounded-lg"
/>
```

**優化 3: 虛擬化列表**
```typescript
// 如 Avatar 數量 > 10，使用虛擬化列表
import { useVirtualizer } from '@tanstack/react-virtual';

// 只渲染可見的卡片，提升效能
```

**優化 4: 記憶體管理**
```typescript
// 定期清理 useGLTF 快取
import { useGLTF } from '@react-three/drei';

// 清理所有快取
useGLTF.clear();

// 清理特定模型
useGLTF.clear(modelUrl);
```

### 未來擴展方向

**進階功能**:
1. **Avatar 自訂**:
   - 整合 Ready Player Me Creator
   - 允許使用者建立自己的 Avatar
   - 儲存自訂 Avatar URL

2. **Avatar 分類**:
   - 分類：男性、女性、中性、卡通
   - 標籤：休閒、正式、科技、藝術
   - 搜尋與篩選功能

3. **Avatar 預覽**:
   - 懸浮時顯示 3D 預覽（Tooltip）
   - 使用縮小版 Three.js 場景
   - 顯示 Avatar 動畫預覽

4. **社交功能**:
   - 分享 Avatar 設定
   - Avatar 收藏夾
   - 熱門 Avatar 排行

### 依賴關係

**前置條件**:
- ✅ Story 2.1 已完成（Three.js 場景）
- ✅ Story 2.2 已完成（Avatar 模型載入）
- ✅ Story 2.3 已完成（待機動畫）
- ✅ Story 2.4 已完成（表情控制）
- ✅ 至少 3 個 Ready Player Me Avatar GLB URL

**後續 Epic 依賴**:
- Epic 3 (Lip Sync): 會使用相同的 Avatar
- Epic 4 (情緒系統): 會根據情緒切換表情
- Epic 5 (記憶功能): 會記憶使用者偏好 Avatar

**Epic 2 完成標準**:
- ✅ 所有 5 個 Stories 完成
- ✅ Avatar 可正常渲染與切換
- ✅ 待機動畫與表情控制正常運作
- ✅ UI 互動流暢無 Bug
- ✅ 效能達標（≥30 FPS）

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-14 | 1.0 | 建立 Story 2.5 草稿 | SM Agent |

---

## Dev Agent Record

*(此部分由 Dev Agent 在實作時填寫)*

### Agent Model Used
_待填寫_

### Debug Log References
_待填寫_

### Completion Notes List
_待填寫_

### File List
_待填寫_

---

## QA Results

*(此部分由 QA Agent 在審核時填寫)*

_待填寫_

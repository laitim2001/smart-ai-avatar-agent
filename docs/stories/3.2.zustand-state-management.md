# Story 3.2: Zustand 狀態管理設定

## Status
Approved

---

## Story

**As a** 開發者,
**I want** 建立 Zustand 狀態管理（chatStore, audioStore），集中管理對話與音訊狀態，
**so that** 不同組件可以共享狀態，簡化資料流與狀態同步。

---

## Acceptance Criteria

1. 安裝 Zustand 依賴：`pnpm add zustand`
2. 建立 `stores/chatStore.ts`，管理對話狀態（訊息陣列、輸入文字、Loading 狀態）
3. chatStore 提供 actions：`sendMessage`, `addMessage`, `clearMessages`, `setInput`, `setLoading`
4. 建立 `stores/audioStore.ts`，管理音訊狀態（播放狀態、音訊佇列、當前音訊）
5. audioStore 提供 actions：`playAudio`, `pauseAudio`, `stopAudio`, `addToQueue`, `clearQueue`
6. 兩個 Store 獨立運作，互不干擾（關注點分離）
7. 在 ChatInterface 組件中整合 chatStore，移除本地 useState（重構 Story 3.1）

---

## Tasks / Subtasks

- [ ] **Task 1: 安裝 Zustand 依賴** (AC: 1)
  - [ ] 執行 `pnpm add zustand`（安裝 Zustand 4.5+ 版本）
  - [ ] 驗證 `package.json` 中已新增 `zustand` 依賴
  - [ ] 執行 `pnpm install` 確保依賴正確安裝
  - [ ] 檢查無安裝錯誤或警告訊息

- [ ] **Task 2: 建立 Chat State 型別定義** (AC: 2)
  - [ ] 建立或更新 `types/chat.ts` 檔案
  - [ ] 定義 Message 介面：
    ```typescript
    export interface Message {
      id: string;
      role: 'user' | 'avatar';
      content: string;
      timestamp: Date;
    }
    ```
  - [ ] 定義 ChatStore 介面：
    ```typescript
    export interface ChatStore {
      // State
      messages: Message[];
      input: string;
      isLoading: boolean;

      // Actions
      sendMessage: () => void;
      addMessage: (message: Message) => void;
      clearMessages: () => void;
      setInput: (input: string) => void;
      setLoading: (isLoading: boolean) => void;
    }
    ```
  - [ ] 加入 JSDoc 註解說明每個欄位與方法用途
  - [ ] 驗證型別定義完整且正確

- [ ] **Task 3: 實作 chatStore Zustand Store** (AC: 2, 3)
  - [ ] 建立目錄 `stores/`（如尚未存在）
  - [ ] 建立 `stores/chatStore.ts` 檔案
  - [ ] 實作 chatStore：
    ```typescript
    import { create } from 'zustand';
    import { Message, ChatStore } from '@/types/chat';

    export const useChatStore = create<ChatStore>((set, get) => ({
      // Initial State
      messages: [],
      input: '',
      isLoading: false,

      // Actions
      sendMessage: () => {
        const { input, isLoading } = get();

        // 驗證輸入與狀態
        if (input.trim() === '' || isLoading) return;

        // 建立使用者訊息
        const userMessage: Message = {
          id: `user-${Date.now()}`,
          role: 'user',
          content: input.trim(),
          timestamp: new Date()
        };

        // 更新狀態
        set((state) => ({
          messages: [...state.messages, userMessage],
          input: '',
          isLoading: true
        }));

        // 後續 Story 3.3 將整合真實 API
        // 目前使用模擬回應驗證 Store 運作
        setTimeout(() => {
          const avatarMessage: Message = {
            id: `avatar-${Date.now()}`,
            role: 'avatar',
            content: '這是 Avatar 的測試回應（來自 chatStore）',
            timestamp: new Date()
          };

          set((state) => ({
            messages: [...state.messages, avatarMessage],
            isLoading: false
          }));
        }, 1500);
      },

      addMessage: (message) => {
        set((state) => ({
          messages: [...state.messages, message]
        }));
      },

      clearMessages: () => {
        set({ messages: [] });
      },

      setInput: (input) => {
        set({ input });
      },

      setLoading: (isLoading) => {
        set({ isLoading });
      }
    }));
    ```
  - [ ] 加入 JSDoc 註解說明 Store 用途與 Actions
  - [ ] 驗證 Store 建立無錯誤

- [ ] **Task 4: 建立 Audio State 型別定義** (AC: 4)
  - [ ] 建立 `types/audio.ts` 檔案
  - [ ] 定義 AudioState 列舉：
    ```typescript
    export enum AudioState {
      IDLE = 'idle',
      PLAYING = 'playing',
      PAUSED = 'paused',
      LOADING = 'loading'
    }
    ```
  - [ ] 定義 AudioItem 介面：
    ```typescript
    export interface AudioItem {
      id: string;
      url: string;          // 音訊 URL（來自 TTS API 或本地檔案）
      text: string;         // 對應的文字內容（用於 lip sync）
      duration?: number;    // 音訊長度（秒）
      timestamp: Date;      // 加入佇列時間
    }
    ```
  - [ ] 定義 AudioStore 介面：
    ```typescript
    export interface AudioStore {
      // State
      state: AudioState;
      queue: AudioItem[];
      currentAudio: AudioItem | null;
      volume: number;       // 音量 (0-1)

      // Actions
      playAudio: (audio: AudioItem) => void;
      pauseAudio: () => void;
      stopAudio: () => void;
      resumeAudio: () => void;
      addToQueue: (audio: AudioItem) => void;
      clearQueue: () => void;
      setVolume: (volume: number) => void;
      playNext: () => void; // 播放佇列中下一個音訊
    }
    ```
  - [ ] 加入 JSDoc 註解說明每個欄位與方法用途
  - [ ] 驗證型別定義完整且正確

- [ ] **Task 5: 實作 audioStore Zustand Store** (AC: 4, 5)
  - [ ] 建立 `stores/audioStore.ts` 檔案
  - [ ] 實作 audioStore：
    ```typescript
    import { create } from 'zustand';
    import { AudioState, AudioItem, AudioStore } from '@/types/audio';

    export const useAudioStore = create<AudioStore>((set, get) => ({
      // Initial State
      state: AudioState.IDLE,
      queue: [],
      currentAudio: null,
      volume: 1.0,

      // Actions
      playAudio: (audio) => {
        set({
          currentAudio: audio,
          state: AudioState.PLAYING
        });
        // 實際播放邏輯將在 Story 3.6 實作（Web Audio API）
      },

      pauseAudio: () => {
        const { state } = get();
        if (state === AudioState.PLAYING) {
          set({ state: AudioState.PAUSED });
          // 實際暫停邏輯將在 Story 3.6 實作
        }
      },

      stopAudio: () => {
        set({
          currentAudio: null,
          state: AudioState.IDLE
        });
        // 實際停止邏輯將在 Story 3.6 實作
      },

      resumeAudio: () => {
        const { state, currentAudio } = get();
        if (state === AudioState.PAUSED && currentAudio) {
          set({ state: AudioState.PLAYING });
          // 實際恢復播放邏輯將在 Story 3.6 實作
        }
      },

      addToQueue: (audio) => {
        set((state) => ({
          queue: [...state.queue, audio]
        }));
      },

      clearQueue: () => {
        set({ queue: [] });
      },

      setVolume: (volume) => {
        // 限制音量範圍 0-1
        const clampedVolume = Math.max(0, Math.min(1, volume));
        set({ volume: clampedVolume });
        // 實際音量調整邏輯將在 Story 3.6 實作
      },

      playNext: () => {
        const { queue } = get();
        if (queue.length > 0) {
          const [nextAudio, ...remainingQueue] = queue;
          set({
            currentAudio: nextAudio,
            queue: remainingQueue,
            state: AudioState.PLAYING
          });
          // 實際播放邏輯將在 Story 3.6 實作
        } else {
          set({
            currentAudio: null,
            state: AudioState.IDLE
          });
        }
      }
    }));
    ```
  - [ ] 加入 JSDoc 註解說明 Store 用途與 Actions
  - [ ] 加入音量範圍限制邏輯（0-1）
  - [ ] 驗證 Store 建立無錯誤

- [ ] **Task 6: 驗證兩個 Store 獨立運作** (AC: 6)
  - [ ] 在開發工具中測試 chatStore 與 audioStore 獨立性
  - [ ] 建立測試檔案 `test-stores.ts`（開發用，非正式測試）：
    ```typescript
    import { useChatStore } from '@/stores/chatStore';
    import { useAudioStore } from '@/stores/audioStore';

    // 測試 chatStore
    const chatState = useChatStore.getState();
    console.log('Initial chat state:', chatState);

    chatState.setInput('測試訊息');
    chatState.sendMessage();
    console.log('After sendMessage:', useChatStore.getState().messages);

    // 測試 audioStore
    const audioState = useAudioStore.getState();
    console.log('Initial audio state:', audioState);

    audioState.addToQueue({
      id: 'test-audio-1',
      url: 'https://example.com/audio.mp3',
      text: '測試音訊',
      timestamp: new Date()
    });
    console.log('After addToQueue:', useAudioStore.getState().queue);

    // 驗證互不干擾
    console.log('Chat state after audio operation:', useChatStore.getState());
    console.log('Audio state after chat operation:', useAudioStore.getState());
    ```
  - [ ] 執行測試檔案驗證兩個 Store 獨立運作
  - [ ] 確認 chatStore 操作不影響 audioStore，反之亦然
  - [ ] 驗證完成後移除或註解測試檔案

- [ ] **Task 7: 重構 ChatInterface 整合 chatStore** (AC: 7)
  - [ ] 開啟 `components/chat/ChatInterface.tsx`
  - [ ] 移除本地 `useState` hooks：
    ```typescript
    // 移除
    const [messages, setMessages] = useState<Message[]>([]);
    const [input, setInput] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    ```
  - [ ] 整合 chatStore：
    ```typescript
    import { useChatStore } from '@/stores/chatStore';

    export default function ChatInterface() {
      const {
        messages,
        input,
        isLoading,
        sendMessage,
        clearMessages,
        setInput
      } = useChatStore();

      const messagesEndRef = useRef<HTMLDivElement>(null);

      // 自動滾動邏輯保持不變
      useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
      }, [messages]);

      return (
        <div className="flex flex-col h-full bg-white rounded-lg shadow-lg">
          {/* 對話歷史區域 */}
          <div className="flex-1 overflow-y-auto p-4 space-y-4">
            {messages.length === 0 ? (
              <div className="flex items-center justify-center h-full text-gray-400">
                <p>開始與 Avatar 對話...</p>
              </div>
            ) : (
              messages.slice(-5).map((message) => (
                <div
                  key={message.id}
                  className={`flex ${message.role === 'user' ? 'justify-end' : 'justify-start'}`}
                >
                  <div
                    className={`max-w-[70%] rounded-lg px-4 py-2 ${
                      message.role === 'user'
                        ? 'bg-blue-600 text-white'
                        : 'bg-gray-200 text-gray-900'
                    }`}
                  >
                    <p className="text-sm whitespace-pre-wrap break-words">
                      {message.content}
                    </p>
                    <p className="text-xs mt-1 opacity-70">
                      {message.timestamp.toLocaleTimeString('zh-TW', {
                        hour: '2-digit',
                        minute: '2-digit'
                      })}
                    </p>
                  </div>
                </div>
              ))
            )}
            <div ref={messagesEndRef} />
          </div>

          {/* 輸入區域 */}
          <div className="border-t border-gray-200 p-4 bg-gray-50">
            <div className="flex items-end space-x-2">
              <textarea
                value={input}
                onChange={(e) => setInput(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                  }
                }}
                placeholder="輸入訊息與 Avatar 對話..."
                disabled={isLoading}
                rows={1}
                className="flex-1 resize-none rounded-lg border border-gray-300 px-4 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:bg-gray-100 disabled:cursor-not-allowed"
              />
              <button
                onClick={sendMessage}
                disabled={isLoading || input.trim() === ''}
                className="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 disabled:bg-gray-300 disabled:cursor-not-allowed transition-colors flex items-center space-x-2"
              >
                {isLoading ? (
                  <>
                    <Spinner />
                    <span>傳送中...</span>
                  </>
                ) : (
                  <span>送出</span>
                )}
              </button>
              <button
                onClick={() => {
                  if (window.confirm('確定要清除所有對話紀錄嗎？')) {
                    clearMessages();
                  }
                }}
                disabled={isLoading || messages.length === 0}
                className="bg-gray-200 text-gray-700 px-4 py-2 rounded-lg hover:bg-gray-300 disabled:bg-gray-100 disabled:cursor-not-allowed transition-colors"
              >
                清除
              </button>
            </div>
          </div>
        </div>
      );
    }
    ```
  - [ ] 移除本地 `handleSend`, `handleClear`, `handleKeyDown` 函式（邏輯已整合至 Store）
  - [ ] 驗證重構後組件正常運作
  - [ ] 測試所有功能與 Story 3.1 一致

- [ ] **Task 8: 整合測試與驗證** (AC: 1-7)
  - [ ] 執行 `pnpm dev` 啟動開發伺服器
  - [ ] 開啟 `http://localhost:3000` 驗證應用正常啟動
  - [ ] 測試 ChatInterface 功能（使用 chatStore）：
    - [ ] 輸入文字並送出訊息
    - [ ] 訊息正確顯示（使用者藍色右側、Avatar 灰色左側）
    - [ ] 自動滾動到最新訊息
    - [ ] Loading 狀態顯示 Spinner 且禁用輸入
    - [ ] 清除按鈕清空所有訊息
    - [ ] 顯示最近 5 則訊息限制
  - [ ] 使用 React DevTools 檢查 Zustand Store 狀態：
    - [ ] chatStore 狀態正確更新（messages, input, isLoading）
    - [ ] audioStore 保持獨立（未受 chatStore 影響）
  - [ ] 驗證 Console 無錯誤或警告訊息
  - [ ] 驗證型別檢查通過（`pnpm run type-check`）

---

## Dev Notes

### 相關來源樹（Source Tree）

根據架構文件，本 Story 涉及的檔案結構：

```
avatar-chat-poc/
├── stores/
│   ├── chatStore.ts        # Zustand Chat 狀態管理 (本 Story)
│   ├── audioStore.ts       # Zustand Audio 狀態管理 (本 Story)
│   └── avatarStore.ts      # Zustand Avatar 狀態管理 (Epic 2)
├── types/
│   ├── chat.ts             # Chat 相關型別定義 (本 Story)
│   ├── audio.ts            # Audio 相關型別定義 (本 Story)
│   └── avatar.ts           # Avatar 相關型別定義 (Epic 2)
├── components/
│   └── chat/
│       └── ChatInterface.tsx  # 對話介面組件 (重構整合 chatStore)
└── package.json            # 加入 zustand 依賴
```

### 技術實作細節

**Zustand 核心概念**：
- **輕量級狀態管理**: 無需 Provider，直接使用 Hooks
- **簡潔 API**: `create()` 建立 Store，`set()` 更新狀態，`get()` 讀取狀態
- **TypeScript 支援**: 原生 TypeScript，型別推斷完整
- **效能優化**: 只有使用到的狀態變更才會觸發重渲染
- **DevTools 整合**: 可與 Redux DevTools 整合（選用）

**chatStore 設計原理**：
```typescript
create<ChatStore>((set, get) => ({
  // State: 直接定義初始狀態
  messages: [],
  input: '',
  isLoading: false,

  // Actions: 使用 set() 更新狀態
  sendMessage: () => {
    const { input, isLoading } = get();  // 讀取當前狀態

    set((state) => ({                     // 更新狀態
      messages: [...state.messages, userMessage],
      input: '',
      isLoading: true
    }));
  }
}));
```

**為何使用 `set((state) => (...))`？**
- ✅ 確保基於最新狀態更新（避免 stale closure 問題）
- ✅ 可同時更新多個狀態欄位
- ✅ 更新時可存取當前狀態（如 `state.messages`）

**audioStore 佇列管理邏輯**：
```typescript
playNext: () => {
  const { queue } = get();
  if (queue.length > 0) {
    const [nextAudio, ...remainingQueue] = queue;  // 解構取出第一個音訊
    set({
      currentAudio: nextAudio,
      queue: remainingQueue,                       // 更新佇列（移除已播放）
      state: AudioState.PLAYING
    });
  }
}
```

**Store 獨立性設計**：
- chatStore 與 audioStore 完全獨立，無互相引用
- 各自管理專屬狀態與邏輯
- 後續 Story 3.7 會透過 E2E 流程協調兩者（在應用層而非 Store 層）

**重構策略（Story 3.1 → 3.2）**：
```typescript
// Before: 本地 state
const [messages, setMessages] = useState<Message[]>([]);
const [input, setInput] = useState('');
const [isLoading, setIsLoading] = useState(false);

// After: Zustand store
const { messages, input, isLoading, sendMessage, setInput, clearMessages } = useChatStore();
```

**優勢**：
- ✅ 移除 95% 本地狀態管理邏輯
- ✅ Actions 集中管理，邏輯可重複使用
- ✅ 其他組件可輕鬆存取相同狀態（如未來的 ChatHistory 組件）

### 重要架構決策

1. **為何選擇 Zustand 而非 Redux 或 Context？**
   - ✅ **Zustand 優勢**:
     - 極簡 API，學習曲線低
     - 無需 Provider 包裝，使用簡單
     - Bundle size 小（~1KB）
     - TypeScript 支援完整
     - 效能優異（精準訂閱，避免不必要重渲染）
   - ❌ **Redux 劣勢**: Boilerplate 過多，POC 階段過度工程化
   - ❌ **Context 劣勢**: 效能問題（狀態變更會重渲染所有消費者）

2. **為何分離 chatStore 與 audioStore？**
   - ✅ **關注點分離**: 對話邏輯與音訊邏輯互不干擾
   - ✅ **可維護性**: 各自獨立測試與修改
   - ✅ **效能優化**: 只訂閱需要的 Store，減少重渲染
   - ✅ **可擴展性**: 未來可輕鬆加入 `videoStore`, `settingsStore` 等

3. **為何 audioStore 現階段不實作播放邏輯？**
   - ✅ 本 Story 專注於狀態管理架構
   - ✅ Story 3.6 將整合 Web Audio API 實作播放邏輯
   - ✅ 現階段建立 Store 架構，後續只需填充播放邏輯
   - ✅ 符合循序漸進原則（架構先行，功能後補）

4. **為何 chatStore.sendMessage 仍使用模擬回應？**
   - ✅ 驗證 Store 邏輯正確性
   - ✅ Story 3.3 將整合真實 Azure OpenAI API
   - ✅ Story 3.4 將整合 SSE 串流接收
   - ✅ 模擬邏輯後續會被完全替換

5. **為何需要 AudioItem.text 欄位？**
   - ✅ 用於 Lip Sync（唇型同步），將在 Story 3.6/3.7 使用
   - ✅ 提供文字與音訊對應關係（用於除錯與 UI 顯示）
   - ✅ 可用於未來字幕功能擴展

### Testing

**測試框架**: 手動測試 + React DevTools + Chrome DevTools（POC 階段）

**測試範圍**:
1. ✅ Zustand 依賴正確安裝
2. ✅ chatStore 建立無錯誤，型別正確
3. ✅ audioStore 建立無錯誤,型別正確
4. ✅ chatStore actions 正常運作（sendMessage, addMessage, clearMessages, setInput, setLoading）
5. ✅ audioStore actions 正常運作（playAudio, pauseAudio, stopAudio, addToQueue, clearQueue, playNext）
6. ✅ 兩個 Store 獨立運作，互不干擾
7. ✅ ChatInterface 重構後功能與 Story 3.1 一致
8. ✅ React DevTools 顯示 Zustand Store 狀態正確

**測試執行方式**:
```bash
# 啟動開發伺服器
pnpm dev

# 瀏覽器開啟
http://localhost:3000

# 測試項目
1. 功能測試：ChatInterface 所有功能（與 Story 3.1 相同）
2. DevTools 測試：
   - 開啟 React DevTools
   - 選擇 ChatInterface 組件
   - 檢查 hooks 中是否顯示 useChatStore
   - 送出訊息後檢查 messages 陣列更新
3. Console 測試：
   - 在 Console 執行 `useChatStore.getState()` 檢查 chatStore 狀態
   - 在 Console 執行 `useAudioStore.getState()` 檢查 audioStore 狀態
4. 獨立性測試：
   - 執行 chatStore actions，確認 audioStore 狀態不變
   - 執行 audioStore actions，確認 chatStore 狀態不變
```

**驗證清單**:
- [ ] `pnpm dev` 啟動無錯誤
- [ ] chatStore 與 audioStore 建立成功
- [ ] ChatInterface 重構後功能與 Story 3.1 一致
- [ ] 送出訊息後 chatStore.messages 正確更新
- [ ] 清除訊息後 chatStore.messages 清空
- [ ] Loading 狀態正確反映在 chatStore.isLoading
- [ ] audioStore 預設狀態正確（idle, 空佇列, null currentAudio, volume 1.0）
- [ ] React DevTools 顯示 Zustand hooks 正常
- [ ] Console 執行 `getState()` 顯示正確狀態
- [ ] 型別檢查通過（無 TypeScript 錯誤）
- [ ] Console 無錯誤或警告訊息

**React DevTools 檢查步驟**:
1. 安裝 React DevTools 瀏覽器擴充套件
2. 開啟 `http://localhost:3000`
3. 開啟 React DevTools (F12 → Components 標籤)
4. 選擇 ChatInterface 組件
5. 右側 Hooks 區域應顯示 `useChatStore` hook
6. 展開 hook 應看到 messages, input, isLoading, sendMessage 等
7. 送出訊息後，觀察 messages 陣列即時更新

### 效能考量

**Zustand 效能優勢**:
- **精準訂閱**: 只訂閱使用的狀態，避免不必要重渲染
  ```typescript
  // ✅ 只訂閱 messages，input 變更不會重渲染
  const messages = useChatStore((state) => state.messages);

  // ❌ 訂閱整個 store，任何狀態變更都會重渲染
  const { messages, input, isLoading } = useChatStore();
  ```
- **淺層比較**: Zustand 預設使用淺層比較，減少計算成本
- **無 Provider**: 避免 Context Provider 的效能問題

**本 Story 的訂閱策略**:
- ChatInterface: 訂閱整個 store（組件需要所有狀態）
- 未來組件可使用選擇器（如只訂閱 `messages` 的歷史記錄組件）

**記憶體管理**:
- **訊息陣列**: POC 階段無限制，正式版可實作訊息上限（如 100 則）
- **音訊佇列**: 需實作佇列上限（避免記憶體膨脹），建議 10-20 個音訊項目

**未來優化方向**（MVP 階段）:
1. **選擇器優化**: 使用 `useShallow` 或自訂選擇器減少重渲染
2. **持久化**: 使用 `zustand/middleware` 的 `persist` 儲存對話歷史
3. **DevTools 整合**: 加入 `devtools` middleware 方便除錯
4. **訂閱拆分**: 大型組件拆分為小組件，各自訂閱需要的狀態

### 安全性考量

**狀態管理安全**:
- ✅ Zustand 狀態在客戶端，無伺服器資料外洩風險
- ✅ 所有 Actions 在 Store 內封裝，避免狀態被外部直接修改
- ⚠️ 敏感資料（如 API Keys）不應儲存在 Zustand Store（使用環境變數）

**型別安全**:
- ✅ TypeScript 完整型別定義，避免執行時錯誤
- ✅ 所有 Actions 有明確型別，防止誤用
- ✅ Message 與 AudioItem 介面確保資料結構一致

**未來考量**（MVP 階段）:
- 對話持久化需考慮本地儲存安全（加密敏感訊息）
- Audio URL 需驗證來源（避免注入惡意音訊）

### 依賴關係

**前置條件**:
- ✅ Story 1.1 已完成（Next.js 專案已建立）
- ✅ Story 3.1 已完成（ChatInterface 組件已建立）
- ✅ Node.js 18+ 與 pnpm 已安裝

**後續 Story 依賴**:
- **Story 3.3**: 會在 chatStore.sendMessage 中整合真實 Azure OpenAI API，替換模擬回應
- **Story 3.4**: 會在 chatStore 中加入 SSE 串流處理邏輯
- **Story 3.5**: 會使用 chatStore.messages 產生 TTS 請求
- **Story 3.6**: 會實作 audioStore 的實際播放邏輯（Web Audio API）
- **Story 3.7**: 會協調 chatStore 與 audioStore，實現端到端對話流程

**關鍵路徑**:
- 本 Story 是 Epic 3 的狀態管理基礎，必須優先完成
- 所有後續功能（API 整合、音訊播放）都依賴此狀態管理架構
- chatStore 與 audioStore 分離設計，支援並行開發

**與其他 Epic 整合**:
- **Epic 2**: avatarStore（已存在）與本 Story 的 Stores 獨立運作
- **Story 3.7**: 會整合 chatStore, audioStore, avatarStore 實現完整體驗

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-14 | 1.0 | 建立 Story 3.2 草稿 | SM Agent |

---

## Dev Agent Record

*(此部分由 Dev Agent 在實作時填寫)*

### Agent Model Used
_待填寫_

### Debug Log References
_待填寫_

### Completion Notes List
_待填寫_

### File List
_待填寫_

---

## QA Results

*(此部分由 QA Agent 在審核時填寫)*

_待填寫_

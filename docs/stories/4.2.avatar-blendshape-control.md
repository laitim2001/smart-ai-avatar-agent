# Story 4.2: Avatar Blendshape 控制與嘴型驅動

## Status
Draft

---

## Story

**As a** 開發者,
**I want** 將 viseme 數據映射到 Avatar 的 blendshapes，控制嘴型變化,
**so that** Avatar 的嘴型可以根據語音動態變化。

---

## Acceptance Criteria

1. 識別 Ready Player Me Avatar 的嘴型 blendshapes（如：`mouthOpen`, `mouthSmile` 等）
2. 建立 viseme 到 blendshape 的映射函式：`applyViseme(mesh, viseme, weight)`
3. 實作 blendshape 權重控制：`aa` → `mouthOpen` (weight 1.0)、`E` → `mouthOpen` (weight 0.5)、`neutral` → 所有嘴型 blendshape (weight 0)
4. 使用 `useFrame` hook 即時更新 blendshape
5. 測試：手動設定 viseme，Avatar 嘴型正確變化
6. 嘴型變化流暢無抖動

---

## Tasks / Subtasks

- [ ] **Task 1: 分析 Ready Player Me Avatar Blendshape 結構** (AC: 1)
  - [ ] 建立測試腳本 `scripts/test/inspect-avatar-blendshapes.ts`
  - [ ] 實作 Avatar 模型載入與 blendshape 檢查：
    ```typescript
    /**
     * 檢查 Ready Player Me Avatar 可用的 Blendshapes
     * 用於識別嘴型控制的 morph targets
     */

    import * as THREE from 'three';
    import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';

    async function inspectAvatarBlendshapes() {
      console.log('=== Avatar Blendshape Inspector ===\n');

      const loader = new GLTFLoader();

      // 載入測試 Avatar 模型（使用 Story 2.2 的預設 Avatar）
      const avatarUrl = 'https://models.readyplayer.me/[YOUR_AVATAR_ID].glb';

      try {
        console.log('📂 Loading Avatar model...');
        const gltf = await loader.loadAsync(avatarUrl);

        console.log('✅ Avatar loaded successfully\n');

        // 遍歷場景中的所有 Mesh
        gltf.scene.traverse((child) => {
          if (child instanceof THREE.SkinnedMesh && child.morphTargetDictionary) {
            console.log(`📦 Found SkinnedMesh: ${child.name}`);
            console.log(`   Morph Targets Count: ${Object.keys(child.morphTargetDictionary).length}\n`);

            // 列出所有 morph targets（blendshapes）
            console.log('🎭 Available Blendshapes:');
            Object.entries(child.morphTargetDictionary).forEach(([name, index]) => {
              console.log(`   [${index}] ${name}`);
            });

            // 特別標註嘴型相關的 blendshapes
            console.log('\n👄 Mouth-Related Blendshapes:');
            const mouthBlendshapes = Object.keys(child.morphTargetDictionary).filter(
              name => name.toLowerCase().includes('mouth') ||
                      name.toLowerCase().includes('jaw') ||
                      name.toLowerCase().includes('lips')
            );

            if (mouthBlendshapes.length > 0) {
              mouthBlendshapes.forEach(name => {
                const index = child.morphTargetDictionary[name];
                console.log(`   ✓ ${name} (index: ${index})`);
              });
            } else {
              console.log('   ⚠️  No mouth-related blendshapes found!');
            }

            console.log('\n');
          }
        });

      } catch (error) {
        console.error('❌ Failed to load Avatar:', error);
      }
    }

    // 執行檢查
    inspectAvatarBlendshapes();
    ```
  - [ ] 執行腳本：`pnpm tsx scripts/test/inspect-avatar-blendshapes.ts`
  - [ ] 記錄所有嘴型相關 blendshape 名稱（預期：`mouthOpen`, `mouthSmile`, `mouthPucker`, `jawOpen` 等）
  - [ ] 建立 blendshape 名稱對照表於 Dev Notes

- [ ] **Task 2: 建立 Blendshape 型別定義與映射表** (AC: 2, 3)
  - [ ] 更新 `types/lipsync.ts` 加入 blendshape 型別
  - [ ] 定義 Blendshape 映射介面：
    ```typescript
    /**
     * Avatar Blendshape 名稱（Ready Player Me 標準）
     * 實際可用名稱需透過模型檢查確認
     */
    export interface AvatarBlendshapes {
      /** 嘴巴開合（主要控制） */
      mouthOpen?: number;
      /** 微笑 */
      mouthSmile?: number;
      /** 嘟嘴 */
      mouthPucker?: number;
      /** 下巴開合 */
      jawOpen?: number;
      /** 嘴角向左 */
      mouthLeft?: number;
      /** 嘴角向右 */
      mouthRight?: number;
      /** 嘴唇上捲 */
      mouthRollUpper?: number;
      /** 嘴唇下捲 */
      mouthRollLower?: number;
    }

    /**
     * Viseme 到 Blendshape 的映射規則
     * 定義每個 Viseme 如何影響不同的 blendshapes
     */
    export interface VisemeBlendshapeMap {
      viseme: VisemeType;
      blendshapes: {
        blendshapeName: keyof AvatarBlendshapes;
        weightMultiplier: number; // 0-1，控制該 blendshape 的強度比例
      }[];
      description: string; // 嘴型描述
    }
    ```
  - [ ] 定義預設 Viseme 映射表常數：
    ```typescript
    /**
     * POC 階段簡化的 Viseme 映射表
     * 定義每個 Viseme 如何驅動 Avatar blendshapes
     */
    export const DEFAULT_VISEME_BLENDSHAPE_MAP: VisemeBlendshapeMap[] = [
      {
        viseme: 'aa',
        blendshapes: [
          { blendshapeName: 'mouthOpen', weightMultiplier: 1.0 },
          { blendshapeName: 'jawOpen', weightMultiplier: 0.8 }
        ],
        description: '張嘴（啊、哈）'
      },
      {
        viseme: 'E',
        blendshapes: [
          { blendshapeName: 'mouthOpen', weightMultiplier: 0.5 },
          { blendshapeName: 'jawOpen', weightMultiplier: 0.3 }
        ],
        description: '半開（欸、誒）'
      },
      {
        viseme: 'I',
        blendshapes: [
          { blendshapeName: 'mouthSmile', weightMultiplier: 0.6 },
          { blendshapeName: 'mouthOpen', weightMultiplier: 0.2 }
        ],
        description: '微笑半開（一、衣）'
      },
      {
        viseme: 'O',
        blendshapes: [
          { blendshapeName: 'mouthPucker', weightMultiplier: 0.7 },
          { blendshapeName: 'mouthOpen', weightMultiplier: 0.4 }
        ],
        description: '嘟嘴（喔、歐）'
      },
      {
        viseme: 'U',
        blendshapes: [
          { blendshapeName: 'mouthPucker', weightMultiplier: 0.8 },
          { blendshapeName: 'mouthOpen', weightMultiplier: 0.3 }
        ],
        description: '嘟嘴緊縮（烏、嗚）'
      },
      {
        viseme: 'neutral',
        blendshapes: [
          { blendshapeName: 'mouthOpen', weightMultiplier: 0.0 },
          { blendshapeName: 'mouthSmile', weightMultiplier: 0.0 },
          { blendshapeName: 'mouthPucker', weightMultiplier: 0.0 },
          { blendshapeName: 'jawOpen', weightMultiplier: 0.0 }
        ],
        description: '閉嘴（靜音）'
      }
    ];
    ```
  - [ ] 加入 JSDoc 註解說明映射邏輯
  - [ ] 驗證型別定義無 TypeScript 錯誤

- [ ] **Task 3: 實作 Blendshape 控制核心函式** (AC: 2, 3)
  - [ ] 建立 `lib/three/blendshape-controller.ts` 檔案
  - [ ] 實作 Blendshape 控制器類別：
    ```typescript
    import * as THREE from 'three';
    import type { VisemeType, VisemeBlendshapeMap, AvatarBlendshapes } from '@/types/lipsync';
    import { DEFAULT_VISEME_BLENDSHAPE_MAP } from '@/types/lipsync';

    /**
     * Avatar Blendshape 控制器
     * 負責將 Viseme 數據映射並應用到 Avatar 模型的 blendshapes
     */
    export class BlendshapeController {
      private mesh: THREE.SkinnedMesh | null = null;
      private morphTargetDictionary: Record<string, number> | null = null;
      private morphTargetInfluences: number[] | null = null;
      private visemeMap: VisemeBlendshapeMap[];

      constructor(visemeMap: VisemeBlendshapeMap[] = DEFAULT_VISEME_BLENDSHAPE_MAP) {
        this.visemeMap = visemeMap;
      }

      /**
       * 初始化控制器，綁定 Avatar Mesh
       *
       * @param avatarMesh - Avatar 的 SkinnedMesh（包含 morph targets）
       * @returns 是否成功初始化
       */
      initialize(avatarMesh: THREE.SkinnedMesh): boolean {
        if (!avatarMesh.morphTargetDictionary || !avatarMesh.morphTargetInfluences) {
          console.error('[BlendshapeController] Avatar mesh does not have morph targets');
          return false;
        }

        this.mesh = avatarMesh;
        this.morphTargetDictionary = avatarMesh.morphTargetDictionary;
        this.morphTargetInfluences = avatarMesh.morphTargetInfluences;

        console.log('[BlendshapeController] Initialized with morph targets:', {
          totalTargets: Object.keys(this.morphTargetDictionary).length,
          availableMouthTargets: this.getAvailableMouthBlendshapes()
        });

        return true;
      }

      /**
       * 取得可用的嘴型 blendshape 列表
       */
      private getAvailableMouthBlendshapes(): string[] {
        if (!this.morphTargetDictionary) return [];

        return Object.keys(this.morphTargetDictionary).filter(
          name => name.toLowerCase().includes('mouth') ||
                  name.toLowerCase().includes('jaw') ||
                  name.toLowerCase().includes('lips')
        );
      }

      /**
       * 應用 Viseme 到 Avatar blendshapes
       *
       * @param viseme - Viseme 類型
       * @param weight - Viseme 權重（0-1）
       */
      applyViseme(viseme: VisemeType, weight: number): void {
        if (!this.mesh || !this.morphTargetDictionary || !this.morphTargetInfluences) {
          console.warn('[BlendshapeController] Controller not initialized');
          return;
        }

        // 找到對應的 Viseme 映射規則
        const mapping = this.visemeMap.find(m => m.viseme === viseme);
        if (!mapping) {
          console.warn(`[BlendshapeController] No mapping found for viseme: ${viseme}`);
          return;
        }

        // 應用每個 blendshape
        mapping.blendshapes.forEach(({ blendshapeName, weightMultiplier }) => {
          const blendshapeIndex = this.morphTargetDictionary![blendshapeName];

          if (blendshapeIndex !== undefined) {
            // 計算最終權重：viseme weight × blendshape multiplier
            const finalWeight = weight * weightMultiplier;
            this.morphTargetInfluences![blendshapeIndex] = Math.max(0, Math.min(1, finalWeight));
          }
        });
      }

      /**
       * 重置所有嘴型 blendshapes 到 neutral 狀態
       */
      resetMouthBlendshapes(): void {
        this.applyViseme('neutral', 0);
      }
    }
    ```
  - [ ] 加入型別檢查與錯誤處理
  - [ ] 驗證 blendshape 權重範圍（0-1）
  - [ ] 測試控制器初始化與應用 viseme 功能

- [ ] **Task 4: 建立 React Hook 封裝 Blendshape 控制** (AC: 4)
  - [ ] 建立 `hooks/useBlendshapeController.ts` 自訂 Hook
  - [ ] 實作 Hook 邏輯：
    ```typescript
    import { useRef, useCallback } from 'react';
    import type { VisemeType } from '@/types/lipsync';
    import { BlendshapeController } from '@/lib/three/blendshape-controller';
    import type * as THREE from 'three';

    /**
     * Blendshape 控制器 Hook
     * 提供簡化的 API 用於 React 組件中控制 Avatar 嘴型
     */
    export function useBlendshapeController() {
      const controllerRef = useRef<BlendshapeController | null>(null);

      /**
       * 初始化控制器（在 Avatar 載入後呼叫）
       */
      const initializeController = useCallback((avatarMesh: THREE.SkinnedMesh) => {
        if (!controllerRef.current) {
          controllerRef.current = new BlendshapeController();
        }

        const success = controllerRef.current.initialize(avatarMesh);

        if (success) {
          console.log('[useBlendshapeController] Controller initialized');
        } else {
          console.error('[useBlendshapeController] Failed to initialize controller');
        }

        return success;
      }, []);

      /**
       * 應用 Viseme
       */
      const applyViseme = useCallback((viseme: VisemeType, weight: number) => {
        if (controllerRef.current) {
          controllerRef.current.applyViseme(viseme, weight);
        } else {
          console.warn('[useBlendshapeController] Controller not initialized yet');
        }
      }, []);

      /**
       * 重置嘴型到 neutral
       */
      const resetMouth = useCallback(() => {
        if (controllerRef.current) {
          controllerRef.current.resetMouthBlendshapes();
        }
      }, []);

      return {
        initializeController,
        applyViseme,
        resetMouth
      };
    }
    ```
  - [ ] 加入 useCallback 優化效能
  - [ ] 加入 JSDoc 註解說明用法
  - [ ] 驗證 Hook 可在組件中正常使用

- [ ] **Task 5: 更新 AvatarModel 組件整合 Blendshape 控制** (AC: 5)
  - [ ] 開啟 `components/avatar/AvatarModel.tsx`（Epic 2 建立）
  - [ ] 整合 useBlendshapeController Hook：
    ```typescript
    'use client';

    import { useRef, useEffect } from 'react';
    import { useGLTF } from '@react-three/drei';
    import { useBlendshapeController } from '@/hooks/useBlendshapeController';
    import type { VisemeType } from '@/types/lipsync';
    import type * as THREE from 'three';

    interface AvatarModelProps {
      avatarUrl: string;
      /** 當前要顯示的 Viseme（測試用） */
      currentViseme?: VisemeType;
      /** Viseme 權重（測試用） */
      visemeWeight?: number;
    }

    export default function AvatarModel({
      avatarUrl,
      currentViseme = 'neutral',
      visemeWeight = 0
    }: AvatarModelProps) {
      const { scene } = useGLTF(avatarUrl);
      const { initializeController, applyViseme } = useBlendshapeController();
      const meshRef = useRef<THREE.SkinnedMesh | null>(null);

      // 初始化 Blendshape 控制器
      useEffect(() => {
        if (scene) {
          // 找到 Avatar 的 SkinnedMesh
          scene.traverse((child) => {
            if (child instanceof THREE.SkinnedMesh && child.morphTargetDictionary) {
              meshRef.current = child;
              initializeController(child);
            }
          });
        }
      }, [scene, initializeController]);

      // 應用 Viseme（測試用，實際會由 LipSyncController 控制）
      useEffect(() => {
        if (meshRef.current && currentViseme) {
          applyViseme(currentViseme, visemeWeight);
        }
      }, [currentViseme, visemeWeight, applyViseme]);

      return <primitive object={scene} />;
    }
    ```
  - [ ] 加入 currentViseme 與 visemeWeight props（測試用）
  - [ ] 測試組件可正確初始化控制器
  - [ ] 驗證 TypeScript 型別無錯誤

- [ ] **Task 6: 建立測試介面驗證嘴型控制** (AC: 5, 6)
  - [ ] 建立測試頁面 `app/test-lipsync/page.tsx`
  - [ ] 實作互動測試介面：
    ```typescript
    'use client';

    import { useState } from 'react';
    import { Canvas } from '@react-three/fiber';
    import { OrbitControls } from '@react-three/drei';
    import AvatarModel from '@/components/avatar/AvatarModel';
    import type { VisemeType } from '@/types/lipsync';

    export default function TestLipSyncPage() {
      const [currentViseme, setCurrentViseme] = useState<VisemeType>('neutral');
      const [visemeWeight, setVisemeWeight] = useState(0.5);

      const visemes: VisemeType[] = ['neutral', 'aa', 'E', 'I', 'O', 'U'];
      const avatarUrl = 'https://models.readyplayer.me/[YOUR_AVATAR_ID].glb';

      return (
        <div className="flex h-screen">
          {/* 左側：3D Avatar */}
          <div className="flex-1 bg-gray-900">
            <Canvas camera={{ position: [0, 1.5, 2], fov: 50 }}>
              <ambientLight intensity={0.5} />
              <directionalLight position={[5, 5, 5]} intensity={1} />
              <AvatarModel
                avatarUrl={avatarUrl}
                currentViseme={currentViseme}
                visemeWeight={visemeWeight}
              />
              <OrbitControls />
            </Canvas>
          </div>

          {/* 右側：控制面板 */}
          <div className="w-96 bg-white p-6 space-y-6">
            <h1 className="text-2xl font-bold text-gray-900">
              Lip Sync Blendshape Test
            </h1>

            {/* Viseme 選擇 */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Viseme Type
              </label>
              <div className="grid grid-cols-3 gap-2">
                {visemes.map(viseme => (
                  <button
                    key={viseme}
                    onClick={() => setCurrentViseme(viseme)}
                    className={`px-4 py-2 rounded-lg font-medium transition-colors ${
                      currentViseme === viseme
                        ? 'bg-blue-600 text-white'
                        : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                    }`}
                  >
                    {viseme}
                  </button>
                ))}
              </div>
            </div>

            {/* Weight 滑桿 */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Viseme Weight: {visemeWeight.toFixed(2)}
              </label>
              <input
                type="range"
                min="0"
                max="1"
                step="0.01"
                value={visemeWeight}
                onChange={(e) => setVisemeWeight(parseFloat(e.target.value))}
                className="w-full"
              />
            </div>

            {/* 當前狀態顯示 */}
            <div className="bg-gray-100 p-4 rounded-lg">
              <h3 className="text-sm font-medium text-gray-700 mb-2">
                Current State
              </h3>
              <div className="text-sm text-gray-600 space-y-1">
                <p>Viseme: <span className="font-mono text-blue-600">{currentViseme}</span></p>
                <p>Weight: <span className="font-mono text-blue-600">{visemeWeight.toFixed(2)}</span></p>
              </div>
            </div>

            {/* 測試提示 */}
            <div className="bg-blue-50 border border-blue-200 p-4 rounded-lg">
              <h3 className="text-sm font-medium text-blue-900 mb-2">
                測試提示
              </h3>
              <ul className="text-xs text-blue-700 space-y-1">
                <li>• 點擊不同 Viseme 觀察嘴型變化</li>
                <li>• 調整 Weight 滑桿觀察嘴型開合程度</li>
                <li>• aa: 張嘴最大，O/U: 嘟嘴，E: 半開</li>
                <li>• neutral: 閉嘴（所有 blendshape 歸零）</li>
              </ul>
            </div>
          </div>
        </div>
      );
    }
    ```
  - [ ] 執行 `pnpm dev` 啟動開發伺服器
  - [ ] 開啟 `http://localhost:3000/test-lipsync`
  - [ ] 測試所有 Viseme 類型：
    - [ ] neutral: 閉嘴（所有 blendshape = 0）
    - [ ] aa: 張嘴最大（mouthOpen ≈ 1.0）
    - [ ] E: 半開（mouthOpen ≈ 0.5）
    - [ ] O: 嘟嘴（mouthPucker ≈ 0.7）
    - [ ] U: 嘟嘴緊縮（mouthPucker ≈ 0.8）
  - [ ] 測試 Weight 滑桿調整嘴型開合程度
  - [ ] 驗證嘴型變化流暢無抖動（AC 6）

- [ ] **Task 7: 優化 Blendshape 過渡平滑度** (AC: 6)
  - [ ] 在 BlendshapeController 加入插值（lerp）邏輯：
    ```typescript
    /**
     * 平滑應用 Viseme（使用線性插值）
     * 避免 blendshape 突變造成抖動
     *
     * @param viseme - Viseme 類型
     * @param targetWeight - 目標權重
     * @param lerpFactor - 插值因子（0-1），越小越平滑，預設 0.3
     */
    applySmoothViseme(viseme: VisemeType, targetWeight: number, lerpFactor: number = 0.3): void {
      if (!this.mesh || !this.morphTargetDictionary || !this.morphTargetInfluences) {
        return;
      }

      const mapping = this.visemeMap.find(m => m.viseme === viseme);
      if (!mapping) return;

      mapping.blendshapes.forEach(({ blendshapeName, weightMultiplier }) => {
        const blendshapeIndex = this.morphTargetDictionary![blendshapeName];

        if (blendshapeIndex !== undefined) {
          const currentWeight = this.morphTargetInfluences![blendshapeIndex];
          const targetFinalWeight = targetWeight * weightMultiplier;

          // 線性插值（lerp）
          const newWeight = currentWeight + (targetFinalWeight - currentWeight) * lerpFactor;

          this.morphTargetInfluences![blendshapeIndex] = Math.max(0, Math.min(1, newWeight));
        }
      });
    }
    ```
  - [ ] 更新 useBlendshapeController Hook 提供平滑版本：
    ```typescript
    const applySmoothViseme = useCallback((viseme: VisemeType, weight: number, lerpFactor?: number) => {
      if (controllerRef.current) {
        controllerRef.current.applySmoothViseme(viseme, weight, lerpFactor);
      }
    }, []);

    return {
      initializeController,
      applyViseme,
      applySmoothViseme, // 新增平滑版本
      resetMouth
    };
    ```
  - [ ] 在測試介面加入平滑開關：
    ```typescript
    const [useSmooth, setUseSmooth] = useState(true);

    useEffect(() => {
      if (meshRef.current && currentViseme) {
        if (useSmooth) {
          applySmoothViseme(currentViseme, visemeWeight);
        } else {
          applyViseme(currentViseme, visemeWeight);
        }
      }
    }, [currentViseme, visemeWeight, useSmooth, applyViseme, applySmoothViseme]);
    ```
  - [ ] 測試平滑與非平滑模式差異
  - [ ] 調整 lerpFactor 找到最佳值（預設 0.3）
  - [ ] 驗證快速切換 Viseme 時無抖動

- [ ] **Task 8: 建立單元測試與文檔** (AC: 1-6)
  - [ ] 建立測試檔案 `lib/three/__tests__/blendshape-controller.test.ts`
  - [ ] 實作基本單元測試：
    ```typescript
    import { describe, it, expect, beforeEach } from 'vitest';
    import { BlendshapeController } from '../blendshape-controller';
    import * as THREE from 'three';

    describe('BlendshapeController', () => {
      let controller: BlendshapeController;
      let mockMesh: THREE.SkinnedMesh;

      beforeEach(() => {
        controller = new BlendshapeController();

        // 建立 mock SkinnedMesh
        const geometry = new THREE.BufferGeometry();
        const material = new THREE.MeshBasicMaterial();
        mockMesh = new THREE.SkinnedMesh(geometry, material);

        // 設定 mock morph targets
        mockMesh.morphTargetDictionary = {
          'mouthOpen': 0,
          'mouthSmile': 1,
          'mouthPucker': 2,
          'jawOpen': 3
        };
        mockMesh.morphTargetInfluences = [0, 0, 0, 0];
      });

      it('should initialize successfully with valid mesh', () => {
        const success = controller.initialize(mockMesh);
        expect(success).toBe(true);
      });

      it('should apply aa viseme correctly', () => {
        controller.initialize(mockMesh);
        controller.applyViseme('aa', 1.0);

        expect(mockMesh.morphTargetInfluences![0]).toBeCloseTo(1.0, 1); // mouthOpen
        expect(mockMesh.morphTargetInfluences![3]).toBeCloseTo(0.8, 1); // jawOpen
      });

      it('should apply neutral viseme (reset all to 0)', () => {
        controller.initialize(mockMesh);
        controller.applyViseme('aa', 1.0);
        controller.applyViseme('neutral', 0);

        expect(mockMesh.morphTargetInfluences![0]).toBe(0);
        expect(mockMesh.morphTargetInfluences![1]).toBe(0);
        expect(mockMesh.morphTargetInfluences![2]).toBe(0);
        expect(mockMesh.morphTargetInfluences![3]).toBe(0);
      });

      it('should clamp weight to 0-1 range', () => {
        controller.initialize(mockMesh);
        controller.applyViseme('aa', 1.5); // 超過 1.0

        expect(mockMesh.morphTargetInfluences![0]).toBeLessThanOrEqual(1.0);
      });
    });
    ```
  - [ ] 執行測試：`pnpm test blendshape-controller`
  - [ ] 確保所有測試通過
  - [ ] 更新 `lib/three/README.md` 加入 Blendshape 控制器文檔：
    ```markdown
    ## Blendshape Controller

    ### Basic Usage
    \`\`\`typescript
    import { BlendshapeController } from '@/lib/three/blendshape-controller';

    const controller = new BlendshapeController();
    controller.initialize(avatarMesh); // SkinnedMesh with morph targets

    // Apply viseme
    controller.applyViseme('aa', 1.0); // 張嘴
    controller.applyViseme('E', 0.5);  // 半開
    controller.applyViseme('neutral', 0); // 閉嘴
    \`\`\`

    ### Smooth Transitions
    \`\`\`typescript
    // 使用平滑過渡避免抖動
    controller.applySmoothViseme('aa', 1.0, 0.3);
    \`\`\`

    ### Available Visemes
    - `aa`: 張嘴（啊、哈）→ mouthOpen: 1.0
    - `E`: 半開（欸、誒）→ mouthOpen: 0.5
    - `I`: 微笑半開（一、衣）→ mouthSmile: 0.6
    - `O`: 嘟嘴（喔、歐）→ mouthPucker: 0.7
    - `U`: 嘟嘴緊縮（烏、嗚）→ mouthPucker: 0.8
    - `neutral`: 閉嘴（靜音）→ all: 0
    ```
  - [ ] 驗證文檔清晰易懂

---

## Dev Notes

### 相關來源樹（Source Tree）

根據架構文件，Story 4.2 的檔案結構：

```
avatar-chat-poc/
├── lib/
│   └── three/
│       ├── blendshape-controller.ts    # Blendshape 控制器 (本 Story)
│       ├── lipsync.ts                  # 音訊分析 (Story 4.1)
│       ├── __tests__/
│       │   └── blendshape-controller.test.ts # 單元測試
│       ├── index.ts                    # Barrel export
│       └── README.md                   # 文檔更新
├── hooks/
│   └── useBlendshapeController.ts      # React Hook 封裝 (本 Story)
├── types/
│   └── lipsync.ts                      # 型別定義更新 (本 Story)
├── components/
│   └── avatar/
│       └── AvatarModel.tsx             # 更新整合 blendshape 控制
├── app/
│   └── test-lipsync/
│       └── page.tsx                    # 測試頁面 (本 Story)
└── scripts/
    └── test/
        └── inspect-avatar-blendshapes.ts # Avatar 檢查腳本
```

### 技術實作細節

**Three.js Morph Targets（Blendshapes）原理**：

```typescript
// Three.js 中的 Morph Target 系統
interface SkinnedMesh {
  morphTargetDictionary: Record<string, number>; // 名稱 → 索引映射
  morphTargetInfluences: number[];                // 權重陣列（0-1）
}

// 範例：
mesh.morphTargetDictionary = {
  'mouthOpen': 0,    // 索引 0
  'mouthSmile': 1    // 索引 1
};

mesh.morphTargetInfluences = [0.5, 0.3]; // mouthOpen: 50%, mouthSmile: 30%

// 權重控制：
// 0 = 原始狀態（無變形）
// 1 = 完全變形（100% blendshape 效果）
// 0.5 = 50% 變形
```

**Viseme 到 Blendshape 映射策略**：

POC 階段簡化映射（一個 Viseme 可影響多個 Blendshapes）：

| Viseme | 主要 Blendshape | 次要 Blendshape | 效果 |
|--------|----------------|----------------|------|
| aa     | mouthOpen (1.0) | jawOpen (0.8) | 大張嘴 |
| E      | mouthOpen (0.5) | jawOpen (0.3) | 半開 |
| I      | mouthSmile (0.6) | mouthOpen (0.2) | 微笑半開 |
| O      | mouthPucker (0.7) | mouthOpen (0.4) | 嘟嘴圓形 |
| U      | mouthPucker (0.8) | mouthOpen (0.3) | 嘟嘴緊縮 |
| neutral | 所有 (0.0) | - | 閉嘴靜止 |

**為何需要多個 Blendshape 組合？**
- ✅ 更自然：單一 blendshape 無法完整模擬真實嘴型
- ✅ 更細緻：組合多個 blendshape 可產生更豐富的表情
- ✅ 符合人類嘴型：例如「啊」需要張嘴 + 張下巴
- ⚠️ 複雜度增加：需要精確調校每個 blendshape 的權重比例

**線性插值（Lerp）平滑過渡原理**：

```typescript
// Lerp 公式：newValue = currentValue + (targetValue - currentValue) * factor
// factor = 0.3 表示每幀移動 30% 的距離

// 範例：
// Frame 1: current = 0.0,  target = 1.0 → new = 0.0 + (1.0 - 0.0) * 0.3 = 0.3
// Frame 2: current = 0.3,  target = 1.0 → new = 0.3 + (1.0 - 0.3) * 0.3 = 0.51
// Frame 3: current = 0.51, target = 1.0 → new = 0.51 + (1.0 - 0.51) * 0.3 = 0.657
// ...漸進式接近 1.0

// 為何需要 Lerp？
// ✅ 平滑過渡：避免 blendshape 突變造成抖動
// ✅ 自然動畫：人類嘴型變化不是瞬間的
// ✅ 效能平衡：每幀計算簡單（一次乘法加法）
// ⚠️ 延遲感：factor 越小越平滑但反應越慢，需調校平衡
```

**Ready Player Me Blendshape 命名慣例**：

根據 Ready Player Me 文檔，標準 blendshape 名稱：

```typescript
// 嘴型相關（Mouth）
- mouthOpen        // 嘴巴開合（上下）
- mouthSmile       // 微笑（嘴角上揚）
- mouthFrown       // 皺眉（嘴角下垂）
- mouthPucker      // 嘟嘴（向前突出）
- mouthLeft        // 嘴角向左
- mouthRight       // 嘴角向右
- mouthRollUpper   // 上嘴唇內捲
- mouthRollLower   // 下嘴唇內捲

// 下巴相關（Jaw）
- jawOpen          // 下巴開合
- jawForward       // 下巴前伸
- jawLeft          // 下巴向左
- jawRight         // 下巴向右
```

### 重要架構決策

1. **為何建立獨立的 BlendshapeController 類別？**
   - ✅ 關注點分離：音訊分析（Story 4.1）與 blendshape 控制解耦
   - ✅ 可重複使用：不同動畫系統都可使用（如手動表情控制）
   - ✅ 易於測試：可 mock SkinnedMesh 進行單元測試
   - ✅ 狀態封裝：morphTargetDictionary 與 influences 集中管理
   - 🔄 未來擴展：可加入表情預設（preset）、動畫時間軸等功能

2. **為何使用映射表（Map）而非硬編碼？**
   - ✅ 配置彈性：可透過 constructor 傳入自訂映射表
   - ✅ 易於調校：修改映射表無需改動程式邏輯
   - ✅ 多 Avatar 支援：不同 Avatar 可能有不同 blendshape 名稱
   - ✅ A/B 測試：可測試不同映射策略找到最佳效果
   - 📝 型別安全：TypeScript 確保映射表結構正確

3. **為何需要 useBlendshapeController Hook？**
   - ✅ React 整合：封裝 ref 與 callback，符合 React Hooks 模式
   - ✅ 生命週期管理：自動處理 controller 初始化與清理
   - ✅ 效能優化：使用 useCallback 避免不必要重渲染
   - ✅ 易於使用：組件中直接呼叫，無需手動管理 controller 實例
   - ⚠️ 注意：Story 4.3 的 LipSyncController 會使用此 Hook

4. **為何需要平滑過渡（Lerp）？**
   - ✅ 視覺流暢：人眼對突變敏感，lerp 提供自然過渡
   - ✅ 避免抖動：快速切換 viseme 時，lerp 平滑化權重變化
   - ✅ 模擬真實：人類嘴型變化有慣性，不是瞬間的
   - ✅ 可調校：lerpFactor 可根據需求調整（快速 vs 平滑）
   - ⚠️ 延遲感：過小的 factor 會導致反應慢，需平衡（預設 0.3）

5. **為何建立測試頁面而非僅單元測試？**
   - ✅ 視覺驗證：blendshape 效果需要視覺確認，單元測試不足
   - ✅ 互動調校：滑桿即時調整權重，快速找到最佳值
   - ✅ Bug 排查：視覺化問題更易發現（如 blendshape 名稱錯誤）
   - ✅ 文檔價值：測試頁面本身是活文檔（live documentation）
   - 🔄 未來保留：MVP 階段可作為開發工具或 Demo 使用

### Testing

**測試框架**: Vitest（單元測試）+ 手動視覺測試（測試頁面）

**測試範圍**:
1. ✅ BlendshapeController 正確初始化
2. ✅ 所有 Viseme 類型正確映射到 blendshapes
3. ✅ 權重值正確限制在 0-1 範圍
4. ✅ neutral Viseme 重置所有 blendshapes 到 0
5. ✅ 平滑過渡（lerp）功能正常
6. ✅ 快速切換 Viseme 無抖動
7. ✅ 測試頁面所有控制項正常運作

**測試執行方式**:
```bash
# 1. 單元測試
pnpm test blendshape-controller

# 預期輸出：
# ✓ should initialize successfully with valid mesh
# ✓ should apply aa viseme correctly
# ✓ should apply neutral viseme (reset all to 0)
# ✓ should clamp weight to 0-1 range

# 2. 視覺測試
pnpm dev
# 瀏覽器開啟 http://localhost:3000/test-lipsync

# 測試項目：
1. 點擊 aa → 嘴巴大張
2. 點擊 E → 嘴巴半開
3. 點擊 O → 嘴巴嘟起（圓形）
4. 點擊 U → 嘴巴嘟起（更緊）
5. 點擊 neutral → 嘴巴閉合
6. 調整 Weight 滑桿 → 嘴型開合程度平滑變化
7. 快速切換不同 Viseme → 過渡流暢無抖動
```

**驗證清單**:
- [ ] 單元測試全部通過（`pnpm test`）
- [ ] Avatar blendshapes 正確識別（inspect 腳本輸出）
- [ ] 所有 Viseme 類型嘴型正確（視覺確認）
- [ ] Weight 滑桿調整平滑無跳躍
- [ ] 快速切換 Viseme 無抖動（開啟/關閉 smooth 對比）
- [ ] console.log 輸出清晰（controller 初始化訊息）
- [ ] TypeScript 編譯無錯誤（`pnpm build`）

### 效能考量

**Blendshape 更新效能**:
- **每幀操作**: 修改 morphTargetInfluences 陣列（純 CPU 操作）
- **GPU 影響**: Three.js 自動上傳至 GPU，無需手動管理
- **效能成本**: 每個 blendshape 約 0.01ms（60fps 下可接受）
- **最佳化**: 僅更新必要的 blendshapes，避免全量更新

**記憶體使用**:
- **Controller 實例**: < 1KB（僅儲存 ref 與映射表）
- **Morph Target 數據**: 由 Three.js 管理，自動釋放
- **無記憶體洩漏**: useRef 確保 controller 生命週期正確

**未來優化方向**（MVP 階段）:
1. **批量更新**: 累積多個 viseme 變更，一次更新 influences
2. **Delta 檢查**: 僅在權重變化 > 閾值時更新（避免微小抖動）
3. **WebWorker**: 將 lerp 計算移至 Worker（實驗性）
4. **Shader 優化**: 自訂 Shader 減少 morph target 計算（進階）

### 安全性考量

**型別安全**:
- ✅ TypeScript 嚴格模式檢查所有型別
- ✅ Viseme 類型使用 string literal union（避免拼寫錯誤）
- ✅ Blendshape 名稱透過 dictionary 檢查（避免不存在的名稱）

**錯誤處理**:
```typescript
// 1. 初始化檢查
if (!mesh.morphTargetDictionary) {
  console.error('Avatar does not have morph targets');
  return false;
}

// 2. 映射檢查
const mapping = this.visemeMap.find(m => m.viseme === viseme);
if (!mapping) {
  console.warn(`No mapping for viseme: ${viseme}`);
  return; // 靜默失敗，不影響其他動畫
}

// 3. Blendshape 存在性檢查
if (blendshapeIndex !== undefined) {
  // 僅更新存在的 blendshape
}
```

**降級方案**:
- ✅ 若 Avatar 無 morph targets，controller 初始化失敗但不崩潰
- ✅ 若 blendshape 名稱不存在，跳過該 blendshape
- ✅ Story 4.5 將實作完整降級方案（無 blendshape 時僅播放音訊）

### 依賴關係

**前置條件**:
- ✅ Story 2.2 已完成（Avatar 模型已載入）
- ✅ Story 4.1 已完成（Viseme 型別定義）
- ✅ Three.js 與 React Three Fiber 已安裝

**後續 Story 依賴**:
- **Story 4.3**: 會使用 useBlendshapeController Hook 整合 Lip Sync
- **Story 4.4**: 會調整 viseme 映射表與 lerp factor
- **Story 4.5**: 會為 blendshape 控制加入錯誤處理

**關鍵路徑**:
- 本 Story 是 Lip Sync 的核心，必須在 Story 4.3 前完成
- Story 4.3（Lip Sync Controller）依賴本 Story 的 blendshape 控制
- Story 4.4（視覺優化）依賴本 Story 的映射表與平滑邏輯

**與其他 Epic 整合**:
- 使用 Epic 2 的 AvatarModel 組件
- 使用 Story 4.1 的 VisemeType 型別定義
- 未來 Story 4.3 會整合 Epic 3 的 audioStore

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-14 | 1.0 | 建立 Story 4.2 草稿 | SM Agent |

---

## Dev Agent Record

*(此部分由 Dev Agent 在實作時填寫)*

### Agent Model Used
_待填寫_

### Debug Log References
_待填寫_

### Completion Notes List
_待填寫_

### File List
_待填寫_

---

## QA Results

*(此部分由 QA Agent 在審核時填寫)*

_待填寫_
